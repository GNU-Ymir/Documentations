<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Ŝablonaj tipoj - Ymir Tour</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        
        <link rel="stylesheet" href="custom.css">
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> Antaŭparolo</a></li><li><a href="hello-world/README.html"><strong>2.</strong> Bonan tagon mondo</a></li><li><ul class="section"><li><a href="hello-world/commentaires.html"><strong>2.1.</strong> Komentoj</a></li></ul></li><li><a href="primitives/README.html"><strong>3.</strong> Bazaj konceptoj de programado</a></li><li><ul class="section"><li><a href="primitives/variables.html"><strong>3.1.</strong> Variabloj kaj Ŝanĝebleco</a></li><li><a href="primitives/types.html"><strong>3.2.</strong> Datenaj tipoj</a></li><li><a href="primitives/functions.html"><strong>3.3.</strong> Funkcioj</a></li><li><a href="primitives/control.html"><strong>3.4.</strong> Kontrolaj fluoj</a></li><li><a href="primitives/operator.html"><strong>3.5.</strong> Prioritato de operacioj</a></li></ul></li><li><a href="advanced/README.html"><strong>4.</strong> Alnomoj, Referencoj kaj pureco</a></li><li><ul class="section"><li><a href="advanced/references.html"><strong>4.1.</strong> Referencoj</a></li><li><a href="advanced/alias.html"><strong>4.2.</strong> Alnomoj</a></li><li><a href="advanced/copies.html"><strong>4.3.</strong> Kopio kaj profunda kopio</a></li><li><a href="advanced/best.html"><strong>4.4.</strong> Plej bonaj kutimoj</a></li><li><a href="advanced/pure.html"><strong>4.5.</strong> Puraj valoroj</a></li></ul></li><li><a href="modules/README.html"><strong>5.</strong> Pakaĵoj</a></li><li><a href="types/README.html"><strong>6.</strong> Tipoj difinitaj de la uzanto</a></li><li><ul class="section"><li><a href="types/struct.html"><strong>6.1.</strong> Strukturo</a></li><li><a href="types/enum.html"><strong>6.2.</strong> Enumeracio</a></li><li><a href="types/aka.html"><strong>6.3.</strong> Kaŝnomo</a></li></ul></li><li><a href="objects/README.html"><strong>7.</strong> Objektoj</a></li><li><ul class="section"><li><a href="objects/class.html"><strong>7.1.</strong> Klaso</a></li><li><a href="objects/mutability.html"><strong>7.2.</strong> Ŝanĝebleco</a></li><li><a href="objects/methods.html"><strong>7.3.</strong> Metodoj</a></li><li><a href="objects/inheritance.html"><strong>7.4.</strong> Heredeco</a></li><li><a href="objects/traits.html"><strong>7.5.</strong> Trajto</a></li><li><a href="objects/cast.html"><strong>7.6.</strong> Tipŝanĝo, kaj dinamikaj tipoj</a></li></ul></li><li><a href="functions/README.html"><strong>8.</strong> Funkcioj pli kompleksaj</a></li><li><a href="pattern/README.html"><strong>9.</strong> Skema kongruo</a></li><li><a href="errors/main.html"><strong>10.</strong> Traktado de Eraroj</a></li><li><ul class="section"><li><a href="errors/scope_guards.html"><strong>10.1.</strong> Regionaj gardantoj</a></li><li><a href="errors/catching.html"><strong>10.2.</strong> Kapti erarojn</a></li><li><a href="errors/option.html"><strong>10.3.</strong> Esceptoj kaj opcia tipo</a></li><li><a href="errors/fptr_closure.html"><strong>10.4.</strong> Montrilo de Malsekuraj Funkcioj</a></li></ul></li><li><a href="templates/README.html"><strong>11.</strong> Ŝablonoj</a></li><li><ul class="section"><li><a href="templates/special.html" class="active"><strong>11.1.</strong> Ŝablonaj tipoj</a></li><li><a href="templates/cte.html"><strong>11.2.</strong> Ŝablonaj valoroj</a></li><li><a href="templates/values.html"><strong>11.3.</strong> Plenumo dum kompilado</a></li></ul></li><li><a href="objects/common_traits.html"><strong>12.</strong> Ordinaraj trajtoj</a></li><li><ul class="section"><li><a href="traits/streamable.html"><strong>12.1.</strong> &quot;Streamable&quot;</a></li><li><a href="traits/copiable.html"><strong>12.2.</strong> &quot;Copiable&quot;</a></li><li><a href="traits/disposable.html"><strong>12.3.</strong> &quot;With&quot; gardanto kaj &quot;Disposable&quot;</a></li><li><a href="traits/hashable.html"><strong>12.4.</strong> &quot;Hashable&quot;</a></li><li><a href="traits/serialize.html"><strong>12.5.</strong> &quot;Packable&quot; kaj &quot;Serializable&quot;</a></li></ul></li><li><a href="templates/operators.html"><strong>13.</strong> Transŝargo de Operacisimboloj</a></li><li><ul class="section"><li><a href="templates/binary.html"><strong>13.1.</strong> Unuopaj, duopaj kaj komparaj operacioj</a></li><li><a href="templates/complex_operators.html"><strong>13.2.</strong> Aliraj, Enhavaj kaj iteraciaj operacioj</a></li></ul></li><li><a href="version/README.html"><strong>14.</strong> Versioj</a></li><li><a href="macros/README.html"><strong>15.</strong> Makrooj</a></li><li><ul class="section"><li><a href="macros/std.html"><strong>15.1.</strong> Normaj kaj kernaj makrooj</a></li></ul></li><li><a href="documentation/README.html"><strong>16.</strong> Dokumentaro</a></li><li><ul class="section"><li><a href="documentation/types.html"><strong>16.1.</strong> Tipoj</a></li><li><a href="documentation/symbols.html"><strong>16.2.</strong> Simboloj</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Ymir Tour</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="templates/special.html#template-specialization" id="template-specialization"><h1>Template specialization</h1></a>
<p>We have seen in the last chapter, the declaration of template symbol,
that can be instanciated using any types. Sometimes, it can be usefull
to restrict the set of types that can be used in a given template
symbol (e.g. only slices but of any type, only classes, only
structures, etc.). In order to make this possible, the <em>Ymir</em> language
offers some elements to filter the different types that can be used.</p>
<p>The following code block present the complete syntax of a template
parameter.</p>
<pre><code class="language-grammar">template_parameter := Identifier | of_filter | class_filter | struct_filter | impl_filter | variadic_filter

of_filter := Identifier 'of' type
class_filter := 'class' Identifier
struct_filter := 'struct' Identifier
impl_filter := Identifier impl type
variadic_filter := Identifier '...'
</code></pre>
<p><br></p>
<p>One can note that every template parameters have an Identifier. This
identifier are the root of the specialization tree. For example, in
the following template parameters <strong><code>{T of [U], U}</code></strong> there are two
roots, <strong><code>T</code></strong> and <strong><code>U</code></strong>. The root <strong><code>U</code></strong> is important, these
template parameters are different to <strong><code>{T of [U]}</code></strong>. In the first
case, the identifier <strong><code>U</code></strong> refers to a template type (as it is a
root of the parameters), and in the second case it refers directly to
a type that is named <strong><code>U</code></strong>, and that has to be declared somewhere.</p>
<a class="header" href="templates/special.html#of-filter" id="of-filter"><h2>Of filter</h2></a>
<p>The <em>of filter</em> is declared using the keyword <strong><code>of</code></strong>. This filter is
used to specify the form of the type that can be used to instanciate
the template. The form can be any form of type, it can be for example
a slice, an array, a template symbol, etc. In the following example,
the first function <strong><code>foo</code></strong> declared at line <strong><code>6</code></strong>, is a template
function that can be instanciated using only <strong><code>T=i32</code></strong>. The second
function <strong><code>foo</code></strong> at line <strong><code>14</code></strong> use the <strong><code>of</code></strong> filter to inform
that the type <strong><code>T</code></strong> must have the same form as the type <strong><code>Z</code></strong>, but
does not filter the type <strong><code>Z</code></strong>. The third function <strong><code>foo</code></strong> at line
<strong><code>21</code></strong>, accepts for the type <strong><code>T</code></strong> any slice that have as internal
type a template type declared as <strong><code>Z</code></strong>, there is no filter on
<strong><code>Z</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

/**
 * This function will only be callable, with a i32 as T
 */
def foo {T of i32} (_ : T) {
    println (&quot;First ??&quot;);
}

/**
 * This function will only be callable, with a type that fit the Z pattern
 * That is to say every type
 */
def foo {T of Z, Z} (_ : T) {
    println (&quot;Second ?&quot;);
}

/**
 * This function will be only callable, with a slice of Z, where Z can be anything
 */
def foo {T of [Z], Z} (_ : T) {
    println (&quot;Third !&quot;);
}

def main () {
    foo ([1, 2]);
}
</code></pre>
<p><br></p>
<p>In the above example, one can note that, two functions can be called
by the expression <code>foo ([1, 2])</code>. The second and third ones. The
template definition that match the best the types, will be used. Here,
this is the third one, the filter is more specific and thus has a
better score.</p>
<p>Results:</p>
<pre><code>Third !
</code></pre>
<p><br></p>
<p>The <em>of filter</em> is a kind of destructuring pattern. They can be
chained, and composed with other filters. Here some other example,
where this time the <em>of filter</em> is used to get the template types
parameters of a given class type, and apply some filter on them.</p>
<pre><code class="language-ymir">import std::io;

/** A template class, that takes any type as template parameters */
class X {T} {
    let _x : T;
    
    pub self (x : T) with _x = x {}
}

/**
 * This function accepts any X object, as long as its template parameter is a slice
 */
def foo {T of &amp;(X!{U}), U of [Z], Z} (x : T) {
    println (&quot;Slice X : &quot;, x::typeinfo.name);
}

/**
 * Accept all the X objects, that have not been accepted by the first function
 * Indeed, the template is less specific, and is used only if the first one fails
 */
def foo {T of &amp;(X!{U}), U} (x : T) {
    println (&quot;Not a slice X : &quot;, x::typeinfo.name);
}


def main () {
    let a = X::new ([1, 2, 3]);
    let b = X::new (&quot;Test&quot;);
    let c = X::new (23.0f);
    
    foo (a);
    foo (b);
    foo (c);
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Slice X : main::X([i32])::X
Slice X : main::X([c32])::X
Not a slice X : main::X(f32)::X
</code></pre>
<p><br></p>
<p>As presented in the introduction of this chapter, there is a
difference between identifier that can be found in the roots of the
template parameters and those which are not. In the following example,
the <strong><code>foo</code></strong> function accept a slice of <strong><code>U</code></strong> where <strong><code>U</code></strong> is not
defined, resulting in an error by the compiler. Indeed, the type
<strong><code>U</code></strong> could have been defined somewhere, and there must be a
distinction between this type and a template parameter.</p>
<pre><code class="language-ymir">import std::io;

def foo {T of [U]} (a : T) {}

def main () {
    foo ([1, 2]);
}
</code></pre>
<p><br>
Errors:</p>
<pre><code class="language-error">Error : the call operator is not defined for foo {T of [U]}(a : T)-&gt; void and {mut [mut i32]}
 --&gt; main.yr:(6,6)
 6  ┃ 	foo ([1, 2]);
    ╋ 	    ^      ^
    ┃ Note : candidate foo --&gt; main.yr:(3,5) : foo {T of [U]}(a : T)-&gt; void
    ┃     ┃ Error : undefined type U
    ┃     ┃  --&gt; main.yr:(3,16)
    ┃     ┃  3  ┃ def foo {T of [U]} (a : T) {}
    ┃     ┃     ╋                ^
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="templates/special.html#struct-and-class-filters" id="struct-and-class-filters"><h2>Struct and Class filters</h2></a>
<p>The keywords <code>struct</code> and <code>class</code> defines respecitvely the <em>struct</em>
and <em>class filters</em>. They filter the accepted types of a template
symbol. Unlike <em>of filter</em> they cannot be chained, and accept only an
identifier. In the following example, the first <strong><code>foo</code></strong> function at
line <strong><code>11</code></strong> is instanciable using a class type, and the second at
line <strong><code>15</code></strong> only accept struct types. <strong>Warning</strong> <em>class filter</em>
accepts a reference class type, and not directly the class type
(<strong><code>&amp;A</code></strong> not <strong><code>A</code></strong>).</p>
<pre><code class="language-ymir">import std::io

struct 
| x : i32
-&gt; X;

class A {
    self () {}
}

def foo {class T} () {
    println (&quot;Class !&quot;);
}

def foo {struct T} () {
    println (&quot;Struct !&quot;);
}

def main () {
    foo!(&amp;A) ();
    foo!(X) ();
} 
</code></pre>
<p><br>
Results:</p>
<pre><code>Class !
Struct !
</code></pre>
<p><br></p>
<p>Even if this filters cannot be chained, they can be used as the leaf
of a <em>of filter</em>. In the following example, the function <strong><code>foo</code></strong>
accepts a slice of class objects.</p>
<pre><code class="language-ymir">import std::io;

class A {
    pub self () {}
    impl Streamable;
}

class B {
    pub self () {}
    impl Streamable;
}

def foo {T of [U], class U} (a : T) {
    println (T::typeid, &quot; = &quot;, a, &quot;&quot;);
}

def main () {
    foo ([A::new (), A::new ()]);
    foo ([B::new ()]);
}
</code></pre>
<p><br>
Results:</p>
<pre><code>[&amp;(main::A)] = [main::A(), main::A()]
[&amp;(main::B)] = [main::B()]
</code></pre>
<a class="header" href="templates/special.html#implement-filter" id="implement-filter"><h2>Implement filter</h2></a>
<p>We have seen in the chapter about traits
(<em>cf</em>. <a href="https://gnu-ymir.github.io/Documentations/en/objects/traits.html">Traits</a>),
that class type can implement a given trait. Implementing a trait
gives specific method to a class type, that can be called. However
traits lose most of their interest if it is impossible to accept a
type that implements the trait without knowning the type itself. This
cannot be done by inheritance, as traits are not types, however
templates have a specific filter to perform this operation. In the
following example, the <em>impl filter</em> is used by the <strong><code>foo</code></strong>
function, that thus accepts any kind of object as long as they impl
the trait <strong><code>Getter</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

trait Getter {
    pub def get (self)-&gt; i32;
}

class A {

    pub self () {}
    
    impl Getter {
        pub over get (self)-&gt; i32 {
            12
        }
    }

}

def foo {T impl Getter} (a : T) -&gt; i32 {
    a.get ()
}

def main () {
    let a = A::new ();
    println (foo (a));
}
</code></pre>
<p><br></p>
<p>A trait can be a template symbol. In that case it has some template
parameters, that can be destructured by a template filter. For
example, in the following source code, the trait <strong><code>Getter</code></strong> is a
template, that is implemented using the type <strong><code>i32</code></strong> by the class
<strong><code>A</code></strong>. The first <strong><code>foo</code></strong> function at line <strong><code>1</code></strong> accepts any kind
of object as long as they impl the trait <strong><code>Getter</code></strong>, and filter the
template parameter of this trait to get it under the identifier
<strong><code>X</code></strong>. The second <strong><code>foo</code></strong> function only accepts types that
implements the trait but using a slice. Because the second <strong><code>foo</code></strong>
function is more specific when using <strong><code>&amp;B</code></strong> object, it is called at
line <strong><code>44</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

trait Getter {T} {
    pub def get (self)-&gt; T;
}

class A {

    pub self () {}
    
    impl Getter!{i32} {
        pub over get (self)-&gt; i32 {
            12
        }
    }
}

class B {

    pub self () {}
    
    impl Getter!{[i32]} {
        pub over get (self)-&gt; [i32] {
            [12, 24]
        }
    }
}

def foo {T impl Getter!{X}, X} (a : T) -&gt; X {
    print (&quot;First : &quot;);
    a.get ()
}

def foo {T impl Getter!{X}, X of [U], U} (a : T)-&gt; X {
    print (&quot;Second : &quot;);
    a.get ()
}

def main () {
    let a = A::new ();
    let b = B::new ();
    
    println (foo (a));
    println (foo (b));
}
</code></pre>
<p><br>
Results:</p>
<pre><code>First : 12
Second : [12, 24]
</code></pre>
<p><br></p>
<a class="header" href="templates/special.html#variadic-templates" id="variadic-templates"><h2>Variadic templates</h2></a>
<p>Variadic templates are special templates, that takes an arbitrary
number of type as arguments. They are defined using an identifier
followed by the token <code>...</code>. When the specialization is done, the
identifier of the variadic template, can be used to define a tuple
type. In the following example, the type of the parameter <strong><code>a</code></strong> of
the <strong><code>foo</code></strong> function is <strong><code>(i32, i32, i32, i32, i32)</code></strong>. <strong>Warning</strong>
If only one type is given to the variadic template, then it is not a
tuple, but directly the type that has been given. As you may have
guessed by now, the <code>println</code> function is a variadic template
function.</p>
<pre><code class="language-ymir">import std::io

def foo {T ...} (a : T) {
    println (a.0, expand a);
}

def main () {
    foo (1, 2, 3, 4, 5);
}
</code></pre>
<p><br>
Results:</p>
<pre><code>112345
</code></pre>
<p><br></p>
<p>The identifier can also be used to complete another type. For example,
a function pointer type. In the following source code, the structure
<strong><code>X</code></strong> accepts an arbitrary number of type as template parameters,
and use them to form the type of the field <strong><code>foo</code></strong>. When
instanciated by the <strong><code>main</code></strong> function at line <strong><code>12</code></strong>, the field
<strong><code>foo</code></strong> takes the type <strong><code>fn (i32, f32)-&gt; void</code></strong>.</p>
<pre><code class="language-ymir">import std::io

struct 
| foo : fn (T)-&gt; void
 -&gt; X {T...};
 
def foo (x : i32, y : f32)-&gt; void {
    println (&quot;(&quot;, x, &quot;, &quot;, y, &quot;)&quot;);
}
 
def main () {
    let x = X!{i32, f32} (&amp;foo);
    x.foo (12, 3.14f);
}
</code></pre>
<p><br>
Results:</p>
<pre><code>(12, 3.140000)
</code></pre>
<p><br></p>
<p>To force the type to be a tuple inside another type, the standard
syntax of tuple can be used. For example, the field <strong><code>foo</code></strong> could
have been defined as follows <strong><code>fn ((T,))-&gt; void</code></strong>, in that case it
would have been equal to <strong><code>fn ((i32, f32))-&gt; void</code></strong>, meaning a
function pointer that takes a parameter of type <strong><code>(i32, f32)</code></strong>, and
returns nothing.</p>
<a class="header" href="templates/special.html#recursive-variadic-template" id="recursive-variadic-template"><h3>Recursive variadic template</h3></a>
<p>Variadic template must contain at least one type. To perfom recursive
variadic function, end case functions must be written, this end case
generally contains a standard template parameter. For example, the
following example presents a <strong><code>foo</code></strong> function that takes variadic
parameters, and prints them. The end case is described at line
<strong><code>3</code></strong>, where the function takes only one standard template
parameter. The function <strong><code>foo</code></strong> at line <strong><code>8</code></strong> takes two template
parameter, a standard one that will be used for the first parameter of
the function, and a variadic one for the rest of the parameters. One
can note from the line <strong><code>5</code></strong> that even if the type of <strong><code>b</code></strong> is
<strong><code>c8</code></strong> and thus not a tuple, the keyword <strong><code>expand</code></strong> is usable, and
does nothing particular.</p>
<pre><code class="language-ymir">import std::io;

def foo {F, R...} (a : F, b : R) {
    println (&quot;FST : &quot;, F::typeid, &quot;(&quot;, a, &quot;)&quot;);
    foo (expand b);
}

def foo {F} (a : F) {
    println (&quot;SCD : &quot;, F::typeid, &quot;(&quot;, a, &quot;)&quot;);
}

def main () {
    foo (1, 3.f, &quot;Test&quot;, 'r'c8);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>FST : i32(1)
FST : f32(3.000000)
FST : [c32](Test)
SCD : c8(r)
</code></pre>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="templates/README.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="templates/cte.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="templates/README.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="templates/cte.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        
    <script type="text/javascript">
        var socket = new WebSocket("ws://localhost:3001");
        socket.onmessage = function (event) {
            if (event.data === "reload") {
                socket.close();
                location.reload(true); // force reload from server (not from cache)
            }
        };

        window.onbeforeunload = function() {
            socket.close();
        }
    </script>


        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        
        <script type="text/javascript" src="custom.js"></script>
        

    </body>
</html>
