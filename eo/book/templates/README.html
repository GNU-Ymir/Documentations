<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Ŝablonoj - Ymir Tour</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        
        <link rel="stylesheet" href="custom.css">
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> Antaŭparolo</a></li><li><a href="hello-world/README.html"><strong>2.</strong> Bonan tagon mondo</a></li><li><ul class="section"><li><a href="hello-world/commentaires.html"><strong>2.1.</strong> Komentoj</a></li></ul></li><li><a href="primitives/README.html"><strong>3.</strong> Bazaj konceptoj de programado</a></li><li><ul class="section"><li><a href="primitives/variables.html"><strong>3.1.</strong> Variabloj kaj Ŝanĝebleco</a></li><li><a href="primitives/types.html"><strong>3.2.</strong> Datenaj tipoj</a></li><li><a href="primitives/functions.html"><strong>3.3.</strong> Funkcioj</a></li><li><a href="primitives/control.html"><strong>3.4.</strong> Kontrolaj fluoj</a></li><li><a href="primitives/operator.html"><strong>3.5.</strong> Prioritato de operacioj</a></li></ul></li><li><a href="advanced/README.html"><strong>4.</strong> Alnomoj, Referencoj kaj pureco</a></li><li><ul class="section"><li><a href="advanced/references.html"><strong>4.1.</strong> Referencoj</a></li><li><a href="advanced/alias.html"><strong>4.2.</strong> Alnomoj</a></li><li><a href="advanced/copies.html"><strong>4.3.</strong> Kopio kaj profunda kopio</a></li><li><a href="advanced/best.html"><strong>4.4.</strong> Plej bonaj kutimoj</a></li><li><a href="advanced/pure.html"><strong>4.5.</strong> Puraj valoroj</a></li></ul></li><li><a href="modules/README.html"><strong>5.</strong> Pakaĵoj</a></li><li><a href="types/README.html"><strong>6.</strong> Tipoj difinitaj de la uzanto</a></li><li><ul class="section"><li><a href="types/struct.html"><strong>6.1.</strong> Strukturo</a></li><li><a href="types/enum.html"><strong>6.2.</strong> Enumeracio</a></li><li><a href="types/aka.html"><strong>6.3.</strong> Kaŝnomo</a></li></ul></li><li><a href="objects/README.html"><strong>7.</strong> Objektoj</a></li><li><ul class="section"><li><a href="objects/class.html"><strong>7.1.</strong> Klaso</a></li><li><a href="objects/mutability.html"><strong>7.2.</strong> Ŝanĝebleco</a></li><li><a href="objects/methods.html"><strong>7.3.</strong> Metodoj</a></li><li><a href="objects/inheritance.html"><strong>7.4.</strong> Heredeco</a></li><li><a href="objects/traits.html"><strong>7.5.</strong> Trajto</a></li><li><a href="objects/cast.html"><strong>7.6.</strong> Tipŝanĝo, kaj dinamikaj tipoj</a></li></ul></li><li><a href="functions/README.html"><strong>8.</strong> Funkcioj pli kompleksaj</a></li><li><a href="pattern/README.html"><strong>9.</strong> Skema kongruo</a></li><li><a href="errors/main.html"><strong>10.</strong> Traktado de Eraroj</a></li><li><ul class="section"><li><a href="errors/scope_guards.html"><strong>10.1.</strong> Regionaj gardantoj</a></li><li><a href="errors/catching.html"><strong>10.2.</strong> Kapti erarojn</a></li><li><a href="errors/option.html"><strong>10.3.</strong> Esceptoj kaj opcia tipo</a></li><li><a href="errors/fptr_closure.html"><strong>10.4.</strong> Montrilo de Malsekuraj Funkcioj</a></li></ul></li><li><a href="templates/README.html" class="active"><strong>11.</strong> Ŝablonoj</a></li><li><ul class="section"><li><a href="templates/special.html"><strong>11.1.</strong> Ŝablonaj tipoj</a></li><li><a href="templates/cte.html"><strong>11.2.</strong> Ŝablonaj valoroj</a></li><li><a href="templates/values.html"><strong>11.3.</strong> Plenumo dum kompilado</a></li></ul></li><li><a href="objects/common_traits.html"><strong>12.</strong> Ordinaraj trajtoj</a></li><li><ul class="section"><li><a href="traits/streamable.html"><strong>12.1.</strong> &quot;Streamable&quot;</a></li><li><a href="traits/copiable.html"><strong>12.2.</strong> &quot;Copiable&quot;</a></li><li><a href="traits/disposable.html"><strong>12.3.</strong> &quot;With&quot; gardanto kaj &quot;Disposable&quot;</a></li><li><a href="traits/hashable.html"><strong>12.4.</strong> &quot;Hashable&quot;</a></li><li><a href="traits/serialize.html"><strong>12.5.</strong> &quot;Packable&quot; kaj &quot;Serializable&quot;</a></li></ul></li><li><a href="templates/operators.html"><strong>13.</strong> Transŝargo de Operacisimboloj</a></li><li><ul class="section"><li><a href="templates/binary.html"><strong>13.1.</strong> Unuopaj, duopaj kaj komparaj operacioj</a></li><li><a href="templates/complex_operators.html"><strong>13.2.</strong> Aliraj, Enhavaj kaj iteraciaj operacioj</a></li></ul></li><li><a href="version/README.html"><strong>14.</strong> Versioj</a></li><li><a href="macros/README.html"><strong>15.</strong> Makrooj</a></li><li><ul class="section"><li><a href="macros/std.html"><strong>15.1.</strong> Normaj kaj kernaj makrooj</a></li></ul></li><li><a href="documentation/README.html"><strong>16.</strong> Dokumentaro</a></li><li><ul class="section"><li><a href="documentation/types.html"><strong>16.1.</strong> Tipoj</a></li><li><a href="documentation/symbols.html"><strong>16.2.</strong> Simboloj</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Ymir Tour</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="templates/README.html#templates" id="templates"><h1>Templates</h1></a>
<p>The templates system provide the possibility to reuse source code,
that is valid for multiple types. The template system of <em>Ymir</em> is
powerful, and allows the generation of code, that will be used many
times for many purpose, by writting minimal source code, and
conditional compilation. Templates is a main part of the <em>Ymir</em>
language, and almost everything in the standard library is written
using templates. It is important to understand the template system, to
use the language.</p>
<a class="header" href="templates/README.html#template-definition-syntax" id="template-definition-syntax"><h2>Template definition syntax</h2></a>
<p>Multiple symbols in <em>Ymir</em> can be templates. Every template symbol has
a name, and the template parameters are following that name enclosed
between curly brackets (this time they are always mandatory). For
example, a function can be a template, as it can be seen in the
following example. In this example, the function <strong><code>foo</code></strong> takes a
type as template parameter, and this type is named <strong><code>T</code></strong> in the
function symbol, and is used as the type of the first parameter of the
function (i.e. the type of the parameter <strong><code>a</code></strong>). By convention, the
identifiers of the template parameters are in upper case, however that
is not mandatory.</p>
<pre><code class="language-ymir">def foo {T} (a : T) {
    println (a);
}
</code></pre>
<p><br></p>
<p>Other symbols can also be templates. These symbols are :</p>
<ul>
<li>Classes</li>
<li>Structures</li>
<li>Enumerations</li>
<li>Local modules</li>
<li>Traits</li>
<li>Aka</li>
</ul>
<p>The templates arguments always follows the name of the symbol. In the
following example, templates are defined for various symbols.</p>
<pre><code class="language-ymir">class A {T} {
    let value : T;
    
    pub self (v : T) with value = v {}
}

struct 
| x : T
-&gt; S {T};

enum 
| X = cast!T (12)
-&gt; F {T};

mod Inner {T} {
    pub def foo (a : T) {
        println (a);
    }
}

trait Z {T} {
    pub def foo (self, a : T)-&gt; T;
}

aka X {T} = cast!T (12);
</code></pre>
<p><br></p>
<a class="header" href="templates/README.html#template-argument-syntax" id="template-argument-syntax"><h2>Template argument syntax</h2></a>
<p>The <em>template call</em> syntax is declared using the token <code>!</code>, followed
by one are multiple arguments, enclosed inside curly
brackets. Template arguments are elements that must be known by the
compiler at compile time, in order to produce a valid template
specialization and create a symbol that can be used and is fully
validated (i.e. where every types are correctly defined). The
following code block present the syntax of the <em>template
call</em>. <em>Template call</em> is a high priority expression, that has a even
higher level of priority than the <strong><code>::</code></strong> operator, and unary
operators. Operator priority is presented in the chapter <a href="https://gnu-ymir.github.io/Documentations/en/primitives/operator.html">Operator
priority</a>.</p>
<pre><code class="language-grammar">template_call := expression (single_arg | multiple_args) 
single_arg := '!' expression 
multiple_args := '!' '{' (expression | template_call) (',' (expression | template_call))*)? '}'
</code></pre>
<p><br></p>
<p>And the following code block presents example of <em>template call</em> on a
function named <strong><code>foo</code></strong>.</p>
<pre><code class="language-ymir">foo!i32 (12); // One template argument (i32)
foo!(i32, f32) (12); // One template tuple (i32, f32)
foo!{i32, f64} (12); // Two template arguments, types i32 and f64
</code></pre>
<p><br></p>
<p>When the arguments, are also template, the curly brackets are
mandatory even if there is only one parameter, to avoid ambiguity.</p>
<pre><code class="language-ymir">foo!{foo!i32} (); // Ok
foo!foo!i32 (); // No
</code></pre>
<p><br></p>
<a class="header" href="templates/README.html#template-instanciation" id="template-instanciation"><h3>Template instanciation</h3></a>
<p>When a template symbol is defined, the <em>template call</em> is used to
reference it, and make a specialization. The arguments used in the
<em>template call</em> are associated to the template parameters of the
template symbol, in the order they are defined. In the following
example, a function <strong><code>foo</code></strong> has a template argument, that must be a
type, and is named <strong><code>T</code></strong>. The <strong><code>main</code></strong> function use the <em>template
call</em> syntax to use that symbol, and associate to <strong><code>T</code></strong> the type
<strong><code>i32</code></strong>. The symbol with a <strong><code>i32</code></strong> is then created by the
compiler, and the <strong><code>main</code></strong> function calls it using the standard call
syntax using the parentheses operator.</p>
<pre><code class="language-ymir">import std::io;

def foo {T} (a : T) {
    println (a);
}
    
def main () {
    foo!i32 (42);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>42
</code></pre>
<p><br></p>
<p>When the template symbol is a function, it can happened that the
template parameters can be infered from the parameters of the
function. For example in the above example, there is no need to
specify a <em>template call</em>, and the <em>standard call</em> expression is
sufficient.</p>
<pre><code class="language-ymir">import std::io;

def foo {T} (a : T) {
    println (a);
}
    
def main () {
    foo (42); // T, is infered as i32
    foo (&quot;Hi !!&quot;); // T, is infered as a [c32]
}
</code></pre>
<p><br>
Results:</p>
<pre><code>42
Hi !!
</code></pre>
<p><br></p>
<p>This cannot be done for structure or module. However, this is possible
to do on classes, and this will be presented a little later, in the
following section of the chapter.</p>
<p>We have seen in the chapter about
function (<em>cf</em>.
<a href="https://gnu-ymir.github.io/Documentations/en/primitives/functions.html">Functions</a>),
the <em>uniform call syntax</em>. This syntax is also applicable on template
functions. In the following example, a function that takes two types
as template parameters is called in the <strong><code>main</code></strong> function.</p>
<pre><code class="language-ymir">import std::io;

def foo {T} (a : T) {
    println (a);
}

def main () {
    (42).foo (); 
}
</code></pre>
<a class="header" href="templates/README.html#multiple-template-parameters" id="multiple-template-parameters"><h3>Multiple template parameters</h3></a>
<p>As said earlier the parameters are specialized using the arguments of
the <em>template call</em> syntax in the order they are presented. For
example, in the following example, the <em>template call</em> syntax at line
<strong><code>1</code></strong> creates a symbol where <strong><code>T=i32</code></strong>, and <strong><code>U=f64</code></strong>.</p>
<pre><code class="language-ymir">def foo {T, U} () {}

def main () {
    foo!{i32, f64} ();
}
</code></pre>
<p><br></p>
<p>It is not necessary to put all the argument in the other template
parameters can be infered from the previous template arguments, or by
the parameters of the function. We will see in a next chapter some way
to determine the kind of type that can be used in a template symbol,
but briefly in the following example, the <strong><code>foo</code></strong> function only
accepts types that are slices of <strong><code>U</code></strong>, where <strong><code>U</code></strong> can
be any type. In that case, because <strong><code>T</code></strong> can be used to infer the
type of <strong><code>U</code></strong>, there is no need to specify the type of <strong><code>U</code></strong>
explicitly.</p>
<pre><code class="language-ymir">import std::io;

def foo {T of [U], U} () {
    println (&quot;T=&quot;, T::typeid, &quot; U=&quot;, U::typeid);
}

def main () {
    foo![i32] ();
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>T=[i32] U=i32
</code></pre>
<p><br></p>
<p>The same behavior can be observed when the type can be infered from a
standard parameter of the function. In the following example, the type
<strong><code>T</code></strong> is defined by the <em>template call</em> syntax, but the type <strong><code>U</code></strong>
is defined by the first argument of the <em>standard call</em>. Thus, type
<strong><code>T</code></strong> is <strong><code>i32</code></strong>, and type <strong><code>U</code></strong> is <strong><code>f64</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

def foo {T, U} (a : U) {
    println (&quot;T=&quot;, T::typeid, &quot; U=&quot;, U::typeid, &quot; a=&quot;, a, &quot;&quot;);
}

def main () {
    foo!i32 (3.14);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>T=i32 U=f64 a=3.140000
</code></pre>
<p><br></p>
<p>One can note that the type <strong><code>T</code></strong> cannot be infered from anything
aside the <em>template call</em>. Thus it has to be the first template
parameter, otherwise the <em>template call</em> would have defined the type
<strong><code>U</code></strong>. In the following example, the parameter <strong><code>T</code></strong> and <strong><code>U</code></strong>
have been reversed, but the call is the same. In that case, the
compiler fails to create a valid symbol and throws an error.</p>
<pre><code class="language-ymir">import std::io;

def foo {U, T} (a : U) {
    println (&quot;T=&quot;, T::typeid, &quot; U=&quot;, U::typeid, &quot; a=&quot;, a, &quot;&quot;);
}

def main () {
    foo!i32 (3.14); // set U to i32, and T cannot be infered
}
</code></pre>
<p><br>
Errors (in this error, we can see that <strong><code>U</code></strong> is set to <strong><code>i32</code></strong> at line <strong><code>10</code></strong>, and that the compiler failed to set <strong><code>T</code></strong>) :</p>
<pre><code class="language-error">Error : the call operator is not defined for foo {T}(a : U)-&gt; void and {f64}
 --&gt; main.yr:(8,10)
 8  ┃ 	foo!i32 (3.14);
    ╋ 	        ^    ^
    ┃ Note : candidate foo --&gt; main.yr:(3,5) : foo {T}(a : U)-&gt; void
    ┃     ┃ Error : unresolved template
    ┃     ┃  --&gt; main.yr:(3,13)
    ┃     ┃  3  ┃ def foo {U, T} (a : U) {
    ┃     ┃     ╋             ^
    ┃     ┃ Note : for : foo --&gt; main.yr:(3,5) with (U = i32)
    ┃     ┗━━━━━━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>Using the <em>template call</em> syntax to set only a part of the template
symbols is named a <em>two time template validation</em>. We will see in the
next chapter, that template specialization can be very powerful and
can be used to choose between multiple template symbols. Refering to a
template symbol without using the <em>template call</em> syntax can be seen
as a special case of <em>two time validation</em>, where the <em>template call</em>
is made but with no arguments.</p>
<a class="header" href="templates/README.html#template-class-instanciation" id="template-class-instanciation"><h3>Template class instanciation</h3></a>
<p>When a class template is declared, the compiler is sometimes able to
infer the type of the templates from the argument passed to the
constructors. The rule is the same as for function instanciation. In
the following example, the class <strong><code>X</code></strong> is a template class that
takes two types as template parameters. The <strong><code>main</code></strong> function
instanciate a <strong><code>X</code></strong> class at line <strong><code>10</code></strong> without using the
<em>template call</em> syntax. This is possible, because the constructor of
the class at line <strong><code>6</code></strong> is sufficient to infer the types <strong><code>T</code></strong> and
<strong><code>U</code></strong> exactly as it would be done if it was a function
template. Because <strong><code>T</code></strong> and <strong><code>U</code></strong> has no restriction any type can
be used.</p>
<pre><code class="language-ymir">import std::io;

class X {T, U} {
    let x : T, y : U;

    pub self (x : T, y : U) with x = x, y = y {}	
}

def main () {
    let a = X::new (1, 'r');
    let b = X::new ([1, 2], &quot;foo&quot;);
    
    println (a::typeinfo.name);
    println (b::typeinfo.name);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>main::X(i32,c32)::X
main::X([i32],[c32])::X
</code></pre>
<p><br></p>
<p>A <em>two time validation</em> can also be used to set the types of a part of
the template parameters, and let the other be infered by the
constructor call. In the following example, the type <strong><code>T</code></strong> is set by
the <em>template call</em> syntax, and the type <strong><code>U</code></strong> is infered from the
type of the parameter <strong><code>y</code></strong> of the constructor (here <strong><code>c32</code></strong>).</p>
<pre><code class="language-ymir">import std::io;

class X {T, U} {
    let y : U;

    pub self (y : U) with y = y {}	
}

def main () {
    let x = X!(i32)::new ('r');
    println (x::typeinfo.name);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>main::X(i32,c32)::X
</code></pre>
<p><strong>Contribution</strong> other template symbols cannot be called without
<em>template call</em>. This is normal for modules, traits, and enumeration,
as nothing can be used to infer the types. But structures are called
using arguments, that are used to set the values of the fields, this
is thus possible to infer the templates types in that case. Has to be
done, though.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="errors/fptr_closure.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="templates/special.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="errors/fptr_closure.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="templates/special.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        
    <script type="text/javascript">
        var socket = new WebSocket("ws://localhost:3001");
        socket.onmessage = function (event) {
            if (event.data === "reload") {
                socket.close();
                location.reload(true); // force reload from server (not from cache)
            }
        };

        window.onbeforeunload = function() {
            socket.close();
        }
    </script>


        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        
        <script type="text/javascript" src="custom.js"></script>
        

    </body>
</html>
