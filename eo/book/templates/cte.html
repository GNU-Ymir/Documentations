<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Ŝablonaj valoroj - Ymir Tour</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        
        <link rel="stylesheet" href="custom.css">
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> Antaŭparolo</a></li><li><a href="hello-world/README.html"><strong>2.</strong> Bonan tagon mondo</a></li><li><ul class="section"><li><a href="hello-world/commentaires.html"><strong>2.1.</strong> Komentoj</a></li></ul></li><li><a href="primitives/README.html"><strong>3.</strong> Bazaj konceptoj de programado</a></li><li><ul class="section"><li><a href="primitives/variables.html"><strong>3.1.</strong> Variablo kaj Ŝanĝebleco</a></li><li><a href="primitives/types.html"><strong>3.2.</strong> Datenaj tipoj</a></li><li><a href="primitives/functions.html"><strong>3.3.</strong> Funkcioj</a></li><li><a href="primitives/control.html"><strong>3.4.</strong> Kontrolaj fluoj</a></li><li><a href="primitives/operator.html"><strong>3.5.</strong> Prioritato de operacioj</a></li></ul></li><li><a href="advanced/README.html"><strong>4.</strong> Alnomoj, Referencoj kaj pureco</a></li><li><ul class="section"><li><a href="advanced/references.html"><strong>4.1.</strong> Referencoj</a></li><li><a href="advanced/alias.html"><strong>4.2.</strong> Alnomoj</a></li><li><a href="advanced/copies.html"><strong>4.3.</strong> Kopio kaj profunda kopio</a></li><li><a href="advanced/best.html"><strong>4.4.</strong> Plej bonaj kutimoj</a></li><li><a href="advanced/pure.html"><strong>4.5.</strong> Puraj valoroj</a></li></ul></li><li><a href="modules/README.html"><strong>5.</strong> Pakaĵoj</a></li><li><a href="types/README.html"><strong>6.</strong> Tipoj difinitaj de la uzanto</a></li><li><ul class="section"><li><a href="types/struct.html"><strong>6.1.</strong> Strukturo</a></li><li><a href="types/enum.html"><strong>6.2.</strong> Enumeracio</a></li><li><a href="types/aka.html"><strong>6.3.</strong> Kaŝnomo</a></li></ul></li><li><a href="objects/README.html"><strong>7.</strong> Objektoj</a></li><li><ul class="section"><li><a href="objects/class.html"><strong>7.1.</strong> Klaso</a></li><li><a href="objects/mutability.html"><strong>7.2.</strong> Ŝanĝebleco</a></li><li><a href="objects/methods.html"><strong>7.3.</strong> Metodoj</a></li><li><a href="objects/inheritance.html"><strong>7.4.</strong> Heredeco</a></li><li><a href="objects/traits.html"><strong>7.5.</strong> Trajto</a></li><li><a href="objects/cast.html"><strong>7.6.</strong> Tipŝanĝo, kaj dinamikaj tipoj</a></li></ul></li><li><a href="functions/README.html"><strong>8.</strong> Funkcioj pli kompleksaj</a></li><li><a href="pattern/README.html"><strong>9.</strong> Skema kongruo</a></li><li><a href="errors/main.html"><strong>10.</strong> Traktado de Eraroj</a></li><li><ul class="section"><li><a href="errors/scope_guards.html"><strong>10.1.</strong> Regionaj gardantoj</a></li><li><a href="errors/catching.html"><strong>10.2.</strong> Kapti erarojn</a></li><li><a href="errors/option.html"><strong>10.3.</strong> Esceptoj kaj opcia tipo</a></li><li><a href="errors/fptr_closure.html"><strong>10.4.</strong> Montrilo de Malsekuraj Funkcioj</a></li></ul></li><li><a href="templates/README.html"><strong>11.</strong> Ŝablonoj</a></li><li><ul class="section"><li><a href="templates/special.html"><strong>11.1.</strong> Ŝablonaj tipoj</a></li><li><a href="templates/cte.html" class="active"><strong>11.2.</strong> Ŝablonaj valoroj</a></li><li><a href="templates/values.html"><strong>11.3.</strong> Plenumo dum kompilado</a></li></ul></li><li><a href="objects/common_traits.html"><strong>12.</strong> Ordinaraj trajtoj</a></li><li><ul class="section"><li><a href="traits/streamable.html"><strong>12.1.</strong> &quot;Streamable&quot;</a></li><li><a href="traits/copiable.html"><strong>12.2.</strong> &quot;Copiable&quot;</a></li><li><a href="traits/disposable.html"><strong>12.3.</strong> &quot;With&quot; gardanto kaj &quot;Disposable&quot;</a></li><li><a href="traits/hashable.html"><strong>12.4.</strong> &quot;Hashable&quot;</a></li><li><a href="traits/serialize.html"><strong>12.5.</strong> &quot;Packable&quot; kaj &quot;Serializable&quot;</a></li></ul></li><li><a href="templates/operators.html"><strong>13.</strong> Transŝargo de Operacisimboloj</a></li><li><ul class="section"><li><a href="templates/binary.html"><strong>13.1.</strong> Unuopaj, duopaj kaj komparaj operacioj</a></li><li><a href="templates/complex_operators.html"><strong>13.2.</strong> Aliraj, Enhavaj kaj iteraciaj operacioj</a></li></ul></li><li><a href="version/README.html"><strong>14.</strong> Versioj</a></li><li><a href="macros/README.html"><strong>15.</strong> Makrooj</a></li><li><ul class="section"><li><a href="macros/std.html"><strong>15.1.</strong> Normaj kaj kernaj makrooj</a></li></ul></li><li><a href="documentation/README.html"><strong>16.</strong> Dokumentaro</a></li><li><ul class="section"><li><a href="documentation/types.html"><strong>16.1.</strong> Tipoj</a></li><li><a href="documentation/symbols.html"><strong>16.2.</strong> Simboloj</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Ymir Tour</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="templates/cte.html#template-values" id="template-values"><h1>Template values</h1></a>
<p>In <em>Ymir</em>, templates are seen as compilation time execution
parameters. These parameters can be either types or values. When
dealing with values, as with any values, decisions and program
branching can be made, but because these values are known at
compilation time, the decisions can also be made at compilation
time. This system is called <em>compilation time execution</em> or <em>cte</em> for
short. The keyword <strong><code>cte</code></strong> is used to ensure that a part of the code
is executed at compilation time, and generates a value (that can be
<strong><code>void</code></strong>) at compilation as well, to save time at execution time and
have a better optimized executable.</p>
<a class="header" href="templates/cte.html#compilation-time-values" id="compilation-time-values"><h2>Compilation time values</h2></a>
<p>Basically, every values can be known at compilation time as long as
they do not implies variable, or dynamic branching. For example, the
value of the <strong><code>foo</code></strong> function in the following source code can be
knwon at compilation time. Indeed, it implies only constants, that can
be computed by the compiler directly. The <strong><code>main</code></strong> function uses the
keyword <strong><code>cte</code></strong> to force the compiler to call the function <strong><code>foo</code></strong>
during the compilation. If the keyword is omitted then the function
<strong><code>foo</code></strong> is called at execution time.</p>
<pre><code class="language-ymir">import std::io;

def foo () -&gt; i32 {
    bar () + baz ()
}
    
def bar () -&gt; i32 
    12
    
def baz () -&gt; i32
    30
    
def main () {
    let z = cte foo ();
    println (z);
}
</code></pre>
<p><br> To verify that the <em>compilation time execution</em> effectively
happened, the option <strong><code>-fdump-tree-gimple</code></strong> can be used. This option
creates alternative files, that give information about the
compilation, and can be used to see what the frontend of the <em>Ymir</em>
compiler gave to the <strong>gcc</strong> compiler (source code close the <em>C
language</em>). The following block of code presents a part of the content
of this file. One can note that the <strong><code>main</code></strong> function does not call
the <strong><code>foo</code></strong> function, but only the <strong><code>println</code></strong> function with the
value <strong><code>42</code></strong>.</p>
<pre><code>main ()
{
  {
    signed int z;

    z = 42;
    _Y3std2io11printlnNi327printlnFi32Zv (z);
  }
}
</code></pre>
<a class="header" href="templates/cte.html#values-as-template-parameter" id="values-as-template-parameter"><h2>Values as template parameter</h2></a>
<p>We have seen in the previous chapter that templates parameters are
used to accept types. They also can be used to accept values, in that
case the syntax - described in the following code block - is a bit
different. The syntax for template values is close to variable
declaration, using the token <strong><code>:</code></strong>, or by using directly the literal
that is accepted.</p>
<pre><code class="language-grammar">template_value := literal | Identifier ':' (Identifier | type) ('=' literal)?
</code></pre>
<a class="header" href="templates/cte.html#template-literal" id="template-literal"><h3>Template literal</h3></a>
<p>A literal that can be known at compilation time can be used to make a
template specialization. The types that can be knwon at compilation
time are the following :</p>
<ul>
<li>string ([c8] or [c32])</li>
<li>char (c8 or c32)</li>
<li>integer (signed or unsigned)</li>
<li>float</li>
</ul>
<p><strong>Contribution</strong>: tuple, and struct are not compilation time knowable,
but this seems possible if they only contains <em>cte</em> values, same for
slice that are not strings.</p>
<p>In the following example, there are three different definition of the
function <strong><code>foo</code></strong>. The first one at line <strong><code>3</code></strong> can be called using
a the <em>cte</em> value <strong><code>3</code></strong>, the second one at line <strong><code>8</code></strong> using the
value <strong><code>2</code></strong>, and so on. The <strong><code>main</code></strong> function calls the function
<strong><code>foo</code></strong> using the value <strong><code>5 - 2</code></strong>, so the first definition at line
<strong><code>3</code></strong> is used.</p>
<pre><code class="language-ymir">import std::io;

def foo {3} () {
    println (&quot;3&quot;);
    foo!2 ();
}

def foo {2} () {
    println (&quot;2&quot;);
    foo!1 ();
}

def foo {1} () {
    println (&quot;1&quot;);
    foo!0 ();
}

def foo {0} () {
    println (&quot;Go !&quot;);
}

def main () {
    foo!{5 - 2} ();
} 
</code></pre>
<p><br>
Results:</p>
<pre><code>3
2
1
Go !
</code></pre>
<p><br></p>
<p>Literal string can also be used as template parameter. We will see in
a forthcoming chapter that those are used for operator overloading
(<em>cf</em>. <a href="https://gnu-ymir.github.io/Documentations/en/templates/operators.html">Operator
overloading</a>). A
simple example is presented in the following source code, where the
<strong><code>foo</code></strong> function accepts the literal <strong><code>Hi I'm foo !</code></strong>, and is called
by the <strong><code>main</code></strong> function using different ways.</p>
<pre><code class="language-ymir">import std::io;

def foo {&quot;Hi I'm foo !&quot;} () {
    println (&quot;Yes that's true !&quot;);
}

def bar () -&gt; [c32] {
    &quot;I'm foo !&quot;
}

def main () {
    foo!&quot;Hi I'm foo !&quot; ();
    foo!{&quot;Hi &quot; ~ bar ()} (); 
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Yes that's true !
Yes that's true !
</code></pre>
<a class="header" href="templates/cte.html#template-variable" id="template-variable"><h3>Template variable</h3></a>
<p>Because it would be utterly exhausting to write every definitions of
the template function with every possible literals (and even
impossible when dealing with infinite types such as slice), we
introduced the possibilty of writing template variables. Unlike real
variables those are evaluated at compilation time, and can be defined
only inside template parameters. The definition syntax of template
variable is close to the definition of a standard parameter, with the
difference that the type can be a template type (containing root
identifiers, foundable inside the template parameters). The following
example presents the definition of a function that make a countdown to
<strong><code>0</code></strong> (the generalization of the function <strong><code>foo</code></strong> presented in the
first example of the previous section). For the recursivity to stop,
the definition of a final case is mandatory, here it is achieved by
the function <strong><code>foo</code></strong> at line <strong><code>8</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

def foo {n : i32} () {
    println (n);
    foo!{n - 1} ();
}

def foo {0} () {
    println (&quot;Go !&quot;);
}

def main () {
    foo!12 ();
}
</code></pre>
<p><br>
Results:</p>
<pre><code>12
11
10
9
8
7
6
5
4
3
2
1
Go !
</code></pre>
<p><br></p>
<p><strong>Limitation</strong>: to avoid infinite loops, the compiler uses a very
simple verification. It is impossible to make more that <strong><code>300</code></strong>
recursive call. For that reason, make the following call <strong><code>foo!300 ()</code></strong> is impossible and generate a compilation error :</p>
<pre><code class="language-error">Error : undefined template operator for foo and {300}
 --&gt; main.yr:(13,5)
13  ┃ 	foo!300 ();
    ╋ 	   ^
    ┃ Error : undefined template operator for foo and {300}
    ┃  --&gt; main.yr:(13,5)
    ┃ 13  ┃ 	foo!300 ();
    ┃     ╋ 	   ^
    ┃     ┃ Note : in template specialization
    ┃     ┃  --&gt; main.yr:(13,5)
    ┃     ┃ 13  ┃ 	foo!300 ();
    ┃     ┃     ╋ 	   ^
    ┃     ┃ Note : foo --&gt; main.yr:(3,5) -&gt; foo
    ┃     ┃ Error : undefined template operator for foo and {299}
    ┃     ┃  --&gt; main.yr:(5,5)
    ┃     ┃  5  ┃ 	foo!{n - 1} ();
    ┃     ┃     ╋ 	   ^
    ┃     ┃     ┃ Error : undefined template operator for foo and {299}
    ┃     ┃     ┃  --&gt; main.yr:(5,5)
    ┃     ┃     ┃  5  ┃ 	foo!{n - 1} ();
    ┃     ┃     ┃     ╋ 	   ^
    ┃     ┃     ┃     ┃      : ...
    ┃     ┃     ┃     ┃ Note : there are other errors, use option -v to show them
    ┃     ┃     ┃     ┃ Error : undefined template operator for foo and {2}
    ┃     ┃     ┃     ┃  --&gt; main.yr:(5,5)
    ┃     ┃     ┃     ┃  5  ┃ 	foo!{n - 1} ();
    ┃     ┃     ┃     ┃     ╋ 	   ^
    ┃     ┃     ┃     ┃     ┃ Note : in template specialization
    ┃     ┃     ┃     ┃     ┃  --&gt; main.yr:(5,5)
    ┃     ┃     ┃     ┃     ┃  5  ┃ 	foo!{n - 1} ();
    ┃     ┃     ┃     ┃     ┃     ╋ 	   ^
    ┃     ┃     ┃     ┃     ┃ Note : foo --&gt; main.yr:(3,5) -&gt; foo
    ┃     ┃     ┃     ┃     ┃ Error : undefined template operator for foo and {1}
    ┃     ┃     ┃     ┃     ┃  --&gt; main.yr:(5,5)
    ┃     ┃     ┃     ┃     ┃  5  ┃ 	foo!{n - 1} ();
    ┃     ┃     ┃     ┃     ┃     ╋ 	   ^
    ┃     ┃     ┃     ┃     ┃     ┃ Error : undefined template operator for foo and {1}
    ┃     ┃     ┃     ┃     ┃     ┃  --&gt; main.yr:(5,5)
    ┃     ┃     ┃     ┃     ┃     ┃  5  ┃ 	foo!{n - 1} ();
    ┃     ┃     ┃     ┃     ┃     ┃     ╋ 	   ^
    ┃     ┃     ┃     ┃     ┃     ┃     ┃ Note : in template specialization
    ┃     ┃     ┃     ┃     ┃     ┃     ┃  --&gt; main.yr:(5,5)
    ┃     ┃     ┃     ┃     ┃     ┃     ┃  5  ┃ 	foo!{n - 1} ();
    ┃     ┃     ┃     ┃     ┃     ┃     ┃     ╋ 	   ^
    ┃     ┃     ┃     ┃     ┃     ┃     ┃ Note : foo --&gt; main.yr:(3,5) -&gt; foo
    ┃     ┃     ┃     ┃     ┃     ┃     ┃ Error : limit of template recursion reached 300
    ┃     ┃     ┃     ┃     ┃     ┃     ┃  --&gt; main.yr:(3,5)
    ┃     ┃     ┃     ┃     ┃     ┃     ┃  3  ┃ def foo {n : i32} () {
    ┃     ┃     ┃     ┃     ┃     ┃     ┃     ╋     ^^^
    ┃     ┃     ┃     ┃     ┃     ┃     ┗━━━━━┻━ 
    ┃     ┃     ┃     ┃     ┃     ┗━━━━━┻━ 
    ┃     ┃     ┃     ┃     ┗━━━━━┻━ 
    ┃     ┃     ┃     ┗━━━━━┻━ 
    ┃     ┃     ┗━━━━━┻━ 
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br> <strong>Contribution</strong>: add an option to the compiler to change this
value of <strong><code>300</code></strong>.</p>
<a class="header" href="templates/cte.html#template-type-for-template-variable" id="template-type-for-template-variable"><h3>Template type for template variable</h3></a>
<p>The type of a <em>cte</em> variable can be a template. In that case the used
template identifiers must be roots of the template parameters (exactly
the same behavior as the <em>of filter</em>). In the following example, the
function <strong><code>foo</code></strong> takes a value as template parameter, the type of
this value can be anything as long as it can be known at compile time.</p>
<pre><code class="language-ymir">import std::io;

def foo {N : T, T} () {
    println (T::typeid, &quot;(&quot;, N, &quot;)&quot;);
}

def main () {
    foo!42 ();
    foo!&quot;Hi !&quot; ();
}
</code></pre>
<p><br>
Results:</p>
<pre><code>i32(42)
[c32](Hi !)
</code></pre>
<p><br> Compilation time values, can also be used to get the size of a
static array at compilation time, and make a template function that
accepts arrays of any size. This evidently works only on static
arrays, and not on slice, because the size of the array has to be
knwon at compilation time. However, this would not be necessary when
using slice, because function accepting slice as parameter already
accepts slices of any size.</p>
<pre><code class="language-ymir">import std::io

def foo {ARRAY of [T; N], T, N : usize} (a : ARRAY) {
    println (&quot;Got an array of &quot;, T::typeid, &quot; of size : &quot;, N);
    println (a);
}

def main () {
    let array = [0; 10u64];
    foo (array);
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Got an array of i32 of size : 10
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
<a class="header" href="templates/cte.html#function-pointers" id="function-pointers"><h2>Function pointers</h2></a>
<p>Lambda functions and function pointers can be compile time knwon
values. This is not the case for closure, and method delegates. Unlike
function pointers, template function are statically written in the
generated executable, thus more efficient (even if we are talking of
marginal gain). To accept a function pointer, a template variable must
be defined in the template parameters. In the following example, the
function <strong><code>foo</code></strong> accepts a function pointer, that takes two
parameters, and return a value of the same type of the
parameters. This type seems to be unknown and is not inferable from
the lambda function that is passed to the function at line <strong><code>13</code></strong>,
but is infered from the execution time parameters passed to the
function. At line <strong><code>14</code></strong>, one can note that a standard function can
be used as a template variable.</p>
<pre><code class="language-ymir">import std::io;


def foo {F : fn (X, X)-&gt; X, X} (a : X, b : X) {
    println (&quot;Foo : &quot;, F (a, b));
}

def bar (a : i32, b : i32) -&gt; i32 {
    a * b
}

def main () {
    foo!{|x, y| =&gt; x + y} (11, 31);
    foo!bar (6, 7);
}
</code></pre>
<p><br>
Results</p>
<pre><code>Foo : 42
Foo : 42
</code></pre>
<p><br> In the following example, the function pointer this time return a
different type from the type of the parameters it takes. This function
<strong><code>foo</code></strong> applies this function pointer to all element of the slice it
takes as parameters.</p>
<pre><code class="language-ymir">import std::io;

def foo {F : fn (X)-&gt; Y, X, Y} (a : [X]) {
    for i in a {
        println (&quot;Foo : &quot;, F (i));
    }
}

def main () {
    foo!{|x| =&gt; cast!i64 (x) + 12i64} ([1, 2, 3]);
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Foo : 13
Foo : 14
Foo : 15
</code></pre>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="templates/special.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="templates/values.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="templates/special.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="templates/values.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        
        <script type="text/javascript" src="custom.js"></script>
        

    </body>
</html>
