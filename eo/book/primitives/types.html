<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Datenaj tipoj - Ymir Tour</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        
        <link rel="stylesheet" href="custom.css">
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> Antaŭparolo</a></li><li><a href="hello-world/README.html"><strong>2.</strong> Bonan tagon mondo</a></li><li><ul class="section"><li><a href="hello-world/commentaires.html"><strong>2.1.</strong> Komentoj</a></li></ul></li><li><a href="primitives/README.html"><strong>3.</strong> Bazaj konceptoj de programado</a></li><li><ul class="section"><li><a href="primitives/variables.html"><strong>3.1.</strong> Variablo kaj Ŝanĝebleco</a></li><li><a href="primitives/types.html" class="active"><strong>3.2.</strong> Datenaj tipoj</a></li><li><a href="primitives/functions.html"><strong>3.3.</strong> Funkcioj</a></li><li><a href="primitives/control.html"><strong>3.4.</strong> Kontrolaj fluoj</a></li><li><a href="primitives/operator.html"><strong>3.5.</strong> Prioritato de operacioj</a></li></ul></li><li><a href="advanced/README.html"><strong>4.</strong> Alnomoj, Referencoj kaj pureco</a></li><li><ul class="section"><li><a href="advanced/references.html"><strong>4.1.</strong> Referencoj</a></li><li><a href="advanced/alias.html"><strong>4.2.</strong> Alnomoj</a></li><li><a href="advanced/copies.html"><strong>4.3.</strong> Kopio kaj profunda kopio</a></li><li><a href="advanced/best.html"><strong>4.4.</strong> Plej bonaj kutimoj</a></li><li><a href="advanced/pure.html"><strong>4.5.</strong> Puraj valoroj</a></li></ul></li><li><a href="modules/README.html"><strong>5.</strong> Pakaĵoj</a></li><li><a href="types/README.html"><strong>6.</strong> Tipoj difinitaj de la uzanto</a></li><li><ul class="section"><li><a href="types/struct.html"><strong>6.1.</strong> Strukturo</a></li><li><a href="types/enum.html"><strong>6.2.</strong> Enumeracio</a></li><li><a href="types/aka.html"><strong>6.3.</strong> Kaŝnomo</a></li></ul></li><li><a href="objects/README.html"><strong>7.</strong> Objektoj</a></li><li><ul class="section"><li><a href="objects/class.html"><strong>7.1.</strong> Klaso</a></li><li><a href="objects/mutability.html"><strong>7.2.</strong> Ŝanĝebleco</a></li><li><a href="objects/methods.html"><strong>7.3.</strong> Metodoj</a></li><li><a href="objects/inheritance.html"><strong>7.4.</strong> Heredeco</a></li><li><a href="objects/traits.html"><strong>7.5.</strong> Trajto</a></li><li><a href="objects/cast.html"><strong>7.6.</strong> Tipŝanĝo, kaj dinamikaj tipoj</a></li></ul></li><li><a href="functions/README.html"><strong>8.</strong> Funkcioj pli kompleksaj</a></li><li><a href="pattern/README.html"><strong>9.</strong> Skema kongruo</a></li><li><a href="errors/main.html"><strong>10.</strong> Traktado de Eraroj</a></li><li><ul class="section"><li><a href="errors/scope_guards.html"><strong>10.1.</strong> Regionaj gardantoj</a></li><li><a href="errors/catching.html"><strong>10.2.</strong> Kapti erarojn</a></li><li><a href="errors/option.html"><strong>10.3.</strong> Esceptoj kaj opcia tipo</a></li><li><a href="errors/fptr_closure.html"><strong>10.4.</strong> Montrilo de Malsekuraj Funkcioj</a></li></ul></li><li><a href="templates/README.html"><strong>11.</strong> Ŝablonoj</a></li><li><ul class="section"><li><a href="templates/special.html"><strong>11.1.</strong> Ŝablonaj tipoj</a></li><li><a href="templates/cte.html"><strong>11.2.</strong> Ŝablonaj valoroj</a></li><li><a href="templates/values.html"><strong>11.3.</strong> Plenumo dum kompilado</a></li></ul></li><li><a href="objects/common_traits.html"><strong>12.</strong> Ordinaraj trajtoj</a></li><li><ul class="section"><li><a href="traits/streamable.html"><strong>12.1.</strong> &quot;Streamable&quot;</a></li><li><a href="traits/copiable.html"><strong>12.2.</strong> &quot;Copiable&quot;</a></li><li><a href="traits/disposable.html"><strong>12.3.</strong> &quot;With&quot; gardanto kaj &quot;Disposable&quot;</a></li><li><a href="traits/hashable.html"><strong>12.4.</strong> &quot;Hashable&quot;</a></li><li><a href="traits/serialize.html"><strong>12.5.</strong> &quot;Packable&quot; kaj &quot;Serializable&quot;</a></li></ul></li><li><a href="templates/operators.html"><strong>13.</strong> Transŝargo de Operacisimboloj</a></li><li><ul class="section"><li><a href="templates/binary.html"><strong>13.1.</strong> Unuopaj, duopaj kaj komparaj operacioj</a></li><li><a href="templates/complex_operators.html"><strong>13.2.</strong> Aliraj, Enhavaj kaj iteraciaj operacioj</a></li></ul></li><li><a href="version/README.html"><strong>14.</strong> Versioj</a></li><li><a href="macros/README.html"><strong>15.</strong> Makrooj</a></li><li><ul class="section"><li><a href="macros/std.html"><strong>15.1.</strong> Normaj kaj kernaj makrooj</a></li></ul></li><li><a href="documentation/README.html"><strong>16.</strong> Dokumentaro</a></li><li><ul class="section"><li><a href="documentation/types.html"><strong>16.1.</strong> Tipoj</a></li><li><a href="documentation/symbols.html"><strong>16.2.</strong> Simboloj</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Ymir Tour</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="primitives/types.html#primitives-types" id="primitives-types"><h1>Primitives types</h1></a>
<p>In <em>Ymir</em> language, each value has a certain type of data, which
indicates how the program must behave and how it should operate with
the value. <em>Ymir</em> is a statically typed language, which means that
all types of all values must be known at compile time. Usually, the
compiler is able to infer the data types from the values, and it is
not necessary to specify them when declaring a variable. But
sometimes, when it comes to the mutability of a variable or the
inheritance of a class for example, the inference can be wrong and
the behavior not adapted to what you might want to do.</p>
<p>Therefore, the type may be added when declaring a variable, as in the
following code.</p>
<pre><code class="language-ymir">let mut x : [mut i32] = [1, 2];
let mut y = [1, 2];
</code></pre>
<p><br></p>
<p>To understand the difference between the type of <strong><code>x</code></strong> and the type
of <strong><code>y</code></strong>, we invite you to read the chapter
<a href="https://gnu-ymir.github.io/Documentations/en/advanced/">Aliases and References</a>.</p>
<p>Each type has type attributes. Theses attributes are accessed using
the double colon operator <strong><code>::</code></strong> on a type expression.</p>
<pre><code class="language-ymir">let a = i32::init;  // i32 (0)
</code></pre>
<p><br></p>
<p>All primitive types have common attributes that are listed in the
table below. Attributes can be surrounded by the token <strong><code>_</code></strong>, to avoid some
ambiguity for some types (<em>cf.</em>
<a href="https://gnu-ymir.github.io/Documentations/en/types/enum.html">Enumeration</a>). For
example, the attribute <strong><code>typeid</code></strong> is equivalent to <code>__typeid__</code>, or
<code>_typeid</code>.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>init</code> </td><td> The initial value of the type </td></tr>
<tr><td> <code>typeid</code> </td><td>  The name of the type stored in a value of type <strong><code>[c32]</code></strong> </td></tr>
<tr><td> <code>typeinfo</code> </td><td> A structure of type TypeInfo, containing information about the type </td></tr>
</tbody></table>
<p>All the information about TypeInfo are presented in chapter <a href="https://gnu-ymir.github.io/Documentations/en/types_advanced/">Dynamic
types</a>.</p>
<a class="header" href="primitives/types.html#typeof-and-sizeof" id="typeof-and-sizeof"><h2><em>typeof</em> and <em>sizeof</em></h2></a>
<ol>
<li>The keyword <strong><code>typeof</code></strong> retreives the type of a value at
compilation time. This type can be used in any context, to retreive
type information. For example, in a variable declaration, a function
parameter, or return type, structure fields, etc..</li>
</ol>
<pre><code class="language-ymir">import std::io;

def bar () -&gt; i32 {
    42 
}

def foo () -&gt; typeof (bar ()) {
    bar ()
}

def main () {
    let x : typeof (foo ()) = foo ();
    
    println (typeof (x)::typeid, &quot; (&quot;, x, &quot;)&quot;);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>i32 (42)
</code></pre>
<p><br></p>
<ol start="2">
<li>The keyword <strong><code>sizeof</code></strong> retreive the size of a type in bytes at
compilation time. It is applicable only on types, not on value, but
the type of a value can be retreive using the <strong><code>typeof</code></strong>
keyword. This size is given in a value of type <strong><code>usize</code></strong> (this
scalar type is presented below).</li>
</ol>
<pre><code class="language-ymir">import std::io;

def main () {
    let x : usize = sizeof (i32);
    println (x, &quot; &quot;, sizeof (typeof (x)));
}
</code></pre>
<p><br></p>
<p>Results: (on a x86-64 arch)</p>
<pre><code>4 8
</code></pre>
<p><br></p>
<a class="header" href="primitives/types.html#scalar-types" id="scalar-types"><h2>Scalar types</h2></a>
<p>Scalar types represent all types containing a single value. <em>Ymir</em>
has five primitive scalar types: integers, floating point, characters,
booleans, and pointers. They can have different sizes for different
purposes.</p>
<a class="header" href="primitives/types.html#integer-types" id="integer-types"><h3>Integer types</h3></a>
<p>An integer is a number without decimal points. There are different
types of integers in <em>Ymir</em>, the signed one and the unsigned
one. Signed and unsigned refers to the possibility for a number to be
negative. Signed integer types begin with the letter <strong><code>i</code></strong>, while
unsigned integers begin with the letter <strong><code>u</code></strong>. The following table
lists all the different types of integers, and sorts them by memory
size.</p>
<table><thead><tr><th> size </th><th> signed </th><th> unsigned </th></tr></thead><tbody>
<tr><td> 8 bits </td><td> i8 </td><td> u8 </td></tr>
<tr><td> 16 bits </td><td> i16 </td><td> u16 </td></tr>
<tr><td> 32 bits </td><td> i32 </td><td> u32 </td></tr>
<tr><td> 64 bits </td><td> i64 </td><td> u64 </td></tr>
<tr><td> arch </td><td> isize </td><td> usize </td></tr>
</tbody></table>
<p>The <code>usize</code> and <code>isize</code> types are architecture dependent, and have the
size of a pointer, depending on the architecture targeted.</p>
<p>Each type of signed integer can store values ranging from <em>-(2
<sup>n - 1</sup>)</em> to <em>2 <sup>n - 1</sup> - 1</em>, where <em>n</em> is the size
of the integer in memory. Unsigned types, on the other hand, can store
numbers ranging from <em>0</em> to <em>2 <sup>n</sup> - 1</em>. For example, type
<strong><code>i8</code></strong>, can store values from <em>-128</em> to <em>127</em>, and type <strong><code>u8</code></strong> can
store values from <em>0</em> to <em>255</em>.</p>
<p>You can write an integer in two forms, decimal <code>9_234</code> and hexadecimal
<code>0x897A</code>. The <code>_</code> token, is simply ignored in a literal integer.</p>
<p>To make sure a literal value has the right type, a prefix can be added
at the end of it. For example, to get a <strong><code>i8</code></strong> with the value <em>7</em>,
the right literal is written <code>7i8</code>. By default, if no prefix is added
at the end of the literal, the language defines its type as a
<strong><code>i32</code></strong>.</p>
<p>As indicated above, each type has attributes, the following table
lists the integer-specific attributes:</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>max</code> </td><td> The maximal value </td></tr>
<tr><td> <code>min</code> </td><td> The minimal value </td></tr>
</tbody></table>
<p>An overflow check is performed on literals at compilation time, and an
error is returned by the compiler if the type of integer choosed to
encode the literal is not large enough to contain the value. For
example:</p>
<pre><code class="language-ymir">def main () {
    let x : i8 = 934i8;
}
</code></pre>
<p>Because a i8 can only store value ranging from <code>-127</code> to <code>128</code>, the
value <code>934</code> would not fit. For that reason the compiler returns the
following error.</p>
<pre><code class="language-error">Error : overflow capacity for type i8 = 943
 --&gt; main.yr:(12,18)
    ┃ 
12  ┃     let x : i8 = 943i8;
    ┃                  ^^^

ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p><strong>WARNING</strong> However, if the value cannot be known at compile time, the
overflow is not checked and can lead to strange behavior. For example,
if you try to add 1 to a variable of type <strong><code>i16</code></strong> that contains the
value <code>32767</code>, the result will be <code>-32768</code>. <em>Contribution:</em> Provide a
dynamic way to verify the overflow of arithmetic operation (at least
in debug mode).</p>
<a class="header" href="primitives/types.html#floating-point-types" id="floating-point-types"><h3>Floating-point types</h3></a>
<p>Floating-point types, refer to numbers with a decimal
part. <em>Ymir</em> provides two types of floating point numbers, <strong><code>f32</code></strong>
and <strong><code>f64</code></strong>, which have a size of 32 bits and 64 bits respectively.</p>
<p>You can add the prefix <strong><code>f</code></strong>, at the end of a literal floating point
to specify that you want a <strong><code>f32</code></strong>, instead of a <strong><code>f64</code></strong> as it is
by default.</p>
<pre><code class="language-ymir">def main () {
    let x = 1.0; 
    let y : f32 = 1.0f;
}
</code></pre>
<p>The following table lists the attributes specific to floating point
types.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>init</code> </td><td> The initial value - <code>nan</code> </td></tr>
<tr><td> <code>max</code> </td><td> The maximal finite value that this type can encode</td></tr>
<tr><td> <code>min</code> </td><td> The minimal finite value that this type can encode</td></tr>
<tr><td> <code>nan</code> </td><td> The value <strong>Not a Number</strong> </td></tr>
<tr><td> <code>dig</code> </td><td> The number of decimal digit of precision </td></tr>
<tr><td> <code>inf</code> </td><td> The value positive infinity </td></tr>
<tr><td> <code>epsilon</code> </td><td> The smallest increment to the value <code>1</code> </td></tr>
<tr><td> <code>mant_dig</code> </td><td> Number of bits in the  <strong>mantissa</strong> </td></tr>
<tr><td> <code>max_10_exp</code> </td><td>    maximum int value such that $$10^{max_10_exp}$$ is representable </td></tr>
<tr><td> <code>max_exp</code> </td><td> maximum int value such that $$2^{max_exp-1}$$ is representable</td></tr>
<tr><td> <code>min_10_exp</code> </td><td> minimum int value such that $$10^{min_10_exp}$$ is representable as a normalized value</td></tr>
<tr><td> <code>min_exp</code> </td><td> minimum int value such that $$2^{min_exp-1}$$ is representable as a normalized value</td></tr>
</tbody></table>
<a class="header" href="primitives/types.html#boolean-type" id="boolean-type"><h3>Boolean type</h3></a>
<p>A boolean is a very simple type that can take two values, either <code>true</code> or <code>false</code>.  For example:</p>
<pre><code class="language-ymir">def main () {
    let b = true;
    let f : bool = false;
}
</code></pre>
<p><br></p>
<p>The following table lists the attributes specific to boolean type.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>init</code> </td><td> The initial value - <code>false</code> </td></tr>
</tbody></table>
<a class="header" href="primitives/types.html#character-type" id="character-type"><h3>Character type</h3></a>
<p>The <strong><code>c8</code></strong> and <strong><code>c32</code></strong> are the types used to encode the
characters. The <strong><code>c32</code></strong> character has a size of four bytes and can
store any unicode value.  Literal characters can have two forms, and
are always surrounded by the token <strong><code>'</code></strong>. The first form is the
character itself for example <strong><code>'r'</code></strong>, and the second is the unicode
value in the integer form <code>\u{12}</code> or <code>\u{0xB}</code>.</p>
<p>As with literal integers, it is necessary to add a prefix
to define the type of a literal. The prefix used to specify the type
of a literal character is <strong><code>c8</code></strong>, if nothing is specified, the
character type will be <strong><code>c32</code></strong>.</p>
<pre><code class="language-ymir">def main () {
    let x = '☺';	
    let y = '\u{0x263A}';
}
</code></pre>
<p><br></p>
<p>If the loaded literal is too long to be stored in the character type,
an error will be returned by the compiler. For example :</p>
<pre><code class="language-ymir">def main () {
    let x = '☺'c8; 
}
</code></pre>
<p><br></p>
<p>The error will be the following. This error means that you will need
at least 3 <strong><code>c8</code></strong> (or bytes) to store the value, so it doesn't fit into one
<strong><code>c8</code></strong> :</p>
<pre><code class="language-error">Error : malformed literal, number of c8 is 3
 --&gt; main.yr:(2,10)
    | 
 2  | 	let x = '☺'c8; 
    | 	        ^

ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>The following table lists the attributes specific to character types.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>init</code> </td><td> The initial value - <code>\u{0}</code> </td></tr>
</tbody></table>
<a class="header" href="primitives/types.html#pointers" id="pointers"><h3>Pointers</h3></a>
<p>Pointer are values that stores an address of memory. They can be used
to store the location of a data in memory. In <em>Ymir</em>, pointers are
considered low level programming and are mainly used in the std, and
runtime to interface with machine level semantics. You can perfectly
write any program without needing pointers, and for that reason we
recomand to not use them.</p>
<p>Pointers are defined using the token <strong><code>&amp;</code></strong> on types, or on
values. They are aliasable types, as they borrow memory (<em>cf.</em> <a href="https://gnu-ymir.github.io/Documentations/en/advanced/">Aliasable
and
References</a>).</p>
<pre><code class="language-ymir">import std::io;

def main ()
    throws &amp;SegFault, &amp;AssertError
{
    let mut i = 12;
    let p : &amp;i32 = &amp;i; // creation of a pointer on i
    i = 42;
    assert (*p == 42); // dereference the pointer and access the value
}
</code></pre>
<p><br></p>
<p>Pointers are unsafe, and dereferencing a pointer can result in undefined
behavior depending on where it points. It can also sometimes raise a
segmentation fault. In <strong><code>Ymir</code></strong>, segmentation fault are recovered,
and an exception is thrown. Error handling is presented in chaper
<a href="https://gnu-ymir.github.io/Documentations/en/errors/main.html">Error
Handling</a>.</p>
<p><strong>WARNING</strong>, Note that the segmentation fault may not occur even if
the pointer is not properly set. The easiest way to avoid undefined
behavior is to not use pointers and use <code>std</code> verified functions, or
other semantically verified elements (cf <a href="https://gnu-ymir.github.io/Documentations/en/advanced/">Aliasable and
References</a>).</p>
<p><br></p>
<p>The following table lists the attributes specific to pointer types.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>inner</code> </td><td> The type of the inner value - for example : <code>i32</code> for <code>&amp;i32</code> </td></tr>
</tbody></table>
<a class="header" href="primitives/types.html#compound-types" id="compound-types"><h2>Compound types</h2></a>
<p>Unlike scalar types, the compound can contain multiple values.  There are
three types of compounds: the tuple, the range and the arrays.</p>
<a class="header" href="primitives/types.html#tuple" id="tuple"><h3>Tuple</h3></a>
<p>A tuple is a set of values of different types. Tuples have a fixed
arity. The arity of a tuple is defined at compilation time, and
represent the number of values contained inside the tuple. Each
element of a tuple has a type, and a given order. Tuples are built
between parentheses, by a comma-separated list of values. A tuple of
one value can be defined, by putting a coma after the first
value. This way the compiler can understand the desire of creating a
tuple, and do not confuse it with a normal expression between
parentheses.</p>
<pre><code class="language-ymir">def main () {
    let t : (i32, c32, f64) = (1, 'r', 3.14);  // three value tuple
    let t2 : (i32,) = (1,); // single value tuple
    let t3 : i32 = (1); // single value of type i32
}
</code></pre>
<p><br></p>
<p>In the above example, the tuple <code>t</code>, is a single element, and can be
used as a function parameter or as a return value of a function. It
can also be destructured, to retrieve the values of its component
elements. There are three ways of tuple destructuring.</p>
<ol>
<li>the dot operator <strong><code>.</code></strong>, followed by an integer value, whose value
is known at compilation time. This value can be computed by a complex
expression, as long as the compiler is able to retreive the value at
compilation time (<em>cf.</em> <a href="https://gnu-ymir.github.io/Documentations/en/templates/cte.html">Compilation time
execution</a>).</li>
</ol>
<pre><code class="language-ymir">import std::io;

def main () {
    let t = (1, 'r', 3.14);
    let z : i32 = t._0;
    let y : c32 = t. (0 + 1); 
    println (t.2);
}
</code></pre>
<p><br></p>
<ol start="2">
<li>the tuple destructuring syntax. This syntax, close to variable
declaration, creates new variables that contains parts of the tuple
that is destructured. In the following example, one can note that the
tuple destructuring syntax allows to extract only some of the tuple
values. The type of the variable <strong><code>e</code></strong> is the tuple <strong><code>(c32, f64)</code></strong>, and its values are <strong><code>('r', 3.14)</code></strong>, when the variable
<strong><code>f</code></strong> contains the value <strong><code>1</code></strong> of type <strong><code>i32</code></strong>.</li>
</ol>
<pre><code class="language-ymir">def main () {
    let t = (1, 'r', 3.14);
    let (x, y, z) = t;
    
    let (f, e...) = t;
    println (f, &quot; &quot;, e.0);
}
</code></pre>
<p><br></p>
<ol start="3">
<li>the keyword <strong><code>expand</code></strong>. this keyword is a compile-time rewrite,
that expands the values of a tuple into a list of values. This list is
then used to create other tuples, call functions, etc. The following
example shows the use of the keyword <strong><code>expand</code></strong> to call a function
taking two parameters, with the value of a tuple containing two
values.</li>
</ol>
<pre><code class="language-ymir">import std::io

def add (a : i32, b : i32) -&gt; i32 
    a + b


def main () {
    let x = (1, 2);
    println (add (expand x)); 
    // ^^^^^^^^^^^^^^^^^^^^^^
    // Will be rewritten into : 	
    // println (add (x.0, x.1));
    
    let j : (i32, i32, i32) = (1, expand x);	
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // rewritten into : (1, x.0, x.1)
}
</code></pre>
<p><br></p>
<p>There is two other ways to destructurate a tuple. These ways are
presented in forthcoming chapters. The following table lists the
attributes specific to tuple types.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>arity</code> </td><td> The number of elements contained in the tuple (in a <strong><code>u32</code></strong>) </td></tr>
<tr><td> <code>init</code> </td><td> a tuple, where each element values are set to <code>init</code>  </td></tr>
</tbody></table>
<a class="header" href="primitives/types.html#ranges" id="ranges"><h3>Ranges</h3></a>
<p>Ranges are types that contain values defining an interval. A range is
named <strong><code>r!T</code></strong>, where <strong><code>T</code></strong> is the type of the range limits. They
are created by the token <strong><code>..</code></strong> and <strong><code>...</code></strong>. A range consists of
four values, which are stored in the fields shown in the following
table. These fields can be accessed using the dot operator <strong><code>.</code></strong>.</p>
<table><thead><tr><th> name </th><th> type </th><th> value </th></tr></thead><tbody>
<tr><td> fst </td><td> T </td><td> the first bound </td></tr>
<tr><td> scd </td><td> T </td><td> the second bound </td></tr>
<tr><td> step </td><td> mut T </td><td> the step of the interval </td></tr>
<tr><td> contain </td><td> bool </td><td> Is the scd bound contained in the interval ? </td></tr>
</tbody></table>
<pre><code class="language-ymir">def main () {
    let range : r!(i32) = 1 .. 8; 	
    let c_range : r!(i32) = 1 ... 8;
}
</code></pre>
<p><br></p>
<p>The <code>step_by</code> function takes a range as a parameter and returns a new
range, with a modified step. This function is a core function, thus
there is nothing to import.</p>
<pre><code class="language-ymir">def main () { 
    let range = (1 .. 8).step_by (2); 
} 
</code></pre>
<p><br></p>
<p>The <a href="https://gnu-ymir.github.io/Documentations/en/primitives/control.html">Control
flows</a>
section shows a use of these types.</p>
<a class="header" href="primitives/types.html#arrays" id="arrays"><h3>Arrays</h3></a>
<p>An array is a collection of values of the same type, stored in
contiguous memory.  Unlike tuples, the size of an array is unknown at
compile time, and in <em>Ymir</em>, they are similar to slices, and will be
refered as such. Slices are defined with a syntax close to the one of
tuple, but with brackets instead of parentheses, for example <strong><code>[1, 2, 3]</code></strong>.  The type of a slice is also defined using the brackets, for
example <strong><code>[i32]</code></strong>, meaning a slice containing <strong><code>i32</code></strong> values.</p>
<p>String literals, enclosed between double quotes are a special case of
slice literals. There is no string type in <em>Ymir</em>, but only slices
type. Because of this, string values are typed <strong><code>[c32]</code></strong> or
<strong><code>[c8]</code></strong> depending on the type of values contained in the
slice. String literals can be prefixed with the keyword <strong><code>s8</code></strong> or
<strong><code>s32</code></strong> to define the encoding system used. By default, when no
prefix is specified a string literal have a type <strong><code>[c32]</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

def main () { 
    let x = [1, 2, 3]; // a [i32] slice
    let y = &quot;Hello World !!&quot;; // a [c32] slice
    let z = &quot;Hello World !!&quot;s8; // a [c8] slice
}
</code></pre>
<p><br></p>
<p><strong>Warning</strong>: The length of a <strong><code>[c8]</code></strong> literals can seem incorrect
due to the encoding system. For example, the slice <strong><code>&quot;☺&quot;s8</code></strong> have a
length of <strong><code>3</code></strong>. To summarize, <strong><code>[c8]</code></strong> slices are utf-8 encoded
string literals, when <strong><code>[c32]</code></strong> are encoded in utf-32.</p>
<p>A slice is a two-word object, the first word is the length of the
slice, and the second is a pointer to the data stored in the slice. A
slice is an aliasable type, its mutability is a bit more complicated
than the mutability of scalar types (except pointers), because it
borrows memory which is not automatically copied when an assignment is
made. This section will not discuss the mutability of internal types
or aliasable types. This is discussed in the chapter <a href="https://gnu-ymir.github.io/Documentations/en/advanced/">Aliases and
References</a>.</p>
<p>The field <strong><code>len</code></strong> records the length of the slice and can be
retrieved with the dot operator <strong><code>.</code></strong>.  The length of the slice is
stored in a <strong><code>usize</code></strong> field.</p>
<pre><code class="language-ymir">import std::io
 
def main () {
   let x = [1, 2, 3];
   println (&quot;The value of x : &quot;, x); 
   println (&quot;The length of x : &quot;, x.len);
}
</code></pre>
<p><br></p>
<p>Similarly, the <strong><code>ptr</code></strong> field, gives access to the pointer of the
slice and its types depend on the inner type of the slice, and is
never mutable. Pointer type are absolutely not important for a
<em>Ymir</em> program, and we suspect that you will never have use of
them. They are defined to allow low level programming paradigms, and
are used in the std and runtime.</p>
<p>To access the elements of an array, the <strong><code>[]</code></strong> operator is used. It
takes either an integer value or a range value as parameter. If a
range value is given, a second slice that borrows a section of the
first is created. For now, the step of the range does not affect the
borrowing of the array. <em>Contribution</em> can be made here. On the other
hand if an integer value <strong><code>i</code></strong> is given as parameter, the value at
the index <strong><code>i</code></strong> is returned.</p>
<pre><code class="language-ymir">import std::io;

def main () 
    throws &amp;OutOfArray 
{
    let x = [1, 2, 3];
    let y = x [0 .. 2];
    let z = x [0];
    
    println (x, &quot; &quot;, y, &quot; &quot;, z); 
}
</code></pre>
<p><br></p>
<p>The length of a slice is unknown at compilation time, and access can
be made with dynamic integers whose values are also unknown at
compilation time. For that reason, it may happen that the parameters
used go beyond the slice length. With this in mind, slice access is
considered unsafe, and can throw an exception of type
<strong><code>&amp;OutOfArray</code></strong>. The exception system, and error handling is
detailed in the chapter <a href="https://gnu-ymir.github.io/Documentations/en/errors/main.html">Error
Handling</a>.</p>
<p>Slices can be concatenated, to form another slice. The concatenation
is made using the operator tilde on two operands. To work properly and
be accepted by the language, the two slice used as operands must share
the same type (but not necessarily mutability level, the mutability of
the operand with the lowest mutability level is choosed for the result
of the operation <em>cf.</em> <a href="https://gnu-ymir.github.io/Documentations/en/advanced/">Aliases and
References</a>).</p>
<pre><code class="language-ymir">import std::io

def foo () -&gt; [i32] {
    [8, 7, 6]
}

def main ()  {
    println ([1, 2, 3] ~ foo ());
}
</code></pre>
<p><br>
Results:</p>
<pre><code>[1, 2, 3, 8, 7, 6]
</code></pre>
<p><br></p>
<p>The tilde token was chosen to avoid some ambiguity. In some languages
such as Java, the concatenation is made using the token <strong><code>+</code></strong> that
sometimes creates some ambiguity when concatenating strings, and other
elements such as integers. For example, the expression <strong><code>&quot;foo&quot; + 1 + 2</code></strong>, is ambiguous.
One can note however, that since concatenation only works on slices of
the same type, the following expression <code>&quot;foo&quot; ~ 2</code>, is invalid as
&quot;foo&quot; is of type <strong><code>[c32]</code></strong>, and <strong><code>2</code></strong> of type <strong><code>i32</code></strong>.</p>
<p>Another syntax can be used to create slices. This syntax called <em>slice
allocation</em>, allocates a slice on the heap and set the same value to
every element of the slice.</p>
<pre><code class="language-ymir">import std::io
import std::random;

def main () {
    let a : [i32] = [0 ; new 100u64]; // this avoids the write of 100 zeros
                                      // but the result is the same
                              
    let b = [12 ; new uniform (10, 100)]; 
    //                ^^^^^^^ generates a random value between 10 and 100
    println (a, &quot; &quot;, b);
}
</code></pre>
<p><br></p>
<p>The following table lists the attributes specific to slice types.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>inner</code> </td><td> the inner type </td></tr>
<tr><td> <code>init</code> </td><td> an empty slice (with <code>len == 0us</code>) </td></tr>
</tbody></table>
<a class="header" href="primitives/types.html#static-arrays" id="static-arrays"><h3>Static Arrays</h3></a>
<p>Unlike the slice, static arrays are stored in the stack rather than on
the heap. To be possible, their size must be known at compilation
time. The syntax used to create a static array is close to the syntax
of a <em>slice allocation</em>, but the keyword <strong><code>new</code></strong> omitted.</p>
<pre><code class="language-ymir">import std::io

/**
  * Takes an array of size twelve as parameter
  */
def foo (a : [i32 ; 12]) {
    println (a);
}

def main ()
    throws &amp;OutOfArray
{
    let mut a : [mut i32 ; 12] = [0 ; 12];

    for i in 0 .. 12
        a [i] = i

    let b = [1; 12];

    foo (a);
    foo (b);
}
</code></pre>
<p><br></p>
<p>A static array can be transformed into a slice using the <code>alias</code>,
<code>copy</code> and <code>dcopy</code> keywords. The chapter <a href="https://gnu-ymir.github.io/Documentations/en/advanced/">Aliases and
references</a>
explains the difference between these keywords.</p>
<pre><code class="language-ymir">import std::io

def main () {
    let x : [i32; 12] = [0; 12];
    
    let a : [i32] = alias x;
    let b = copy x;
    
    println (a, &quot; &quot;, b);
}
</code></pre>
<p><br></p>
<p>One can argue that slice literals should be of static array type. We
made the choice to create slices from array literals rather than
static arrays to avoid verbosity, as we claim that slices are way more
commonly used than arrays with a static size. We are for the moment
considering the possibility to prefix slice literals, to define static
array literals, but the question is not yet decided.</p>
<p><br></p>
<p>The following table lists the attributes specific to array types.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>inner</code> </td><td> the inner type </td></tr>
<tr><td> <code>len</code> </td><td> the len of the array (<code>usize</code> value) </td></tr>
<tr><td> <code>init</code> </td><td> an array where each element is set to the <code>init</code> value of the inner type </td></tr>
</tbody></table>
<a class="header" href="primitives/types.html#option" id="option"><h3>Option</h3></a>
<p>The option typed values are values that may be set or not. They are
defined using the token <strong><code>?</code></strong> on types or values. Further
information on option type are given in the chapter <a href="https://gnu-ymir.github.io/Documentations/en/errors/main.html">Error
handling</a>,
as they are completely related to error management system.</p>
<pre><code class="language-ymir">import std::io;

def main () {
    let i : i32? = (12)?; // an option type containing the value 12
    let j : i32? = (i32?)::err; // an option value containing no value
}
</code></pre>
<p><br></p>
<p>The value of an option type can be retreived using functions in the
std, or pattern matching. In this chapter, we only focus on the
<strong><code>unwrap</code></strong> function, pattern matching being left for a future
chapter (<em>cf.</em> <a href="https://gnu-ymir.github.io/Documentations/en/pattern">Pattern
matchin</a>).  The
function <strong><code>unwrap</code></strong> from the module <strong><code>std::conv</code></strong>, get the value
contained inside an option type. If no value is contained inside the
option, the function throws an error of type <strong><code>&amp;CastFailure</code></strong>.</p>
<pre><code class="language-ymir">import std::io;
import std::conv;

def foo (b : bool)-&gt; (i32)? {
    if b { 
        19? // return the value 19, wrapped into an option
    } else {
        (i32?)::__err__ // return an empty value
    }
}


def main () 
    throws &amp;CastFailure 
{
    let x = foo (true);
    println (x.unwrap () + 23);
}
</code></pre>
<p><br></p>
<p>The following table lists the attributes specific to option types.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>err</code> </td><td> An empty option value </td></tr>
</tbody></table>
<a class="header" href="primitives/types.html#cast" id="cast"><h2>Cast</h2></a>
<p>Some value can be transformed to create value of another type. This
operation is done with the <strong><code>cast</code></strong> keywords, whose syntax is
presented in the code block below.</p>
<pre><code class="language-grammar">cast_expression := 'cast' '!' ('{' type '}' | type) expression
</code></pre>
<p><br></p>
<p>In the following example, a cast of a value of type <strong><code>i32</code></strong> to a
value of type <strong><code>i64</code></strong> is made. As said earlier, implicit casting is
not allowed. The mutability of the casted value is always lower or
equal to the mutability of the original value (for obvious reason).
<strong>Warning</strong> cast can cause loss of precision, or even sign problems.</p>
<pre><code class="language-ymir">let a = 0;
let b : i64 = cast!i64 (a);
</code></pre>
<p><br></p>
<p>The following table list the authorized casts of the primitive types :</p>
<table><thead><tr><th> From </th><th> To </th></tr></thead><tbody>
<tr><td> <code>i8</code> <code>i16</code> <code>i32</code> <code>i64</code> <code>isize</code> </td><td> <code>i8</code> <code>i16</code> <code>i32</code> <code>i64</code> <code>u8</code> <code>u16</code> <code>u32</code> <code>u64</code> <code>isize</code> <code>usize</code> </td></tr>
<tr><td> <code>u8</code> <code>u16</code> <code>u32</code> <code>u64</code> <code>usize</code> </td><td> <code>i8</code> <code>i16</code> <code>i32</code> <code>i64</code> <code>u8</code> <code>u16</code> <code>u32</code> <code>u64</code> <code>isize</code> <code>usize</code> <code>c8</code> <code>c32</code> </td></tr>
<tr><td> <code>f32</code> <code>f64</code> </td><td> <code>f32</code> <code>f64</code> </td></tr>
<tr><td> <code>c8</code> </td><td> <code>c8</code> <code>c32</code> <code>u8</code> </td></tr>
<tr><td> <code>c32</code> </td><td> <code>c8</code> <code>c32</code> <code>u32</code> </td></tr>
<tr><td> <code>&amp;(X)</code> for <code>X</code> = any type </td><td> <code>&amp;(void)</code> </td></tr>
</tbody></table>
<p>Cast if a very basic type transformation, and must be used with
precaution for basic operations. We will see in a forthecoming chapter
(<em>cf</em>. <a href="">Dynamic conversion</a>) a complex system of conversion, provided
by the standard library. This conversion system can be used to
transform value of very different type and encoding.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="primitives/variables.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="primitives/functions.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="primitives/variables.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="primitives/functions.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        
        <script type="text/javascript" src="custom.js"></script>
        

    </body>
</html>
