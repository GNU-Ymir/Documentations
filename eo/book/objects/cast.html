<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Tipŝanĝo, kaj dinamikaj tipoj - Ymir Tour</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        
        <link rel="stylesheet" href="custom.css">
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> Antaŭparolo</a></li><li><a href="hello-world/README.html"><strong>2.</strong> Bonan tagon mondo</a></li><li><ul class="section"><li><a href="hello-world/commentaires.html"><strong>2.1.</strong> Komentoj</a></li></ul></li><li><a href="primitives/README.html"><strong>3.</strong> Bazaj konceptoj de programado</a></li><li><ul class="section"><li><a href="primitives/variables.html"><strong>3.1.</strong> Variabloj kaj Ŝanĝebleco</a></li><li><a href="primitives/types.html"><strong>3.2.</strong> Datenaj tipoj</a></li><li><a href="primitives/functions.html"><strong>3.3.</strong> Funkcioj</a></li><li><a href="primitives/control.html"><strong>3.4.</strong> Kontrolaj fluoj</a></li><li><a href="primitives/operator.html"><strong>3.5.</strong> Prioritato de operacioj</a></li></ul></li><li><a href="advanced/README.html"><strong>4.</strong> Alnomoj, Referencoj kaj pureco</a></li><li><ul class="section"><li><a href="advanced/references.html"><strong>4.1.</strong> Referencoj</a></li><li><a href="advanced/alias.html"><strong>4.2.</strong> Alnomoj</a></li><li><a href="advanced/copies.html"><strong>4.3.</strong> Kopio kaj profunda kopio</a></li><li><a href="advanced/best.html"><strong>4.4.</strong> Plej bonaj kutimoj</a></li><li><a href="advanced/pure.html"><strong>4.5.</strong> Puraj valoroj</a></li></ul></li><li><a href="modules/README.html"><strong>5.</strong> Pakaĵoj</a></li><li><a href="types/README.html"><strong>6.</strong> Tipoj difinitaj de la uzanto</a></li><li><ul class="section"><li><a href="types/struct.html"><strong>6.1.</strong> Strukturo</a></li><li><a href="types/enum.html"><strong>6.2.</strong> Enumeracio</a></li><li><a href="types/aka.html"><strong>6.3.</strong> Kaŝnomo</a></li></ul></li><li><a href="objects/README.html"><strong>7.</strong> Objektoj</a></li><li><ul class="section"><li><a href="objects/class.html"><strong>7.1.</strong> Klaso</a></li><li><a href="objects/mutability.html"><strong>7.2.</strong> Ŝanĝebleco</a></li><li><a href="objects/methods.html"><strong>7.3.</strong> Metodoj</a></li><li><a href="objects/inheritance.html"><strong>7.4.</strong> Heredeco</a></li><li><a href="objects/traits.html"><strong>7.5.</strong> Trajto</a></li><li><a href="objects/cast.html" class="active"><strong>7.6.</strong> Tipŝanĝo, kaj dinamikaj tipoj</a></li></ul></li><li><a href="functions/README.html"><strong>8.</strong> Funkcioj pli kompleksaj</a></li><li><a href="pattern/README.html"><strong>9.</strong> Skema kongruo</a></li><li><a href="errors/main.html"><strong>10.</strong> Traktado de Eraroj</a></li><li><ul class="section"><li><a href="errors/scope_guards.html"><strong>10.1.</strong> Regionaj gardantoj</a></li><li><a href="errors/catching.html"><strong>10.2.</strong> Kapti erarojn</a></li><li><a href="errors/option.html"><strong>10.3.</strong> Esceptoj kaj opcia tipo</a></li><li><a href="errors/fptr_closure.html"><strong>10.4.</strong> Montrilo de Malsekuraj Funkcioj</a></li></ul></li><li><a href="templates/README.html"><strong>11.</strong> Ŝablonoj</a></li><li><ul class="section"><li><a href="templates/special.html"><strong>11.1.</strong> Ŝablonaj tipoj</a></li><li><a href="templates/cte.html"><strong>11.2.</strong> Ŝablonaj valoroj</a></li><li><a href="templates/values.html"><strong>11.3.</strong> Plenumo dum kompilado</a></li></ul></li><li><a href="objects/common_traits.html"><strong>12.</strong> Ordinaraj trajtoj</a></li><li><ul class="section"><li><a href="traits/streamable.html"><strong>12.1.</strong> &quot;Streamable&quot;</a></li><li><a href="traits/copiable.html"><strong>12.2.</strong> &quot;Copiable&quot;</a></li><li><a href="traits/disposable.html"><strong>12.3.</strong> &quot;With&quot; gardanto kaj &quot;Disposable&quot;</a></li><li><a href="traits/hashable.html"><strong>12.4.</strong> &quot;Hashable&quot;</a></li><li><a href="traits/serialize.html"><strong>12.5.</strong> &quot;Packable&quot; kaj &quot;Serializable&quot;</a></li></ul></li><li><a href="templates/operators.html"><strong>13.</strong> Transŝargo de Operacisimboloj</a></li><li><ul class="section"><li><a href="templates/binary.html"><strong>13.1.</strong> Unuopaj, duopaj kaj komparaj operacioj</a></li><li><a href="templates/complex_operators.html"><strong>13.2.</strong> Aliraj, Enhavaj kaj iteraciaj operacioj</a></li></ul></li><li><a href="version/README.html"><strong>14.</strong> Versioj</a></li><li><a href="macros/README.html"><strong>15.</strong> Makrooj</a></li><li><ul class="section"><li><a href="macros/std.html"><strong>15.1.</strong> Normaj kaj kernaj makrooj</a></li></ul></li><li><a href="documentation/README.html"><strong>16.</strong> Dokumentaro</a></li><li><ul class="section"><li><a href="documentation/types.html"><strong>16.1.</strong> Tipoj</a></li><li><a href="documentation/symbols.html"><strong>16.2.</strong> Simboloj</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Ymir Tour</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="objects/cast.html#cast-and-dynamic-typing" id="cast-and-dynamic-typing"><h1>Cast, and dynamic typing</h1></a>
<p>An object instance of a heir class can be casted to an object instance
of an ancestor class. Unlike, casting of integer values,
(e.g. <strong><code>i32</code></strong> to <strong><code>i64</code></strong>), because an object is an aliasable type,
the memory size of the object is not modified. Casting must respect
mutability of the object value. Moreover, this cast can be made
implicitely, as it does not create any problem in memory. In the
following example, the class <strong><code>Bar</code></strong> inherits from the class
<strong><code>Foo</code></strong>. A variable <strong><code>x</code></strong> is created, and is of type
<strong><code>&amp;Bar</code></strong>. At line <strong><code>1</code></strong>, an implicit cast is made of a <strong><code>&amp;Bar</code></strong>
value to a <strong><code>&amp;Foo</code></strong> value, the same cast is made but explicitely at
line <strong><code>1</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

class Foo {
    pub self () {}
    
    pub def foo (self) {
        println (&quot;Foo&quot;);
    }
}

class Bar over Foo {
    pub self () {}
    
    pub over foo (self) {
        println (&quot;Bar&quot;);
    }
}

def baz (f : &amp;Foo) {
    f.foo ();
}

def main () {
    let x = Bar::new ();
    baz (x);
    
    let y = cast!{&amp;Foo} (x);
    y.foo ();
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Bar
Bar
</code></pre>
<a class="header" href="objects/cast.html#dynamic-typeinfo" id="dynamic-typeinfo"><h2>Dynamic typeinfo</h2></a>
<p>One can note from the above example, that when a variable contains a
value of type <strong><code>&amp;Foo</code></strong>, that does not necessarily mean that this is
a pure <strong><code>&amp;Foo</code></strong> value, but it can be a <strong><code>&amp;Bar</code></strong>. In object
oriented programming, this principle is denote polyphormism. In the
chapter <a href="https://gnu-ymir.github.io/Documentations/en/primitives/">Basic programming
concepts</a>,
we have seen that every object has specific attributes. Object is no
exception to the rule. The following table lists the default specific
attributes of the object types.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>typeid</code> </td><td> The name of the type stored in a value of type [c32] </td></tr>
<tr><td> <code>typeinfo</code> </td><td> A structure of type TypeInfo, containing information about the type </td></tr>
</tbody></table>
<p>These attributes are compile time executed, and thus are static. For
example, in the following source code, the typeid of the class
<strong><code>Bar</code></strong> is printed to stdout, followed by a line that does exactly
the same thing (literraly).</p>
<pre><code class="language-ymir">def main () {
    println (Bar::typeid);
    println (&quot;main::Bar&quot;);
}
</code></pre>
<p><br></p>
<p>When it comes to dynamic typing, it can be interesting to get the
typeinfo of the type of the value that is actually stored inside the
variable (e.g. get the typeinfo of the <strong><code>Bar</code></strong> class, type of the
value contained inside a <strong><code>&amp;Foo</code></strong> variable). To do that, the
specific attribute <strong><code>typeinfo</code></strong> of object is also accessible from
the value directly, and this time dynamically.</p>
<pre><code class="language-ymir">def main () {
    let x = Bar::new ();
    let y : &amp;Foo = x;
    
    println (y::typeinfo);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>core::typeinfo::TypeInfo(13, 16, [core::typeinfo::TypeInfo(13, 16, [], main::Foo)], main::Bar)
</code></pre>
<p><br></p>
<p>The result presented above, gives the following information : 1)
we have a object, 2) its size is 16 bytes, 3) it has an ancestor
(object, size 16 bytes, no ancestor, named <strong><code>main::Foo</code></strong>), 4) its
name is <strong><code>main::Bar</code></strong>.</p>
<p>The <strong><code>TypeInfo</code></strong> returned by the <strong><code>typeinfo</code></strong> attributes (either
dynamically or statically), is a structure whose definition is the
following. The <strong><code>inner</code></strong> fields depend on the value of the
<strong><code>typeid</code></strong> field, for example, when dealing with an object it stores
the ancestor <strong><code>TypeInfo</code></strong>, and when dealing with slice, it stores
the <strong><code>TypeInfo</code></strong> of the type contained inside the slice.</p>
<pre><code class="language-ymir">pub struct
| typeid : TypeIDs
| size   : usize
| inner  : [TypeInfo]
| name   : [c32] 
 -&gt; TypeInfo;

pub enum : u32
| ARRAY        = 1u32
| BOOL         = 2u32
| CHAR         = 3u32
| CLOSURE      = 4u32
| FLOAT        = 5u32
| FUNC_PTR     = 6u32
| SIGNED_INT   = 7u32
| UNSIGNED_INT = 8u32
| POINTER      = 9u32
| SLICE        = 10u32
| STRUCT       = 11u32
| TUPLE        = 12u32
| OBJECT       = 13u32
| VOID         = 14u32
 -&gt; TypeIDs;
</code></pre>
<p><br></p>
<p>The typeinfo of a class is stored in the text and is accessible from
the vtable of the object. One can note that <strong><code>Bar</code></strong> and <strong><code>Foo</code></strong>
have a size of 16 bytes, despite the fact that they store no
fields. This is due to two pointers that are stored inside every
objects, the first pointer is refering to the monitor of the object
(<em>cf.</em> <a href="">Parallelism</a>), and the second one points the the vtable of
the object.</p>
<a class="header" href="objects/cast.html#object" id="object"><h2>Object</h2></a>
<p><em>Ymir</em> have a type named <strong><code>Object</code></strong>, that can used to cast any
object into that type. The reverse is impossible. We have seen that
the object are not inheriting from a global ancestor, and this is
really not the case. This cast unlike casting to parent class objects,
cannot be made implicitely. We can see the <strong><code>&amp;(Object)</code></strong> type as the
<strong><code>&amp;(void)</code></strong> type, that can store any pointer, but for
objects. Unlike <strong><code>&amp;(void)</code></strong> (in which by the way we can't cast
objects), <strong><code>&amp;Object</code></strong> stores one valuable information, it stores a
valid object value, with a vtable, a monitor, a typeinfo, and <strong>cannot
be <code>null</code></strong>.</p>
<p>In the following example, a pattern matching is used to check the type
of the object that is returned by the <strong><code>foo</code></strong> function. This is
discussed in chapter <a href="https://gnu-ymir.github.io/Documentations/en/pattern/">Pattern
Matching</a>.</p>
<pre><code class="language-ymir">def foo ()-&gt; &amp;Object {
    cast!{&amp;Object} (Foo::new ())
}

def main () {
    match foo () {
        Foo () =&gt; {
            println (&quot;I got a Foo !&quot;);
        }
    }
}
</code></pre>
<p><br>
Results:</p>
<pre><code>I got a Foo !
</code></pre>
<p><br></p>
<p>Some function of the standard library uses the <strong><code>Object</code></strong> type to
return values, when it is impossible statically to get more accurate
information about the type (e.g. [Packable]
(https://gnu-ymir.github.io/Documentations/en/traits/serialize.html).)</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="objects/traits.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="functions/README.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="objects/traits.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="functions/README.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        
    <script type="text/javascript">
        var socket = new WebSocket("ws://localhost:3001");
        socket.onmessage = function (event) {
            if (event.data === "reload") {
                socket.close();
                location.reload(true); // force reload from server (not from cache)
            }
        };

        window.onbeforeunload = function() {
            socket.close();
        }
    </script>


        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        
        <script type="text/javascript" src="custom.js"></script>
        

    </body>
</html>
