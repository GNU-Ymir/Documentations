<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Heredeco - Ymir Tour</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        
        <link rel="stylesheet" href="custom.css">
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> Antaŭparolo</a></li><li><a href="hello-world/README.html"><strong>2.</strong> Bonan tagon mondo</a></li><li><ul class="section"><li><a href="hello-world/commentaires.html"><strong>2.1.</strong> Komentoj</a></li></ul></li><li><a href="primitives/README.html"><strong>3.</strong> Bazaj konceptoj de programado</a></li><li><ul class="section"><li><a href="primitives/variables.html"><strong>3.1.</strong> Variablo kaj Ŝanĝebleco</a></li><li><a href="primitives/types.html"><strong>3.2.</strong> Datenaj tipoj</a></li><li><a href="primitives/functions.html"><strong>3.3.</strong> Funkcioj</a></li><li><a href="primitives/control.html"><strong>3.4.</strong> Kontrolaj fluoj</a></li><li><a href="primitives/operator.html"><strong>3.5.</strong> Prioritato de operacioj</a></li></ul></li><li><a href="advanced/README.html"><strong>4.</strong> Alnomoj, Referencoj kaj pureco</a></li><li><ul class="section"><li><a href="advanced/references.html"><strong>4.1.</strong> Referencoj</a></li><li><a href="advanced/alias.html"><strong>4.2.</strong> Alnomoj</a></li><li><a href="advanced/copies.html"><strong>4.3.</strong> Kopio kaj profunda kopio</a></li><li><a href="advanced/best.html"><strong>4.4.</strong> Plej bonaj kutimoj</a></li><li><a href="advanced/pure.html"><strong>4.5.</strong> Puraj valoroj</a></li></ul></li><li><a href="modules/README.html"><strong>5.</strong> Pakaĵoj</a></li><li><a href="types/README.html"><strong>6.</strong> Tipoj difinitaj de la uzanto</a></li><li><ul class="section"><li><a href="types/struct.html"><strong>6.1.</strong> Strukturo</a></li><li><a href="types/enum.html"><strong>6.2.</strong> Enumeracio</a></li><li><a href="types/aka.html"><strong>6.3.</strong> Kaŝnomo</a></li></ul></li><li><a href="objects/README.html"><strong>7.</strong> Objektoj</a></li><li><ul class="section"><li><a href="objects/class.html"><strong>7.1.</strong> Klaso</a></li><li><a href="objects/mutability.html"><strong>7.2.</strong> Ŝanĝebleco</a></li><li><a href="objects/methods.html"><strong>7.3.</strong> Metodoj</a></li><li><a href="objects/inheritance.html" class="active"><strong>7.4.</strong> Heredeco</a></li><li><a href="objects/traits.html"><strong>7.5.</strong> Trajto</a></li><li><a href="objects/cast.html"><strong>7.6.</strong> Tipŝanĝo, kaj dinamikaj tipoj</a></li></ul></li><li><a href="functions/README.html"><strong>8.</strong> Funkcioj pli kompleksaj</a></li><li><a href="pattern/README.html"><strong>9.</strong> Skema kongruo</a></li><li><a href="errors/main.html"><strong>10.</strong> Traktado de Eraroj</a></li><li><ul class="section"><li><a href="errors/scope_guards.html"><strong>10.1.</strong> Regionaj gardantoj</a></li><li><a href="errors/catching.html"><strong>10.2.</strong> Kapti erarojn</a></li><li><a href="errors/option.html"><strong>10.3.</strong> Esceptoj kaj opcia tipo</a></li><li><a href="errors/fptr_closure.html"><strong>10.4.</strong> Montrilo de Malsekuraj Funkcioj</a></li></ul></li><li><a href="templates/README.html"><strong>11.</strong> Ŝablonoj</a></li><li><ul class="section"><li><a href="templates/special.html"><strong>11.1.</strong> Ŝablonaj tipoj</a></li><li><a href="templates/cte.html"><strong>11.2.</strong> Ŝablonaj valoroj</a></li><li><a href="templates/values.html"><strong>11.3.</strong> Plenumo dum kompilado</a></li></ul></li><li><a href="objects/common_traits.html"><strong>12.</strong> Ordinaraj trajtoj</a></li><li><ul class="section"><li><a href="traits/streamable.html"><strong>12.1.</strong> &quot;Streamable&quot;</a></li><li><a href="traits/copiable.html"><strong>12.2.</strong> &quot;Copiable&quot;</a></li><li><a href="traits/disposable.html"><strong>12.3.</strong> &quot;With&quot; gardanto kaj &quot;Disposable&quot;</a></li><li><a href="traits/hashable.html"><strong>12.4.</strong> &quot;Hashable&quot;</a></li><li><a href="traits/serialize.html"><strong>12.5.</strong> &quot;Packable&quot; kaj &quot;Serializable&quot;</a></li></ul></li><li><a href="templates/operators.html"><strong>13.</strong> Transŝargo de Operacisimboloj</a></li><li><ul class="section"><li><a href="templates/binary.html"><strong>13.1.</strong> Unuopaj, duopaj kaj komparaj operacioj</a></li><li><a href="templates/complex_operators.html"><strong>13.2.</strong> Aliraj, Enhavaj kaj iteraciaj operacioj</a></li></ul></li><li><a href="version/README.html"><strong>14.</strong> Versioj</a></li><li><a href="macros/README.html"><strong>15.</strong> Makrooj</a></li><li><ul class="section"><li><a href="macros/std.html"><strong>15.1.</strong> Normaj kaj kernaj makrooj</a></li></ul></li><li><a href="documentation/README.html"><strong>16.</strong> Dokumentaro</a></li><li><ul class="section"><li><a href="documentation/types.html"><strong>16.1.</strong> Tipoj</a></li><li><a href="documentation/symbols.html"><strong>16.2.</strong> Simboloj</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Ymir Tour</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="objects/inheritance.html#inheritance" id="inheritance"><h1>Inheritance</h1></a>
<p>One of the most important point of the object oriented programming
paradigm is the possibility for a class to be derived from a base
class. This capability enables type polymorphism. In <em>Ymir</em> the
keyword <code>over</code> is used for class derivation, and overriding. A class
can have only one ancestor. We will see in the chapter about traits,
that multiple inheritance can be in some way achieved in another way.</p>
<pre><code class="language-ymir">class Shape {
}

/**
 * A circle is a shape
 */
class Circle over Shape {
    let _center : i32 = 0;
    let _radius : i32 = 1;
}
</code></pre>
<a class="header" href="objects/inheritance.html#fields" id="fields"><h2>Fields</h2></a>
<p>The fields of an ancestor cannot be redeclared by an heir class. Even
if they are hidden to the heir class (private fields). This choice was
made to avoid miscomprehension, as two different variables would be
named the same way.</p>
<pre><code class="language-ymir">import std::io;
        
class Shape {
    let _x : i32 = 0;
    
    pub self () {}
}

class Circle over Shape {
    let _x : i32;
    
    pub self () {
        println (self._x);
    }	
}
</code></pre>
<p><br></p>
<p>Error:</p>
<pre><code class="language-error">Error : when validating main::Circle
 --&gt; main.yr:(9,7)
 9  ┃ class Circle over Shape {
    ╋       ^^^^^^
    ┃ Error : declaration of _x shadows another declaration
    ┃  --&gt; main.yr:(4,13)
    ┃  4  ┃     prv let _x : i32 = 0;
    ┃     ╋             ^^
    ┃     ┃ Note : 
    ┃     ┃  --&gt; main.yr:(10,9)
    ┃     ┃ 10  ┃     let _x : i32;
    ┃     ┃     ╋         ^^
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="objects/inheritance.html#parent-class-construction" id="parent-class-construction"><h2>Parent class construction</h2></a>
<p>All object instances must be constructed. This means that when a class
override a base class, the constructor of the base class must be
called inside the constructor of the heir class. This call can be made
implicitly if the constructor of the parent class takes no
arguments. However, if no constructor in the parent class takes no
arguments, then the call must be made explicitly. This explicit call
is made inside the with statement.</p>
<pre><code class="language-ymir">class Shape {	
    let _x = 0;
    pub self () {}
    
    pub self (x : i32) with _x = x {}
}

class Circle over Shape {
    let _radius : f32;
    
    // Same as : with super ()
    pub self () with _radius = 1.0f {} 
    
    // call the second parent constructor, at line 5
    pub self (x : i32) with super (x), _radius = 1.0f {} 
}
</code></pre>
<p><br></p>
<p>The call of the parent constructor is the first thing performed inside
a constructor. Meaning, that the construction of the fields of the
heir class are made afterward. To illustrate this point, the following
example presents a base class <strong><code>Foo</code></strong> with a constructor printing
<strong><code>foo</code></strong>, and a heir class <strong><code>Bar</code></strong>, calling the function <strong><code>bar</code></strong>*
(printing the value <strong><code>bar</code></strong>) to initialize its field <strong><code>_x</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

def bar () -&gt; i32 {
    println( &quot;Bar&quot;);
    42
}

class Foo {    
    pub self () {
        println (&quot;Foo&quot;);
    }
}

class Bar over Foo {
    let _x : i32;

    pub self () with _x = bar () {}
}

def main () {
    let _ = Bar::new ();
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Foo
Bar
</code></pre>
<p><br></p>
<p>However, because constructor redirection does not call parent
constructor, and let that work to the called constructor, to which
they are redirected, the following program has a different
behavior. The arguments of the redirection are computed first, then
the call to the parent constructor, and finally the construction of
the fields of the heir class.</p>
<pre><code class="language-ymir">import std::io;

def bar () -&gt; i32 {
    println( &quot;Bar&quot;);
    29
}

def baz () -&gt; i32 {
    println( &quot;Baz&quot;);
    13
}

class Foo {
    pub self () {
        println (&quot;Foo&quot;);
    }
}

class Bar over Foo {
    let _x : i32;

    /**
     * Call parent constructor at line 14, and then bar
     */
    pub self (x : i32) with _x = bar () + x {}

    /**
     * Call baz first, then self at line 25
     */
    pub self () with self (baz ()) {} 
}

def main () {
    let _ = Bar::new ();
}
</code></pre>
<p><br>
Results:</p>
<pre><code class="language-ymir">Baz
Foo
Bar
</code></pre>
<p><br> The construction order is perfectly predictible, but should not
have an impact on the program behavior. So it is probably not a good
idea to rely on it.</p>
<a class="header" href="objects/inheritance.html#parent-class-destruction" id="parent-class-destruction"><h2>Parent class destruction</h2></a>
<p>In contrast to construction, the parent destructor is the last
operation of the destruction of a heir class. The parent destructor is
always called, there is no way to avoid it (aside exiting the
program).</p>
<pre><code class="language-ymir">import std::io;

class Foo {    
    pub self () {}
    __dtor (mut self) {
        println (&quot;Destroying Foo&quot;);
        println (&quot;====&quot;);
    }
}

class Bar over Foo {
    pub self () {}

    __dtor (mut self) {
        println (&quot;====&quot;);
        println (&quot;Destroying Bar&quot;);
        return {} // desperately trying to avoid parent destruction
    }
}

def foo () {
    let _ = Bar::new ();
}

def main () {
    loop {
        foo ();
    }
}
</code></pre>
<p><br>
Results:</p>
<pre><code>====
Destroying Bar
Destroying Foo
====
====
Destroying Bar
Destroying Foo
====
====
Destroying Bar
Destroying Foo
====
...
</code></pre>
<a class="header" href="objects/inheritance.html#method-overriding" id="method-overriding"><h2>Method overriding</h2></a>
<p>The keyword <code>over</code> is used to override a method. Methods <strong>cannot</strong> be
implicitly overriden by omitting the <code>over</code> keyword and using the
<code>def</code> keyword. The signature of the method must be strictly identical
to the one of the ancestor method, including privacy, and argument
mutability. Of course, private methods cannot be overriden, because
hidden to heir classes, but protected and public methods can be
overriden. In the following example, a class <strong><code>Shape</code></strong> define the
method <strong><code>area</code></strong>. This method is public, and then can be overriden
by heir classes. The class <strong><code>Circle</code></strong> and <strong><code>Rectangle</code></strong> overrides
the methods.</p>
<pre><code class="language-ymir">import std::io
    
class Shape {
    pub self () {}
    
    pub def area (self) -&gt; f64 
    0.0
}

class Circle over Shape {
    let _radius : f64;
    pub self (radius : f64) with _radius = radius {}
    
    pub over area (self) -&gt; f64 {
        import std::math;
        math::PI * (self._radius * self._radius)
    }
}

class Square over Shape {
    let _side : f64;
    pub self (side : f64) with _side = side {}
    
    pub over area (self) -&gt; f64 {
        self._side * self._side
    }
    
}

def main () {
    let mut s : &amp;Shape = Circle::new (12.0);
    println (s.area ());
    
    s = Square::new (3.0);
    println (s.area ());	
}
</code></pre>
<p><br>
Results:</p>
<pre><code>452.389342
9.000000
</code></pre>
<a class="header" href="objects/inheritance.html#override-mutable-method" id="override-mutable-method"><h3>Override mutable method</h3></a>
<p>The mutability of the method must be respected in the heir class. This
means that mutable method must be mutable in the heir, and immutable
methods must be immutable in the heir.</p>
<pre><code class="language-ymir">class Foo {
    pub self () {}
    
    pub def foo (mut self)-&gt; void {}
    
    pub def bar (self)-&gt; void {}
}

class Bar over Foo {
    pub self () {}
    
    pub over foo (self)-&gt; void {}
    
    pub over bar (mut self)-&gt; void {}
}
</code></pre>
<p><br>
Errors:</p>
<pre><code class="language-error">Error : when validating main::Bar
 --&gt; main.yr:(9,7)
 9  ┃ class Bar over Foo {
    ╋       ^^^
    ┃ Error : the method (const self) =&gt; main::Bar::foo ()-&gt; void marked as override does not override anything
    ┃  --&gt; main.yr:(12,11)
    ┃ 12  ┃ 	pub over foo (self)-&gt; void {}
    ┃     ╋ 	         ^^^
    ┃     ┃ Note : candidate foo --&gt; main.yr:(4,10) : (mut self) =&gt; main::Foo::foo ()-&gt; void
    ┃     ┗━━━━━━ 
    ┃ Error : the method (mut self) =&gt; main::Bar::bar ()-&gt; void marked as override does not override anything
    ┃  --&gt; main.yr:(14,11)
    ┃ 14  ┃ 	pub over bar (mut self)-&gt; void {}
    ┃     ╋ 	         ^^^
    ┃     ┃ Note : candidate bar --&gt; main.yr:(6,10) : (const self) =&gt; main::Foo::bar ()-&gt; void
    ┃     ┗━━━━━━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="objects/inheritance.html#final-methods" id="final-methods"><h3>Final methods</h3></a>
<p>A base class can flag its method to avoid overriding. This flag is
placed as a <em>custom modifier</em> before the name of the method.</p>
<pre><code class="language-ymir">class Foo {
    pub self () {}
    
    pub def @final foo (self) {}
}

class Bar over Foo {
    pub self () {}

    pub over foo (self) {}
}
</code></pre>
<p><br></p>
<p>Errors:</p>
<pre><code class="language-error">Error : when validating main::Bar
 --&gt; main.yr:(7,7)
 7  ┃ class Bar over Foo {
    ╋       ^^^
    ┃ Error : cannot override final method (const self) =&gt; main::Foo::foo ()-&gt; void
    ┃  --&gt; main.yr:(10,14)
    ┃ 10  ┃     pub over foo (self) {}
    ┃     ╋              ^^^
    ┃     ┃ Note : 
    ┃     ┃  --&gt; main.yr:(4,20)
    ┃     ┃  4  ┃     pub def @final foo (self) {}
    ┃     ┃     ╋                    ^^^
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>This flag can also be used on an overriden method inside a heir
class to avoid further overriding.</p>
<pre><code class="language-ymir">class Foo {
    pub self () {}
    
    pub def foo (self) {}
}

class Bar over Foo {
    pub self () {}

    pub over @final foo (self) {}
}

class Baz over Bar {
    pub self () {}

    pub over foo (self) {}
}
</code></pre>
<p><br>
Errors:</p>
<pre><code class="language-error">Error : when validating main::Baz
 --&gt; main.yr:(13,7)
13  ┃ class Baz over Bar {
    ╋       ^^^
    ┃ Error : cannot override final method (const self) =&gt; main::Bar::foo ()-&gt; void
    ┃  --&gt; main.yr:(16,14)
    ┃ 16  ┃     pub over foo (self) {}
    ┃     ╋              ^^^
    ┃     ┃ Note : 
    ┃     ┃  --&gt; main.yr:(10,21)
    ┃     ┃ 10  ┃     pub over @final foo (self) {}
    ┃     ┃     ╋                     ^^^
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="objects/inheritance.html#abstract-class" id="abstract-class"><h2>Abstract class</h2></a>
<p>A class can be abstract, this means that the class cannot be
instantiated even if it has a constructor. An abstract class can
declare methods without body, these methods must be overriden by heir
classes. An abstract must have a constructor to be heritable, this
constructor being called by the heir classes. Not that an abstract
class can have no public constructors, but that a class that have no
public constructors is not necessarily abstract.</p>
<pre><code class="language-ymir">class @abstract Shape {
    prot self () {} // need a constructor to be inheritable
    
    pub def area (self)-&gt; f64; // Method does not need a body
}

class Circle over Shape {
    let _radius : f64;
    pub self (radius : f64) with _radius = radius {}
    
    pub over area (self) -&gt; f64 {
        import std::math;
        math::PI * (self._radius * self._radius)
    }
}

def main () {
    let s : Shape = Circle::new (12);
    println (s.area ());
}
</code></pre>
<a class="header" href="objects/inheritance.html#method-with-no-body" id="method-with-no-body"><h3>Method with no body</h3></a>
<p>A method of an abstract class can have a body, and thus behave as any
method of any class. It can also have no body, but in that case heir
class must override this method. Otherwise the class is
incomplete. Abstract class can be heir class, in that case they don't
need to override the methods without body.</p>
<pre><code class="language-ymir">class @abstract Foo {
    pub self () {}
    
    pub def foo (self);
}

class @abstract Bar over Foo {
    pub self () {}
}

class Baz over Bar {
    pub self () {}
}
</code></pre>
<p><br>
Error:</p>
<pre><code class="language-error">Error : when validating main::Baz
 --&gt; main.yr:(11,7)
11  ┃ class Baz over Bar {
    ╋       ^^^
    ┃ Error : the class main::Baz is not abstract, but does not override the empty parent method (const self) =&gt; main::Foo::foo ()-&gt; void
    ┃  --&gt; main.yr:(11,7)
    ┃ 11  ┃ class Baz over Bar {
    ┃     ╋       ^^^
    ┃     ┃ Note : 
    ┃     ┃  --&gt; main.yr:(4,13)
    ┃     ┃  4  ┃     pub def foo (self);
    ┃     ┃     ╋             ^^^
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="objects/inheritance.html#final-class" id="final-class"><h2>Final class</h2></a>
<p>Final classes declared with the custom attributes <code>@final</code> defines
classes that cannot have heirs. A final class, can be an heir class,
or a base class. If the class is a base class, strong optimization can
be made by the compiler, (no vtable required, and call of the methods
are direct and way faster). For that reason, it is a good practice to
flag classes for which we are certain they cannot be inheritable. This
optimization is also done on final methods (if they are not overriden,
i.e. final when define for the first time), thus this is a good
practice to flag methods for which we are certain they won't be
overriden. This optimization cannot be done if the class is not a base
class.</p>
<pre><code class="language-ymir">class @final Foo {
    pub self () {}
    
    pub def foo (self) {}
}

class Bar over Foo {
    pub self () {}
}
</code></pre>
<p><br>
Error:</p>
<pre><code class="language-error">Error : the base class main::Foo is marked as final
 --&gt; main.yr:(7,16)
 7  ┃ class Bar over Foo {
    ╋                ^^^


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p><em>Contribution</em>: It is possible to have an abstract and final class. I
didn't find any use case for that, maybe that is completely useless,
and must be prohibited.</p>
<a class="header" href="objects/inheritance.html#casting-base-class-objects-to-heir-class" id="casting-base-class-objects-to-heir-class"><h2>Casting base class objects to heir class</h2></a>
<p>In many languages (such as C++, D, Java, or Scala) polymorphism gives
the possibility to cast an object of a base class into an object of an
heir class. This is not possible in <em>Ymir</em> because this behavior is
not safe. We will see in the chapter <a href="https://gnu-ymir.github.io/Documentations/en/pattern/">Pattern
matching</a> how
to achieve a cast of an object into a heir class, in a safe way.</p>
<p>However, the <em>std</em> provides a safe shortcut that can be used to
achieve the cast. This shortcut is by using the template function
<strong><code>to</code></strong> of the module <strong><code>std::conv</code></strong>. This function throws a
<strong><code>CastFailure</code></strong> exception when the cast failed, (safe in <em>Ymir</em>
means that the error can be managed, and has to be managed in fact, as
we will see in the chapter on <a href="https://gnu-ymir.github.io/Documentations/en/errors/main.html">Error
handling</a>). In
the following example, two objects are stored in the variable <strong><code>x</code></strong>
and <strong><code>y</code></strong>, whose type are <strong><code>&amp;Foo</code></strong>. The first cast at line <strong><code>18</code></strong>
works, because the variable <strong><code>x</code></strong> indeed contains an object of type
<strong><code>&amp;Bar</code></strong>, however the cast at line <strong><code>19</code></strong> does not work, the
variable <strong><code>y</code></strong> stores an object of type <strong><code>&amp;Foo</code></strong>.</p>
<pre><code class="language-ymir">import std::conv;

class Foo {
    pub self () {}
}

class Bar over Foo {
    pub self () {}
}


def main ()
    throws &amp;CastFailure // the possible errors are rethrown, so the program ends if there is an error 
{
    let x : &amp;Foo = Bar::new ();
    let y : &amp;Foo = Foo::new ();
    
    let _ : &amp;Bar = x.to!(&amp;Bar) (); // possibly throw a &amp;CastFailure
    let _ : &amp;Bar = y.to!(&amp;Bar) (); // here as well, (and actually throw it)
}
</code></pre>
<p><br></p>
<p>The following result happens because an error is thrown by the main
function, and then unmanaged by the program. The stacktrace is printed
because the program was compiled in debug mode. We can see in this
trace (at line <strong><code>11</code></strong>) that the error was effectively thrown by the
conversion at line <strong><code>19</code></strong>.</p>
<pre><code>Unhandled exception
Exception in file &quot;/home/emile/gcc/gcc-install/bin/../lib/gcc/x86_64-pc-linux-gnu/9.3.0/include/ymir/std/conv.yr&quot;, at line 820, in function &quot;std::conv::to(&amp;(main::Bar),&amp;(main::Foo))::to&quot;, of type std::conv::CastFailure.
╭  Stack trace :
╞═ bt ╕ #1
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #2
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #3 in function std::conv::toNP94main3BarNP94main3Foo::to (...)
│     ╘═&gt; /home/emile/gcc/gcc-install/bin/../lib/gcc/x86_64-pc-linux-gnu/9.3.0/include/ymir/std/conv.yr:820
╞═ bt ╕ #4 in function main (...)
│     ╘═&gt; /home/emile/Documents/test/ymir/main.yr:19
╞═ bt ╕ #5
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #6 in function main
│     ╘═&gt; /home/emile/Documents/test/ymir/main.yr:12
╞═ bt ╕ #7
│     ╘═&gt; /lib/x86_64-linux-gnu/libc.so.6:??
╞═ bt ═ #8 in function _start
╰
Aborted (core dumped)
</code></pre>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="objects/methods.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="objects/traits.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="objects/methods.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="objects/traits.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        
        <script type="text/javascript" src="custom.js"></script>
        

    </body>
</html>
