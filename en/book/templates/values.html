<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Compilation time execution - Ymir Tour</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        
        <link rel="stylesheet" href="custom.css">
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> Introduction</a></li><li><a href="hello-world/README.html"><strong>2.</strong> Hello World</a></li><li><ul class="section"><li><a href="hello-world/commentaires.html"><strong>2.1.</strong> Comments</a></li></ul></li><li><a href="primitives/README.html"><strong>3.</strong> Basic programming concepts</a></li><li><ul class="section"><li><a href="primitives/variables.html"><strong>3.1.</strong> Variable and Mutability</a></li><li><a href="primitives/types.html"><strong>3.2.</strong> Data types</a></li><li><a href="primitives/functions.html"><strong>3.3.</strong> Functions</a></li><li><a href="primitives/control.html"><strong>3.4.</strong> Control flows</a></li><li><a href="primitives/operator.html"><strong>3.5.</strong> Operator priority</a></li></ul></li><li><a href="advanced/README.html"><strong>4.</strong> Alias, References and Purity</a></li><li><ul class="section"><li><a href="advanced/references.html"><strong>4.1.</strong> References</a></li><li><a href="advanced/alias.html"><strong>4.2.</strong> Aliases</a></li><li><a href="advanced/copies.html"><strong>4.3.</strong> Copy and Deep copy</a></li><li><a href="advanced/best.html"><strong>4.4.</strong> Best practice</a></li><li><a href="advanced/pure.html"><strong>4.5.</strong> Pure values</a></li></ul></li><li><a href="modules/README.html"><strong>5.</strong> Modules</a></li><li><a href="types/README.html"><strong>6.</strong> User defined types</a></li><li><ul class="section"><li><a href="types/struct.html"><strong>6.1.</strong> Structure</a></li><li><a href="types/enum.html"><strong>6.2.</strong> Enum</a></li><li><a href="types/aka.html"><strong>6.3.</strong> Aka</a></li></ul></li><li><a href="objects/README.html"><strong>7.</strong> Objects</a></li><li><ul class="section"><li><a href="objects/class.html"><strong>7.1.</strong> Class</a></li><li><a href="objects/mutability.html"><strong>7.2.</strong> Mutability</a></li><li><a href="objects/methods.html"><strong>7.3.</strong> Methods</a></li><li><a href="objects/inheritance.html"><strong>7.4.</strong> Inheritance</a></li><li><a href="objects/traits.html"><strong>7.5.</strong> Traits</a></li><li><a href="objects/cast.html"><strong>7.6.</strong> Cast, and dynamic typing</a></li></ul></li><li><a href="functions/README.html"><strong>8.</strong> Function advanced</a></li><li><a href="pattern/README.html"><strong>9.</strong> Pattern matching</a></li><li><a href="errors/main.html"><strong>10.</strong> Error handling</a></li><li><ul class="section"><li><a href="errors/scope_guards.html"><strong>10.1.</strong> Scope guards</a></li><li><a href="errors/catching.html"><strong>10.2.</strong> Catching</a></li><li><a href="errors/option.html"><strong>10.3.</strong> Exception and option type</a></li><li><a href="errors/fptr_closure.html"><strong>10.4.</strong> Unsafe function pointer</a></li></ul></li><li><a href="templates/README.html"><strong>11.</strong> Templates</a></li><li><ul class="section"><li><a href="templates/special.html"><strong>11.1.</strong> Template types</a></li><li><a href="templates/cte.html"><strong>11.2.</strong> Template values</a></li><li><a href="templates/values.html" class="active"><strong>11.3.</strong> Compilation time execution</a></li></ul></li><li><a href="objects/common_traits.html"><strong>12.</strong> Common traits</a></li><li><ul class="section"><li><a href="traits/streamable.html"><strong>12.1.</strong> Streamable</a></li><li><a href="traits/copiable.html"><strong>12.2.</strong> Copiable</a></li><li><a href="traits/disposable.html"><strong>12.3.</strong> With guard and Disposable</a></li><li><a href="traits/hashable.html"><strong>12.4.</strong> Hashable</a></li><li><a href="traits/serialize.html"><strong>12.5.</strong> Packable and Serializable</a></li></ul></li><li><a href="templates/operators.html"><strong>13.</strong> Operator overloading</a></li><li><ul class="section"><li><a href="templates/binary.html"><strong>13.1.</strong> Unary, binary and Comparison</a></li><li><a href="templates/complex_operators.html"><strong>13.2.</strong> Access, contains and iteration</a></li></ul></li><li><a href="version/README.html"><strong>14.</strong> Version</a></li><li><a href="macros/README.html"><strong>15.</strong> Macro</a></li><li><ul class="section"><li><a href="macros/std.html"><strong>15.1.</strong> Std and Core macros</a></li></ul></li><li><a href="documentation/README.html"><strong>16.</strong> Documentation</a></li><li><ul class="section"><li><a href="documentation/types.html"><strong>16.1.</strong> Types</a></li><li><a href="documentation/symbols.html"><strong>16.2.</strong> Symbols</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Ymir Tour</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="templates/values.html#template-values" id="template-values"><h1>Template values</h1></a>
<p>In the previous chapter, we saw that some values can be known at the
time of compilation. These values can be used for the compiler to
decide which part of the code should be compiled and which part should
not, using branching operations.</p>
<a class="header" href="templates/values.html#compile-time-condition" id="compile-time-condition"><h2>Compile time condition</h2></a>
<p>The keyword <strong><code>cte</code></strong> is used to inform the compiler that a value can
be known at compile time, and must be evaluated during the
compilation. It is not the default behavior of the compiler, as the
compilation would be extremely long, if every values had to be
checked. This keyword can be used on <em>if expression</em> to execute the
condition at compile time, and evaluate compile only a part of the
source code. In the following example, an <em>if expression</em> is used to
check if the template value that is passed to the <strong><code>foo</code></strong> function
was lower than <strong><code>10</code></strong>. Because it is the case only the scope of the
<em>if expression</em> is compiled (not the scope of the <em>else</em>), that is why
even if the scope of the <em>else</em> part has no sense in term of types,
the compiler does not return any error.</p>
<pre><code class="language-ymir">import std::io;

def foo {X : i32} () {
    cte if X &lt; 10 {
        println (&quot;X is &lt; 10 : &quot;, X);
    } else {
        println (X + &quot;foo&quot;);
    }
}

def main () {
    foo!{2} ();
}
</code></pre>
<p><br>
Results:</p>
<pre><code>X is &lt; 10 : 2
</code></pre>
<p><br> As normal <em>if expression</em>, <em>cte if expression</em> can be chained,
however the keyword <em>cte</em> must be repeated before each <em>if expression</em>
otherwise the compiler consideres that they are execution time <em>if
expression</em>.</p>
<pre><code class="language-ymir">import std::io;

def foo {X : i32} () {
    cte if X &lt; 10 {
        println (&quot;X is &lt; 10 : &quot;, X);
    } else cte if X &lt; 25 {
        println (&quot;X is &lt; 25 : &quot;, X);
    } else {
        println (&quot;X is &gt; 25 : &quot;, X);
    }
}

def main () {
    foo!{2} ();
    foo!{14} ();
    foo!{38} ();
}
</code></pre>
<p><br></p>
<pre><code>X is &lt; 10 : 2
X is &lt; 25 : 14
X is &gt; 25 : 38
</code></pre>
<a class="header" href="templates/values.html#is-expression" id="is-expression"><h2>Is expression</h2></a>
<p>The <em>is expression</em> (that must not be confused with the <em>is operator</em>
applicable only on pointers) is used to check template specialization,
and gives a <em>cte bool value</em>. The syntax of the <em>is expression</em> is
similar to the syntax of a template call, following by template
parameters, as presented in the following code block. The template
parameters are used to create a specialization from the template
arguments.</p>
<pre><code class="language-grammar">is_expression := 'is' '!' (single_arg | multiple_args) '{' (template_parameter (',' template_parameter)*)? '}'
</code></pre>
<p><br></p>
<p>In the following example, the <strong><code>foo</code></strong> function accepts any kind of
type as template parameter, and a <em>cte if expression</em> is used to apply
a different behavior depending on the type of <strong><code>X</code></strong>. The first test
at line <strong><code>1</code></strong> works if the <strong><code>X</code></strong> is a <strong><code>i32</code></strong>, the second at
line <strong><code>2</code></strong> works if <strong><code>X</code></strong> is a slice of anything.</p>
<pre><code class="language-ymir">import std::io;

def foo {X} () {
    cte if is!{X} {T of i32} {
        println (&quot;Is a i32&quot;);
    } else cte if is!{X} {T of [U], U} {
        println (&quot;Is a slice&quot;);
    } else cte if is!{X} {T of [U; N], U, N : usize} {
        println (&quot;Is a static array&quot;);
    } else {
        println (&quot;I don't know ...&quot;);
    }
}

def main () {
    foo!i32 ();
    foo![i32] ();
    foo![i32 ; 4us] ();
    foo!f32 ();
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Is a i32
Is a slice
Is a static array
I don't know ...
</code></pre>
<p><br></p>
<p><strong>Warning</strong> An is expression is not a complete template
specialization, it is not attached to any code block. Thus the
variable declared inside the expression are not accessible from
anywhere. It is a volontary limitation, if the variable are to be used
a declaration such as a function, must be made.</p>
<a class="header" href="templates/values.html#cte-assert" id="cte-assert"><h2>Cte assert</h2></a>
<p>The keyword <strong><code>cte</code></strong> can be used on an <strong><code>assert</code></strong> expression. In
that case the condition of the assertion must be known at compilation
time. If the value of the condition is false, then an error is thrown
by the compiler, with the associated message. In the following
example, the assert test wether the template class <strong><code>T</code></strong> implements
the traits <strong><code>Hashable</code></strong>, and throws an explicit error message.</p>
<pre><code class="language-ymir">trait Useless {}

class X {class T} {
    cte assert (is!T {U impl Useless}, T::typeid ~ &quot; does not implement Useless&quot;);
    
    pub self () {}	
}

class B {}

def main () {
    let _ = X!{&amp;B}::new ();
}
</code></pre>
<p><br>
Errors:</p>
<pre><code class="language-error">Note : 
 --&gt; main.yr:(12,14)
12  ┃     let _ = X!{&amp;B}::new ();
    ╋              ^
    ┃ Error : undefined template operator for X and {&amp;(main::B)}
    ┃  --&gt; main.yr:(12,14)
    ┃ 12  ┃     let _ = X!{&amp;B}::new ();
    ┃     ╋              ^
    ┃     ┃ Note : in template specialization
    ┃     ┃  --&gt; main.yr:(12,14)
    ┃     ┃ 12  ┃     let _ = X!{&amp;B}::new ();
    ┃     ┃     ╋              ^
    ┃     ┃ Note : X --&gt; main.yr:(3,7) -&gt; X
    ┃     ┃ Error : assertion failed : main::B does not implement Useless
    ┃     ┃  --&gt; main.yr:(4,9)
    ┃     ┃  4  ┃     cte assert (is!T {U impl Useless}, T::typeid ~ &quot; does not implement Useless&quot;);
    ┃     ┃     ╋         ^^^^^^
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="templates/values.html#condition-on-template-definition" id="condition-on-template-definition"><h2>Condition on template definition</h2></a>
<p>Every template symbol can have a complex condition that is executed at
compilation time. This condition is executed when all the template
parameter have been infered, and can be used to add further test on
the template parameters that cannot be done by the syntax provided by
<em>Ymir</em> (for example accept either a <strong><code>i32</code></strong> or a <strong><code>i64</code></strong>). The
test is defined using the <strong><code>if</code></strong> keyword followed by an expression,
the value of the expression must be known at compilation time. In this
expression the template parameters can be used. The <strong><code>if</code></strong> keyword
always followes the keyword that is used to declare the symbol
(<strong><code>def</code></strong> for function, <strong><code>class</code></strong> for classes, etc.), unlike the
template parameters that always follow the identifier of the symbol.</p>
<pre><code class="language-ymir">class if (is!T {U of i32}) A {T} {
    let value : T;

    pub self if (is!U {J of T}) {U} (v : U) with value = v {}
}

struct if (is!T {U of f64})
| x : T
-&gt; S {T};
 
enum if (is!T {U of f64})
| X = cast!T (12)
-&gt; F {T};

mod if (is!T {U of f64}) Inner {T} {
    pub def foo (a : T) {
        println (a);
    }
}

trait if (is!T {U of f64}) Z {T} {
    pub def foo (self, a : T)-&gt; T;
}

aka if (is!T {U of f64}) X {T} = cast!T (12);
</code></pre>
<p><br></p>
<p>In the following example, the function <strong><code>foo</code></strong> have a simple
template specialization, but only accepts <strong><code>i32</code></strong> or <strong><code>i64</code></strong>
types, thanks to the condition test. Because <strong><code>u64</code></strong> is not
accepted, the compiler throws an error due to line <strong><code>10</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

def if (is!{X}{T of i32} || is!{X}{T of i64}) foo {X} (x : X) {
    println (x);
}

def main () {
    foo (12);
    foo (12i64);
    foo (34u64);
}
</code></pre>
<p><br>
Errors:</p>
<pre><code class="language-error">Error : the call operator is not defined for foo {X}(x : X)-&gt; void and {u64}
 --&gt; main.yr:(10,6)
10  ┃ 	foo (34u64);
    ╋ 	    ^     ^
    ┃ Note : candidate foo --&gt; main.yr:(3,47) : foo {X}(x : X)-&gt; void
    ┃     ┃ Error : the test of the template failed with {X -&gt; u64} specialization
    ┃     ┃  --&gt; main.yr:(3,26)
    ┃     ┃  3  ┃ def if (is!{X}{T of i32} || is!{X}{T of i64}) foo {X} (x : X) {
    ┃     ┃     ╋                          ^^
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>Template symbol with condition have a the same score than template
with the same template specialization but without a condition. For
that reason, in the following example, the call of <strong><code>foo</code></strong> at line
<strong><code>12</code></strong> create an error by the compiler. To avoid this error, the
reverse test must be added to the function <strong><code>foo</code></strong> defined at line
<strong><code>7</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

def if (is!{X}{T of i32} || is!{X}{T of i64}) foo {X} (x : X) {
    println (&quot;First : &quot;, x);
}

def foo {X} (x : X) {
    println (&quot;Second : &quot;, x);
}

def main () {
    foo (12);
}
</code></pre>
<p><br>
Errors:</p>
<pre><code class="language-error">Error : {foo {X}(x : X)-&gt; void, foo {X}(x : X)-&gt; void} x 2 called with {i32} work with both
 --&gt; main.yr:(12,6)
12  ┃ 	foo (12);
    ╋ 	    ^
    ┃ Note : candidate foo --&gt; main.yr:(3,47) : main::foo(i32)::foo (x : i32)-&gt; void
    ┃ Note : candidate foo --&gt; main.yr:(7,5) : main::foo(i32)::foo (x : i32)-&gt; void
    ┗━━━━━━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="templates/values.html#common-tests" id="common-tests"><h2>Common tests</h2></a>
<p>The module <strong><code>std::traits</code></strong> of the standard library defines some
<em>cte</em> function that can be used to add more complex test of the type
in template condition.</p>
<table><thead><tr><th> Function </th><th> Result </th></tr></thead><tbody>
<tr><td> <strong><code>isFloating</code></strong> </td><td> true for <strong><code>f32</code></strong> and <strong><code>f64</code></strong> </td></tr>
<tr><td> <strong><code>isIntegral</code></strong> </td><td> true for any integral types (signed and unsigned) </td></tr>
<tr><td> <strong><code>isSigned</code></strong> </td><td> true for any integral types that are signed </td></tr>
<tr><td> <strong><code>isUnsigned</code></strong> </td><td> true for any integral types that are unsigned </td></tr>
<tr><td> <strong><code>isChar</code></strong> </td><td> true for <strong><code>c8</code></strong> and <strong><code>c32</code></strong> </td></tr>
<tr><td> <strong><code>isTuple</code></strong> </td><td> true for any tuple type </td></tr>
</tbody></table>
<pre><code class="language-ymir">import std::io, std::traits;

def if (isIntegral!{T} ()) foo {T} () {
    println (&quot;Accept any integral type&quot;);
}

def if (isFloating!{T} ()) foo {T} () {
    println (&quot;Accept any floating type&quot;);
}

def main () {
    foo!i32 ();
    foo!u64 ();
    foo!f32 ();
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Accept any integral type
Accept any integral type
Accept any floating type
</code></pre>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="templates/cte.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="objects/common_traits.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="templates/cte.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="objects/common_traits.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        
        <script type="text/javascript" src="custom.js"></script>
        

    </body>
</html>
