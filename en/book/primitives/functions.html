<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Functions - Ymir Tour</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        
        <link rel="stylesheet" href="custom.css">
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> Introduction</a></li><li><a href="hello-world/README.html"><strong>2.</strong> Hello World</a></li><li><ul class="section"><li><a href="hello-world/commentaires.html"><strong>2.1.</strong> Comments</a></li></ul></li><li><a href="primitives/README.html"><strong>3.</strong> Basic programming concepts</a></li><li><ul class="section"><li><a href="primitives/variables.html"><strong>3.1.</strong> Variable and Mutability</a></li><li><a href="primitives/types.html"><strong>3.2.</strong> Data types</a></li><li><a href="primitives/functions.html" class="active"><strong>3.3.</strong> Functions</a></li><li><a href="primitives/control.html"><strong>3.4.</strong> Control flows</a></li><li><a href="primitives/operator.html"><strong>3.5.</strong> Operator priority</a></li></ul></li><li><a href="advanced/README.html"><strong>4.</strong> Alias, References and Purity</a></li><li><ul class="section"><li><a href="advanced/references.html"><strong>4.1.</strong> References</a></li><li><a href="advanced/alias.html"><strong>4.2.</strong> Aliases</a></li><li><a href="advanced/copies.html"><strong>4.3.</strong> Copy and Deep copy</a></li><li><a href="advanced/best.html"><strong>4.4.</strong> Best practice</a></li><li><a href="advanced/pure.html"><strong>4.5.</strong> Pure values</a></li></ul></li><li><a href="modules/README.html"><strong>5.</strong> Modules</a></li><li><a href="types/README.html"><strong>6.</strong> User defined types</a></li><li><ul class="section"><li><a href="types/struct.html"><strong>6.1.</strong> Structure</a></li><li><a href="types/enum.html"><strong>6.2.</strong> Enum</a></li><li><a href="types/aka.html"><strong>6.3.</strong> Aka</a></li></ul></li><li><a href="objects/README.html"><strong>7.</strong> Objects</a></li><li><ul class="section"><li><a href="objects/class.html"><strong>7.1.</strong> Class</a></li><li><a href="objects/mutability.html"><strong>7.2.</strong> Mutability</a></li><li><a href="objects/methods.html"><strong>7.3.</strong> Methods</a></li><li><a href="objects/inheritance.html"><strong>7.4.</strong> Inheritance</a></li><li><a href="objects/traits.html"><strong>7.5.</strong> Traits</a></li><li><a href="objects/cast.html"><strong>7.6.</strong> Cast, and dynamic typing</a></li></ul></li><li><a href="functions/README.html"><strong>8.</strong> Function advanced</a></li><li><a href="pattern/README.html"><strong>9.</strong> Pattern matching</a></li><li><a href="errors/main.html"><strong>10.</strong> Error handling</a></li><li><ul class="section"><li><a href="errors/scope_guards.html"><strong>10.1.</strong> Scope guards</a></li><li><a href="errors/catching.html"><strong>10.2.</strong> Catching</a></li><li><a href="errors/option.html"><strong>10.3.</strong> Exception and option type</a></li><li><a href="errors/fptr_closure.html"><strong>10.4.</strong> Unsafe function pointer</a></li></ul></li><li><a href="templates/README.html"><strong>11.</strong> Templates</a></li><li><ul class="section"><li><a href="templates/special.html"><strong>11.1.</strong> Template types</a></li><li><a href="templates/cte.html"><strong>11.2.</strong> Template values</a></li><li><a href="templates/values.html"><strong>11.3.</strong> Compilation time execution</a></li></ul></li><li><a href="objects/common_traits.html"><strong>12.</strong> Common traits</a></li><li><ul class="section"><li><a href="traits/streamable.html"><strong>12.1.</strong> Streamable</a></li><li><a href="traits/copiable.html"><strong>12.2.</strong> Copiable</a></li><li><a href="traits/disposable.html"><strong>12.3.</strong> With guard and Disposable</a></li><li><a href="traits/hashable.html"><strong>12.4.</strong> Hashable</a></li><li><a href="traits/serialize.html"><strong>12.5.</strong> Packable and Serializable</a></li></ul></li><li><a href="templates/operators.html"><strong>13.</strong> Operator overloading</a></li><li><ul class="section"><li><a href="templates/binary.html"><strong>13.1.</strong> Unary, binary and Comparison</a></li><li><a href="templates/complex_operators.html"><strong>13.2.</strong> Access, contains and iteration</a></li></ul></li><li><a href="version/README.html"><strong>14.</strong> Version</a></li><li><a href="macros/README.html"><strong>15.</strong> Macro</a></li><li><ul class="section"><li><a href="macros/std.html"><strong>15.1.</strong> Std and Core macros</a></li></ul></li><li><a href="documentation/README.html"><strong>16.</strong> Documentation</a></li><li><ul class="section"><li><a href="documentation/types.html"><strong>16.1.</strong> Types</a></li><li><a href="documentation/symbols.html"><strong>16.2.</strong> Symbols</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Ymir Tour</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="primitives/functions.html#functions" id="functions"><h1>Functions</h1></a>
<p>Function is a widely accepted concept for dividing a program into
small parts. A <em>Ymir</em> program starts with the <strong><code>main</code></strong> function that
you have already seen in previous chapters. All functions are declared
using the keyword <strong><code>def</code></strong> followed by a identifier, and a list of
parameters. A function is called by using its identifier followed by a
list of parameters separated by commas between parentheses.</p>
<pre><code class="language-ymir">import std::io 

/** 
 * The main function is the entry point of the program
 * It can have no parameters, and return an i32, or void
 */
def main () {
    foo ();
}


/** 
 * Declaration of a function named 'foo' with no parameters 
 */
def foo () {
    println (&quot;Foo&quot;);
        
    bar (); 
}


/**
 * Declaration of a function named 'bar' with one parameter 'x' of type 'i32'
*/
def bar (x : i32) {
    println (&quot;Bar &quot;, x);
}
</code></pre>
<p><br></p>
<p>The grammar of a function is defined in the following code block.</p>
<pre><code class="language-grammar">function := template_function | simple_function
simple_function := 'def' identifier parameters ('-&gt;' type)? expression
template_function := 'def' ('if' expression) identifier templates parameters ('-&gt;' type)? expression

parameters := '(' (var_decl (',' var_decl)*)? ')'
var_decl := identifier ':' type ('=' expression)?

identifier := ('_')* [A-z] ([A-z0-9_])*
</code></pre>
<p><br></p>
<p>The order of declaration of the symbol has no impact on the
compilation. The symbols are defined by the compiler before being
validated, thus contrary to C-like languages, even if the <code>foo</code>
function is defined after the <code>main</code> function (in the first example of
this chapter), it's symbol is accessible, and hence callable by the
<code>main</code> function. Further information about symbol declarations, and
accesses are presented in chapter
<a href="https://gnu-ymir.github.io/Documentations/en/modules/">Modules</a>.</p>
<a class="header" href="primitives/functions.html#parameters" id="parameters"><h2>Parameters</h2></a>
<p>The parameters of a function are declared after its identifier between
parentheses. The syntax of declaration of a parameter is similar to
the syntax of declaration of a variable, except that the keyword
<strong><code>let</code></strong> is omitted. However, unlike variable declaration, a
parameter must have a type, and its value is optional.</p>
<pre><code class="language-ymir">import std::io 

/**
 * Declaration of a function 'foo' with one parameter 'x' of type 'i32'
 */
def foo (x : i32) {
    println (&quot;The value of x is : &quot;, x);
}

/**
 * Declaration of a function 'bar' with two parameters 'x' and 'y' whose respective types are 'i32' and 'i32'
 */
def bar (x : i32, y : i32) {
    println (&quot;The value of x + y : &quot;, x + y);
}

def main () {
    foo (5); // Call the function 'foo' with 'x' set to '5'
    bar (3, 4); // Call the function 'bar' with 'x' set to '3' and 'y' set to '4'
}
</code></pre>
<p><br></p>
<a class="header" href="primitives/functions.html#default-value" id="default-value"><h3>Default value</h3></a>
<p>A function parameter can have a value, that is used by default when
calling the function. Therefore it is optional to specify the value of
a function parameter that have a default value, when calling it. To
change the value of a parameter with a default value, the <em>named
expression</em> syntax is used. This expression, whose grammar is
presented in the following code block, consists in naming a value.</p>
<pre><code>named_expression: Identifier '-&gt;' expression
</code></pre>
<p><br></p>
<p>The following source code presents an example of function with a
parameter with a default value, and the usage of a <em>named expression</em> to
call this function.</p>
<pre><code class="language-ymir">import std::io


/**
 * Function 'foo' can be called without specifying a value for parameter 'x'
 * '8' will be used as the default value for 'x'
 */
def foo (x : i32 = 8) {
    println (&quot;The value of x is : &quot;, x);
}

def main () {
    foo (); // call 'foo' with 'x' set to '8'
    foo (x-&gt; 7); // call 'foo' with 'x' set to '7'
}
</code></pre>
<p><br></p>
<p>The <em>named expression</em> can also be used for parameters without any
default value. Thanks to that <em>named expression</em>, it is possible to
specify the parameter in any order.</p>
<pre><code class="language-ymir">import std::io


/**
 * Parameters with default values, does not need to be last parameters
 * This function can be called with only two parameters ('x' and 'z'), or using named expression syntax
 */
def foo (x : i32, y : i32 = 9, z : i32) {
    println (x, &quot; &quot;, y, &quot; &quot;, z);
}

def main () {
    // Call the 'foo' function with 'x' = 2, 'y' = 1 and 'z' = 8 
    foo (8, y-&gt; 1, x-&gt; 2);
    foo (1, 8); // call the function 'foo' with 'x' = 1 and y = '9' and z = '8'
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>2 1 8
1 9 8
</code></pre>
<p><br></p>
<p>Any complex expression can be used, for the default value of a
function parameter. The creation of an object, a call of a function, a
code block, etc. The only limitation is that, you cannot refer to the
other parameters of the function. Indeed, they are not considered
declared in the scope of the default value.</p>
<pre><code class="language-ymir">def foo (x : i32) -&gt; i32 { ... }
def bar (x : i32) -&gt; i32 { ... }

/**
 * Declaration of a 'baz' function, where 'b' = bar(1) + foo(2), as a default value
 */
def baz (a : i32, b : i32 = {bar (1) + foo (2)}) {
 // ...
}

def main () {
    baz (12);
}
</code></pre>
<p><br></p>
<p>The symbols used in the default value of a parameters must be
accessible in the context of the function declaration. In the last
example, that means that the function <code>baz</code> must know the function
<code>bar</code> and the function <code>foo</code>, however, there is no need for the
function that calls it (here the function <code>main</code>) to know these
symbols. Further explanation on symbol declarations and accesses are
presented in chapter
<a href="https://gnu-ymir.github.io/Documentations/en/modules/">Modules</a>.</p>
<a class="header" href="primitives/functions.html#recursive-default-value" id="recursive-default-value"><h3>Recursive default value</h3></a>
<p><br></p>
<p>Recursivity of default parameter is prohibited. To illustrate this
point, the following code example will not be accepted by the
compiler.</p>
<pre><code class="language-ymir">import std::io;

def foo (foo_a : i32 = bar ()) -&gt; i32 {
                    // ^^^ here there is a recursive call 
    foo_a
}

def bar (bar_a : i32 = foo ()) -&gt; i32 {
                    // ^^^ recursivity problem
                     
    println (&quot;Bar &quot;, bar_a);
    foo (foo_a-&gt; bar_a + 11) 
}

def main () {
    println (&quot;Main &quot;, bar ()); // no need to set bar_a
}
</code></pre>
<p>Errors:</p>
<pre><code class="language-error">Error : the call operator is not defined for main::bar and {}
 --&gt; main.yr:(3,28)
 3  ┃ def foo (foo_a : i32 = bar ()) -&gt; i32 {
    ╋                            ^^
    ┃ Note : candidate bar --&gt; main.yr:(8,5) : main::bar (bar_a : i32)-&gt; i32
    ┃ Note : 
    ┃  --&gt; main.yr:(3,10)
    ┃  3  ┃ def foo (foo_a : i32 = bar ()) -&gt; i32 {
    ┃     ╋          ^^^^^
    ┃ Note : 
    ┃  --&gt; main.yr:(8,24)
    ┃  8  ┃ def bar (bar_a : i32 = foo ()) -&gt; i32 {
    ┃     ╋                        ^^^
    ┃ Note : 
    ┃  --&gt; main.yr:(8,10)
    ┃  8  ┃ def bar (bar_a : i32 = foo ()) -&gt; i32 {
    ┃     ╋          ^^^^^
    ┃ Note : 
    ┃  --&gt; main.yr:(3,24)
    ┃  3  ┃ def foo (foo_a : i32 = bar ()) -&gt; i32 {
    ┃     ╋                        ^^^
    ┗━━━━━┻━
</code></pre>
<p><br></p>
<p>This recursivity problem can be easily resolved by setting a value to
the parameter <strong><code>bar_a</code></strong> when called in the default value of
<strong><code>foo_a</code></strong>.</p>
<pre><code class="language-ymir">def foo (foo_a : i32 = bar (bar_a-&gt; 20)) -&gt; i32 {
                    //      ^^^^^ resolve the recursive problem 
    foo_a
}

// no need to do the same in bar, the recursivity does not exists anymore
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>Bar 20
Bar 31
Main 42
</code></pre>
<a class="header" href="primitives/functions.html#main-function-parameters" id="main-function-parameters"><h3>Main function parameters</h3></a>
<p>The <strong><code>main</code></strong> function can have a parameter. This parameter is of
type <strong><code>[[c8]]</code></strong>, and is the list of arguments passed to the program
in the command line when called.</p>
<pre><code class="language-ymir">import std::io;

def main (args : [[c8]]) {
    println (args);
}
</code></pre>
<p>Results:</p>
<pre><code class="language-bash">$ ./a.out foo bar 1
[./a.out, foo, bar, 1]
</code></pre>
<p>The std provides an argument parser in <strong><code>std::args</code></strong>, that will not
be presented here, but worth mentioning.</p>
<a class="header" href="primitives/functions.html#function-body" id="function-body"><h2>Function body</h2></a>
<p>The body of a function is an expression. Every expression in <em>Ymir</em>
are typed, but that does not mean that every expression have a value,
as they can be typed as <code>void</code> expression. The expression (body of the
function) is evaluated when the function is entered, and its value is
used as the value of the function. A simple <strong><code>add</code></strong> function can be
written as follows:</p>
<pre><code class="language-ymir">def add (x : i32, y : i32)-&gt; i32 
    x + y
</code></pre>
<p><br></p>
<p>Or by using a more complex expression, such as scope, which is an
expression containing a list of expression. A scope is surrounded by
the curly brackets, and was presented in the section regarding
lifetime of local variables. The last expression in the list of
expression of a scope, is taken as the value of the scope.</p>
<pre><code class="language-ymir">
def add (x : i32, y : i32) -&gt; i32 { // start of a block
    x + y // last expression of the block is the value of the block
} // end of a block

def main () 
    throws &amp;AssertError
{
    let x = {
        let y = add (1, 2);
        y + 8 
    };
    assert (x == 11)
}
</code></pre>
<p><br></p>
<p>The semi-colon token <strong><code>;</code></strong> is a way of specifying that an expression
ends inside a scope, and that its value must be ignored. If the last
expression of a scope is terminated by a semi-colon, an empty
expression is added to the scope. This empty expression has no value,
giving to the scope an empty value of type <strong><code>void</code></strong> as well.</p>
<pre><code class="language-ymir">
/**
 * The value of foo is '9'
 */
def foo () -&gt; i32 
    9


def main () {
    let x = {
         foo (); // Call foo, but its value is ignored
    } // The value of the scope is 'void'
}
</code></pre>
<p><br></p>
<p>Because it is impossible to declare a variable with a void type, that
contains no value, the above example is no accepted by the
language. The compiler returns the error depicted below. One can note,
that it is however possible the declare a variable without value, but
its type must be an empty tuple, defined by the literal <strong><code>()</code></strong>.</p>
<pre><code class="language-error">Error : cannot declare var of type void
 --&gt; main.yr:(6,9)
    | 
 6  |     let x = {
    |         ^

ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="primitives/functions.html#function-return-type" id="function-return-type"><h2>Function return type</h2></a>
<p>When the value of the body of a function is not of type <strong><code>void</code></strong>,
the function has as well a value with a type. This type must be
defined in the prototype of the function, to be visible from the other
function that can call it. This type declaration is made with the
single arrow token <strong><code>-&gt;</code></strong> after the declarations of the parameter of
the function. The return type of a function can be omitted if the
value of its body is of type <strong><code>void</code></strong>, but must be specified
otherwise.</p>
<pre><code class="language-ymir">def foo (x : i32)-&gt; i32 
    x + 1
    
def bar (x : i32, y : i32) -&gt; i32 {
    let z = x + y;
    println (&quot;The value of z : &quot;, z);
    foo (z)
}
</code></pre>
<p><br></p>
<p>It is not always convenient to define a body of a function in a way
that leads to return the right value, when many branches are
possible. To avoid verbosity, and return function prematuraly, the
keyword <strong><code>return</code></strong>, close a function and return the value of the
expression associated with it. This <strong><code>return</code></strong> statement can also be
used in a <strong><code>void</code></strong> function, if its expression is of type
<strong><code>void</code></strong>. The type of the value of the expression associated to the
<em>return statement</em> must be the same as the function return type
defined in its prototype.</p>
<pre><code class="language-ymir">def isDivisable (x : i32, z : i32) -&gt; bool {
    if (z == 0) return false; 
    
    (x % z) == 0
}
</code></pre>
<p><br></p>
<p>The compiler checks that every branches leads to a return statement or
to a value of the right type. If a function body has a type different
to the return type of the function, and it can happen that no return
statement is encountered, then the compiler returns an error.</p>
<pre><code class="language-ymir">import std::io

def add_one (x : i32)-&gt; i32 {
    x + 1; // the value of the block is void, due to the ';'
}

def main () {
    let x = add_one (5); 
    println (&quot;The value of x : &quot;, x);
}
</code></pre>
<p><br></p>
<p>In the above source code, the function <em>add_one</em> has a body of type
<strong><code>void</code></strong>, when the function prototype claims that the function
returns a <strong><code>i32</code></strong>, and no return statement can be encountered inside
the function, thus the compiler returns the following error.</p>
<pre><code class="language-error">Error : incompatible types i32 and void
 --&gt; main.yr:(3,29)
 3  ┃ def add_one (x : i32)-&gt; i32 {
    ╋                             ^
    ┃ Note : 
    ┃  --&gt; main.yr:(5,1)
    ┃  5  ┃ }
    ┃     ╋ ^
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="primitives/functions.html#scope-declaration" id="scope-declaration"><h2>Scope declaration</h2></a>
<p>A scope is also the opening of a local module, in which declaration
can be made. These declarations can be other functions, structures,
classes, enumeration, etc. The declarations made inside a scope have
no access to the local variables defined in the function. Such access
is possible with the use of closures (<em>cf.</em> <a href="https://gnu-ymir.github.io/Documentations/en/functions">Function
advanced</a>),
but this is not be presented inside this chapter.</p>
<pre><code class="language-ymir">def foo () {
    import std::io;	 // imporation is local to foo
    let x = 12;
    {
    def bar () -&gt; i32 {
        println (x);
        12
    }
    println (x + bar ());
    }
    
    // bar is not accessible anymore
    bar (); // does not compile
}

def main () {
    foo ();
    
    bar ();
    println (&quot;In the main function !&quot;);
}
</code></pre>
<p><br></p>
<p>In the above example, the <strong><code>bar</code></strong> function is available in the scope
opened at line <strong>4</strong>, until its end at line <strong>10</strong>. For that reason,
it is also not available inside the <strong><code>main</code></strong> function. Moreover, the
<em>import statement</em> made at line <strong>2</strong> (importing the <strong><code>println</code></strong>
function) is only available in the scope opened at line <strong>1</strong>, and for
that reason not available in the <strong><code>main</code></strong> function. For these
reasons, the above example contains five errors, that are thrown by
the compiler.</p>
<pre><code class="language-error">Error : undefined symbol x
 --&gt; main.yr:(6,15)
 6  ┃ 	    println (x);
    ╋ 	             ^

Error : undefined symbol bar
 --&gt; main.yr:(9,15)
 9  ┃ 	println (x + bar ());
    ╋ 	             ^^^

Error : undefined symbol bar
 --&gt; main.yr:(13,5)
13  ┃     bar (); // does not compile
    ╋     ^^^

Error : undefined symbol bar
 --&gt; main.yr:(19,5)
19  ┃     bar ();
    ╋     ^^^

Error : undefined symbol println
 --&gt; main.yr:(20,5)
20  ┃     println (&quot;In the main function !&quot;);
    ╋     ^^^^^^^


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>Functions are not modules, this way of defining is used to define
private symbols only, in a future chapter we will see a way to define
public symbols available for other functions, and foreign modules
(<em>cf.</em>
<a href="https://gnu-ymir.github.io/Documentations/en/modules/">Modules</a>).</p>
<a class="header" href="primitives/functions.html#uniform-call-syntax" id="uniform-call-syntax"><h2>Uniform call syntax</h2></a>
<p>The <em>uniform call syntax</em> is a syntax that allows to call a function
with the dot operator <strong><code>.</code></strong>. The <em>uniform call syntax</em> places the
first parameter of the function at the left of the dot
operation, and the rest of the arguments of the function after the
right operand as a list of expressions separated by comas enclosed
inside parentheses.</p>
<pre><code class="language-grammar">ufc := expression '.' expression '(' (expression (',' expression)*)? ')'
</code></pre>
<p>This syntax is used to perform continuous data processing and to make
the source code easier to read. This syntax is named <em>uniform call
syntax</em> because it is similar to the the syntax used to call methods
on class objects
(<em>cf.</em> <a href="https://gnu-ymir.github.io/Documentations/en/objects/">Objects</a>).</p>
<pre><code class="language-ymir">import std::io

def plusOne (i : i32) -&gt; i32 
    i + 1

def plusTwo (i : i32) -&gt; i32
    i + 2
    
def main () {
    let x = 12;
    x.plusOne ()
     .plusTwo ()
     .println ();	 	 
}	
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>15
</code></pre>
<p><br></p>
<p>The <em>uniform call syntax</em> can also be useful to define equivalent of
methods on structures. Because structures are presented in a future
chapter, we do not present this possibility here.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="primitives/types.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="primitives/control.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="primitives/types.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="primitives/control.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        
        <script type="text/javascript" src="custom.js"></script>
        

    </body>
</html>
