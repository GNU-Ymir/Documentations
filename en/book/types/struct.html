<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Structure - Ymir Tour</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        
        <link rel="stylesheet" href="custom.css">
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> Introduction</a></li><li><a href="hello-world/README.html"><strong>2.</strong> Hello World</a></li><li><ul class="section"><li><a href="hello-world/commentaires.html"><strong>2.1.</strong> Comments</a></li></ul></li><li><a href="primitives/README.html"><strong>3.</strong> Basic programming concepts</a></li><li><ul class="section"><li><a href="primitives/variables.html"><strong>3.1.</strong> Variable and Mutability</a></li><li><a href="primitives/types.html"><strong>3.2.</strong> Data types</a></li><li><a href="primitives/functions.html"><strong>3.3.</strong> Functions</a></li><li><a href="primitives/control.html"><strong>3.4.</strong> Control flows</a></li><li><a href="primitives/operator.html"><strong>3.5.</strong> Operator priority</a></li></ul></li><li><a href="advanced/README.html"><strong>4.</strong> Alias, References and Purity</a></li><li><ul class="section"><li><a href="advanced/references.html"><strong>4.1.</strong> References</a></li><li><a href="advanced/alias.html"><strong>4.2.</strong> Aliases</a></li><li><a href="advanced/copies.html"><strong>4.3.</strong> Copy and Deep copy</a></li><li><a href="advanced/best.html"><strong>4.4.</strong> Best practice</a></li><li><a href="advanced/pure.html"><strong>4.5.</strong> Pure values</a></li></ul></li><li><a href="modules/README.html"><strong>5.</strong> Modules</a></li><li><a href="types/README.html"><strong>6.</strong> User defined types</a></li><li><ul class="section"><li><a href="types/struct.html" class="active"><strong>6.1.</strong> Structure</a></li><li><a href="types/enum.html"><strong>6.2.</strong> Enum</a></li><li><a href="types/aka.html"><strong>6.3.</strong> Aka</a></li></ul></li><li><a href="objects/README.html"><strong>7.</strong> Objects</a></li><li><ul class="section"><li><a href="objects/class.html"><strong>7.1.</strong> Class</a></li><li><a href="objects/mutability.html"><strong>7.2.</strong> Mutability</a></li><li><a href="objects/methods.html"><strong>7.3.</strong> Methods</a></li><li><a href="objects/inheritance.html"><strong>7.4.</strong> Inheritance</a></li><li><a href="objects/traits.html"><strong>7.5.</strong> Traits</a></li><li><a href="objects/cast.html"><strong>7.6.</strong> Cast, and dynamic typing</a></li></ul></li><li><a href="functions/README.html"><strong>8.</strong> Function advanced</a></li><li><a href="pattern/README.html"><strong>9.</strong> Pattern matching</a></li><li><a href="errors/main.html"><strong>10.</strong> Error handling</a></li><li><ul class="section"><li><a href="errors/scope_guards.html"><strong>10.1.</strong> Scope guards</a></li><li><a href="errors/catching.html"><strong>10.2.</strong> Catching</a></li><li><a href="errors/option.html"><strong>10.3.</strong> Exception and option type</a></li><li><a href="errors/fptr_closure.html"><strong>10.4.</strong> Unsafe function pointer</a></li></ul></li><li><a href="templates/README.html"><strong>11.</strong> Templates</a></li><li><ul class="section"><li><a href="templates/special.html"><strong>11.1.</strong> Template types</a></li><li><a href="templates/cte.html"><strong>11.2.</strong> Template values</a></li><li><a href="templates/values.html"><strong>11.3.</strong> Compilation time execution</a></li></ul></li><li><a href="objects/common_traits.html"><strong>12.</strong> Common traits</a></li><li><ul class="section"><li><a href="traits/streamable.html"><strong>12.1.</strong> Streamable</a></li><li><a href="traits/copiable.html"><strong>12.2.</strong> Copiable</a></li><li><a href="traits/disposable.html"><strong>12.3.</strong> With guard and Disposable</a></li><li><a href="traits/hashable.html"><strong>12.4.</strong> Hashable</a></li><li><a href="traits/serialize.html"><strong>12.5.</strong> Packable and Serializable</a></li></ul></li><li><a href="templates/operators.html"><strong>13.</strong> Operator overloading</a></li><li><ul class="section"><li><a href="templates/binary.html"><strong>13.1.</strong> Unary, binary and Comparison</a></li><li><a href="templates/complex_operators.html"><strong>13.2.</strong> Access, contains and iteration</a></li></ul></li><li><a href="version/README.html"><strong>14.</strong> Version</a></li><li><a href="macros/README.html"><strong>15.</strong> Macro</a></li><li><ul class="section"><li><a href="macros/std.html"><strong>15.1.</strong> Std and Core macros</a></li></ul></li><li><a href="documentation/README.html"><strong>16.</strong> Documentation</a></li><li><ul class="section"><li><a href="documentation/types.html"><strong>16.1.</strong> Types</a></li><li><a href="documentation/symbols.html"><strong>16.2.</strong> Symbols</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Ymir Tour</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="types/struct.html#structure" id="structure"><h1>Structure</h1></a>
<p>Structure is a common design used in many languages to define users'
custom types. They contains multiple values of different types,
accessible by identifiers. Structures are similar to tuples, in terms
of memory management (located in the stack). Unlike tuples, structures
are named, and all their internal fields are named as well.</p>
<p>The complete grammar of structure definition is presented in the
following code block. One can note the possibility to add templates to
the definition of the structure. These templates will only be
discussed in the chapter
<a href="https://gnu-ymir.github.io/Documentations/en/templates/">Templates</a>,
and are not of interest to us at the moment.</p>
<pre><code class="language-grammar">struct_type := 'struct' ('|' var_decl)* '-&gt;' identifier (templates)?
var_decl := ('mut'?) identifier ':' type ('=' expression)?
identifier := ('_')* [A-z] ([A-z0-9_])*	 
</code></pre>
<p><br></p>
<p>The fields of the structure are defined using the same syntax as the
declaration of function parameters, i.e. the same syntax as variable
declaration but with the keyword <strong><code>let</code></strong> omitted. The following
source code presents a definition of a structure <strong><code>Point</code></strong> with two
fields <strong><code>x</code></strong> and <strong><code>y</code></strong> of type <strong><code>i32</code></strong>. The two fields of this
structure are immutable, and have no default values.</p>
<pre><code class="language-ymir">import std::io

struct 
| x : i32
| y : i32 
 -&gt; Point;
 
def main () {
    let point = Point (1, 2); // initialize the value of the structure
    println (point); // structures are printable
} 
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>main::Point(1, 2)
</code></pre>
<p><br></p>
<p>It is possible to declare a structure with no fields. Note, however,
that such structure has a size of 1 byte in memory.</p>
<p><strong>Contribution</strong> this is a limitation observed in gcc, maybe
this can be corrected ?</p>
<pre><code class="language-ymir">import std::io;

struct -&gt; Unit;

def main () {
    let x = Unit ();
    println (x, &quot; of size &quot;, sizeof (x));
}
</code></pre>
<p>Results:</p>
<pre><code>main::Unit() of size 1
</code></pre>
<a class="header" href="types/struct.html#structure-construction" id="structure-construction"><h2>Structure construction</h2></a>
<p>The construction of a structure is made using the same syntax as a
function call, that is to say using its identifier and a list of
parameters inside parentheses and separated by comas. Like function
calls, structure can have default values assigneted to fields. The
value of these fields can be changed using the <em>named expression</em>
syntax, which is constructed with the arrow operator <code>-&gt;</code>. Field
without default value can also be constructed using the <em>named
expression</em> syntax. In that case, the order of field construction is
not important.</p>
<pre><code class="language-ymir">import std::io

struct 
| x : i32 = 0
| y : i32 
 -&gt; Point;
  
def main () {
    let point = Point (y-&gt; 12, x-&gt; 98);
    println (point);

    let point2 = Point (1);
    println (point2);
}
</code></pre>
<p>Results:</p>
<pre><code>main::Point(98, 12)
main::Point(0, 1)
</code></pre>
<p><br></p>
<a class="header" href="types/struct.html#field-access" id="field-access"><h2>Field access</h2></a>
<p>The fields of a structure are always public, and accessible using the
dot binary operator <strong><code>.</code></strong>, where the left operand is a value whose
type is a structure, and the right operand is the identifier of the
field.</p>
<pre><code class="language-ymir">import std::io

struct 
| x : i32
| y : i32 
 -&gt; Point;
 
def main ()
    throws &amp;AssertError
{
    let point = Point (1, 2); 
    assert (point.x == 1 &amp;&amp; point.y == 2);
}
</code></pre>
<a class="header" href="types/struct.html#structure-mutability" id="structure-mutability"><h2>Structure mutability</h2></a>
<p>The mutability of a field of a structure is defined in the structure
declaration. As with any variable declaration, the fields of a
structure are by default immutable. By adding the keyword <strong><code>mut</code></strong>
before the identifier of a field, the field becomes mutable. However,
the mutability is transitive in <em>Ymir</em>, meaning that a immutable value
of a struct type, cannot be modified even if its field are marked
mutable. Consequently, for a field to be really mutable, it must be
marked as such, and be a field of a mutable value.</p>
<pre><code class="language-ymir">import std::io

struct 
| x : i32
| mut y : i32
 -&gt; Point;
 
def main () {
    let mut p1 = Point (1, 2);
    p1.y = 98; // y is mutable
                  // and p1 is mutable no problem
    
    p1.x = 34; // x is not mutable, this won't compile
    
    let p2 = Point (1, 2);
    p2.y = 98; // p2 is not mutable, this won't compile	
}
</code></pre>
<p>Errors:</p>
<pre><code class="language-error">Error : left operand of type i32 is immutable
 --&gt; main.yr:(13,4)
13  ┃ 	p1.x = 34; // x is not mutable, this won't compile
    ╋ 	  ^

Error : left operand of type i32 is immutable
 --&gt; main.yr:(16,4)
16  ┃ 	p2.y = 98; // p2 is not mutable, this won't compile	
    ╋ 	  ^


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="types/struct.html#memory-borrowing-of-structure" id="memory-borrowing-of-structure"><h2>Memory borrowing of structure</h2></a>
<p>By default structure data are located in the value that contains them,
i.e. in the stack inside a variable, on the heap inside a slice,
etc. They are copied by value, at assignement or function call. This
copy is static, and does not require allocation, so it is allowed
implicitely.</p>
<pre><code class="language-ymir">import std::io

struct 
| mut x : i32
| mut y : i32
 -&gt; Point;

def main ()
    throws &amp;AssertError
{
    let p = Point (1, 2);
    let mut p2 = p; // make a copy of the structure
    p2.y = 12;

    assert (p.y == 2);
    assert (p2.y == 12);
}
</code></pre>
<p><br></p>
<p>Structure may contain aliasable values, such as slice. In that case,
the copy is no longer allowed implicitely (if the structure is
mutable, and the field containing the <em>aliasable</em> value is also
mutable, and the element that will borrow the data is also
mutable). To resolve the problem, the keywords <code>dcopy</code>, and <code>alias</code>
presented in <a href="https://gnu-ymir.github.io/Documentations/en/advanced/">Aliases and
References</a>
can be used.</p>
<pre><code class="language-ymir">import std::io

struct 
| mut y : [mut [mut i32]]
 -&gt; Point;

def main ()
    throws &amp;OutOfArray
{
    let mut a = Point ([[1, 23, 3], [4, 5, 6]]);
    let mut b = dcopy a;
    let mut c = alias a;
    
    b.y [0][0] = 9; // only change the value of 'b'
    c.y [0][1] = 2; // change the value of 'a' and 'c'
    
    println (a);
    println (b);
    println (c);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>main::Point([[1, 2, 3], [4, 5, 6]])
main::Point([[9, 23, 3], [4, 5, 6]])
main::Point([[1, 2, 3], [4, 5, 6]])
</code></pre>
<p><br></p>
<p>It is impossible to make a simple copy of a structure with the keyword
<strong><code>copy</code></strong>, the mutability level being set once and for all in the
structure definition. For example, if a structure <em>S</em> contains a field
whose type is <strong><code>mut [mut [i32]]</code></strong>, every value of type <em>S</em> have a
field of type <strong><code>mut [mut [i32]]</code></strong>. For that reason, by making a
first level <em>copy</em>, the mutability level would not be respected.</p>
<a class="header" href="types/struct.html#packed-and-union" id="packed-and-union"><h2>Packed and Union</h2></a>
<p>This part only concerns advanced programming paradigms, and is close
to the machine level. It is unlikely that you will ever need it,
unless you try to optimize your code at a binary level.</p>
<a class="header" href="types/struct.html#packed" id="packed"><h3>Packed</h3></a>
<p>The size of a structure is calculated by the compiler, which decides
the alignment of the different fields. This is why the size of a
structure containing an <code>i64</code> and a <code>c8</code> is <strong>16</strong> bytes, not <strong>9</strong>
bytes. There is no guarantee about the size or the order of the fields
in the generated program. To force the compiler to remove the
optimized alignment, the <em>special modifier</em> <strong><code>packed</code></strong> can be
used.</p>
<pre><code class="language-ymir">import std::io

struct @packed
| x : i64
| c : c8
 -&gt; Packed;
 
struct 
| x : i64
| c : c8
 -&gt; Unpacked;


def main () {
    println (&quot;Size of packed : &quot;, sizeof Packed);
    println (&quot;Size of unpacked : &quot;, sizeof Unpacked);
}
</code></pre>
<p>Results:</p>
<pre><code>Size of packed : 9
Size of unpacked : 16
</code></pre>
<a class="header" href="types/struct.html#union" id="union"><h3>Union</h3></a>
<p>The <strong><code>union</code></strong> <em>special modifier</em> , on the other hand, informs the
compiler that all fields in the structure must share the same memory
location. In the following example, the <strong><code>union</code></strong> <em>modifier</em> is used
on a structure containing two fields. The largest field of the
structure is the field <strong><code>y</code></strong> of type <strong><code>f64</code></strong>. The size of this
field is <strong>8</strong> bytes, thus the structure has a size of <strong>8</strong> bytes as
well. All the fields are aligned at the beginning of the strucures,
meaning that the field <strong><code>x</code></strong>, and <strong><code>y</code></strong> shares the same address in
memory.</p>
<pre><code class="language-ymir">struct @union 
| x : i32
| y : f64
 -&gt; Dummy;
</code></pre>
<p><br></p>
<p>The construction of a structure with <strong><code>union</code></strong> <em>modifier</em> requires
only one argument. This argument must be passed as a <em>named
expression</em> with the arrow operator <code>-&gt;</code>.</p>
<pre><code class="language-ymir">import std::io

struct @union
| x : i32
| y : f32
 -&gt; Dummy;

def main ()
    throws &amp;AssertError
{
    let x = Dummy (y-&gt; 12.0f);

    // Comparison of pointer is only possible on pointer of the same type
    // Any pointer can be casted into a pointer of &amp;void (the contrary is not possible)
    // is operator, checks if two pointer are equals
    assert (cast!(&amp;void) (&amp;(x.x)) is cast!(&amp;void) (&amp;(x.y)));

    // The value of x depends on the value of y
    assert (x.x == 1094713344);
    assert (x.y == 12.0f);
}
</code></pre>
<a class="header" href="types/struct.html#structure-specific-attributes" id="structure-specific-attributes"><h2>Structure specific attributes</h2></a>
<p>Structures have type specific attributes, as any types, accessible with
the double colon binary operator <strong><code>::</code></strong>. The table below presents
these specific attributes. These attributes are accessible using a
type of struct, and not a value. A example, under the table presents
usage of struct specific attributes.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>init</code> </td><td> The initial value of the type </td></tr>
<tr><td> <code>typeid</code> </td><td>  The name of the type stored in a value of type <strong><code>[c32]</code></strong> </td></tr>
<tr><td> <code>typeinfo</code> </td><td> A structure of type TypeInfo, containing information about the type </td></tr>
</tbody></table>
<p>All the information about TypeInfo are presented in chapter <a href="">Dynamic types</a>.</p>
<pre><code class="language-ymir">mod main;

import std::io;

struct
| x : i32
| y : i32 = 9
 -&gt; Point; 
 
def main ()
    throws &amp;AssertError
{
    let x = Point::init;
    
    // the structure is declared in the main module, thus its name is main::Point	
    assert (Point::typeid == &quot;main::Point&quot;);
    
    assert (x.x == i32::init &amp;&amp; x.y == 9);
}
</code></pre>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="types/README.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="types/enum.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="types/README.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="types/enum.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        
        <script type="text/javascript" src="custom.js"></script>
        

    </body>
</html>
