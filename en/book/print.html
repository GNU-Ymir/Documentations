<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Ymir Tour</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        
        <link rel="stylesheet" href="custom.css">
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> Introduction</a></li><li><a href="hello-world/README.html"><strong>2.</strong> Hello World</a></li><li><ul class="section"><li><a href="hello-world/commentaires.html"><strong>2.1.</strong> Comments</a></li></ul></li><li><a href="primitives/README.html"><strong>3.</strong> Basic programming concepts</a></li><li><ul class="section"><li><a href="primitives/variables.html"><strong>3.1.</strong> Variable and Mutability</a></li><li><a href="primitives/types.html"><strong>3.2.</strong> Data types</a></li><li><a href="primitives/functions.html"><strong>3.3.</strong> Functions</a></li><li><a href="primitives/control.html"><strong>3.4.</strong> Control flows</a></li><li><a href="primitives/operator.html"><strong>3.5.</strong> Operator priority</a></li></ul></li><li><a href="advanced/README.html"><strong>4.</strong> Alias, References and Purity</a></li><li><ul class="section"><li><a href="advanced/references.html"><strong>4.1.</strong> References</a></li><li><a href="advanced/alias.html"><strong>4.2.</strong> Aliases</a></li><li><a href="advanced/copies.html"><strong>4.3.</strong> Copy and Deep copy</a></li><li><a href="advanced/best.html"><strong>4.4.</strong> Best practice</a></li><li><a href="advanced/pure.html"><strong>4.5.</strong> Pure values</a></li></ul></li><li><a href="modules/README.html"><strong>5.</strong> Modules</a></li><li><a href="types/README.html"><strong>6.</strong> User defined types</a></li><li><ul class="section"><li><a href="types/struct.html"><strong>6.1.</strong> Structure</a></li><li><a href="types/enum.html"><strong>6.2.</strong> Enum</a></li><li><a href="types/aka.html"><strong>6.3.</strong> Aka</a></li></ul></li><li><a href="objects/README.html"><strong>7.</strong> Objects</a></li><li><ul class="section"><li><a href="objects/class.html"><strong>7.1.</strong> Class</a></li><li><a href="objects/mutability.html"><strong>7.2.</strong> Mutability</a></li><li><a href="objects/methods.html"><strong>7.3.</strong> Methods</a></li><li><a href="objects/inheritance.html"><strong>7.4.</strong> Inheritance</a></li><li><a href="objects/traits.html"><strong>7.5.</strong> Traits</a></li><li><a href="objects/cast.html"><strong>7.6.</strong> Cast, and dynamic typing</a></li></ul></li><li><a href="functions/README.html"><strong>8.</strong> Function advanced</a></li><li><a href="pattern/README.html"><strong>9.</strong> Pattern matching</a></li><li><a href="errors/main.html"><strong>10.</strong> Error handling</a></li><li><ul class="section"><li><a href="errors/scope_guards.html"><strong>10.1.</strong> Scope guards</a></li><li><a href="errors/catching.html"><strong>10.2.</strong> Catching</a></li><li><a href="errors/option.html"><strong>10.3.</strong> Exception and option type</a></li><li><a href="errors/fptr_closure.html"><strong>10.4.</strong> Unsafe function pointer</a></li></ul></li><li><a href="templates/README.html"><strong>11.</strong> Templates</a></li><li><ul class="section"><li><a href="templates/special.html"><strong>11.1.</strong> Template types</a></li><li><a href="templates/cte.html"><strong>11.2.</strong> Template values</a></li><li><a href="templates/values.html"><strong>11.3.</strong> Compilation time execution</a></li></ul></li><li><a href="objects/common_traits.html"><strong>12.</strong> Common traits</a></li><li><ul class="section"><li><a href="traits/streamable.html"><strong>12.1.</strong> Streamable</a></li><li><a href="traits/copiable.html"><strong>12.2.</strong> Copiable</a></li><li><a href="traits/disposable.html"><strong>12.3.</strong> With guard and Disposable</a></li><li><a href="traits/hashable.html"><strong>12.4.</strong> Hashable</a></li><li><a href="traits/serialize.html"><strong>12.5.</strong> Packable and Serializable</a></li></ul></li><li><a href="templates/operators.html"><strong>13.</strong> Operator overloading</a></li><li><ul class="section"><li><a href="templates/binary.html"><strong>13.1.</strong> Unary, binary and Comparison</a></li><li><a href="templates/complex_operators.html"><strong>13.2.</strong> Access, contains and iteration</a></li></ul></li><li><a href="version/README.html"><strong>14.</strong> Version</a></li><li><a href="macros/README.html"><strong>15.</strong> Macro</a></li><li><ul class="section"><li><a href="macros/std.html"><strong>15.1.</strong> Std and Core macros</a></li></ul></li><li><a href="documentation/README.html"><strong>16.</strong> Documentation</a></li><li><ul class="section"><li><a href="documentation/types.html"><strong>16.1.</strong> Types</a></li><li><a href="documentation/symbols.html"><strong>16.2.</strong> Symbols</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Ymir Tour</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#introduction" id="introduction"><h1>Introduction</h1></a>
<p><em>Ymir</em> is a high-level, statically typed programming language
designed to help developers to save time by providing strong and
safe semantic. The semantic of this language is oriented towards
safety, concurrency and speed of execution. These objectives are
achieved thanks to its high expressiveness and its direct
compilation into an efficient native machine language.</p>
<p>This documentation explores the main concepts of <em>Ymir</em>, providing a
set of examples that demonstrate the strengths of this new
language. It also presents an introduction to the standard library.</p>
<a class="header" href="print.html#important" id="important"><h1>Important</h1></a>
<p>Before starting to discuss the language, please keep in mind that it
is still under development and that sometimes things may not work as
expected. If you encounter errors that you do not understand or think
are incorrect, please contact us at: <a href="mailto:gnu.ymir@mail.com">gnu.ymir@mail.com</a>. We look
forward to receiving your mails!</p>
<p>Even more, all contributions are very welcome, whether to improve the
documentation, to propose improvements to the language or std, to the
runtime, or even to the automatic release generation procedure. All
code repositories are available on
<a href="https://github.com/GNU-Ymir">github</a>. In this documentation, known
limitations of the language are sometimes highlighted, and calls for
contribution.</p>
<a class="header" href="print.html#installation" id="installation"><h2>Installation</h2></a>
<p>The reference compiler of <em>Ymir</em> is based on the compiler <strong>GCC</strong>,
which offer strong static optimization, as well as a vast set of
supported target architectures.</p>
<p>There are two ways to install the <strong>gyc</strong> (Gnu Ymir Compiler), natively or by using a docker container.</p>
<a class="header" href="print.html#native-installation" id="native-installation"><h3>Native installation</h3></a>
<p>This compiler can be installed on linux debian system, by following those simple steps:</p>
<ul>
<li>
<p>First, you need to downloads the packages :</p>
<ul>
<li><a href="https://ymir-lang.org/release/gmidgard/9.3.0/libgmidgard_9.3.0_amd64.deb">libmidgard-9-dev</a></li>
<li><a href="https://ymir-lang.org/release/gymir/9.3.0/gyc-9_9.3.0_amd64.deb">GYC</a></li>
</ul>
</li>
<li>
<p>And then, you need to install them using dpkg :</p>
</li>
</ul>
<pre><code class="language-bash">$ sudo dpkg -i libgmidgard_9.3.0_amd64.deb
$ sudo dpkg -i gyc-9_9.3.0_amd64.deb
</code></pre>
<p><br></p>
<p>These packages depend on :</p>
<ul>
<li>g++-9</li>
<li>gcc-9-base</li>
<li>libc6 &gt;= 2.21</li>
<li>libgmp10 &gt;= 2:5.0.1~</li>
<li>libmpc3</li>
<li>libmpfr6 &gt;= 3.1.3</li>
<li>zlib1g &gt;= 1:1.1.4</li>
<li>libgcc1</li>
<li>zlib1g-dev</li>
<li>zlib1g &gt;= 1:1.2.0</li>
<li>libgc-dev &gt;= 1:7.4.2</li>
</ul>
<p>If one of them is not installed, you will get an error, that can be resolved by running the following command :</p>
<pre><code class="language-bash">sudo apt --fix-broken install
</code></pre>
<p><br></p>
<p>And then reinstall the package that has previously failed (dpkg).
The compiler is now installed and is named <code>gyc</code></p>
<pre><code class="language-bash">$ gyc --version

gyc-9 (GCC) 9.3.0
Copyright (C) 2018 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</code></pre>
<p><br></p>
<a class="header" href="print.html#uninstallation-of-the-native-version" id="uninstallation-of-the-native-version"><h3>Uninstallation of the native version</h3></a>
<p>As for any debian package, the uninstall is done as follows :</p>
<pre><code class="language-bash">$ dpkg -r gyc-9
$ dpkg -r libgmidgard-9-dev
</code></pre>
<p><br></p>
<p><strong>Caution</strong> The uninstallation can remove your gcc installation.
But you can still reinstall it easily if there is any problem, by typing :</p>
<pre><code class="language-bash">sudo apt install --reinstall gcc-9
</code></pre>
<a class="header" href="print.html#docker-installation" id="docker-installation"><h2>Docker installation</h2></a>
<p>To start you have to install docker.</p>
<pre><code class="language-bash">$ sudo apt install docker.io
</code></pre>
<p><br></p>
<p>Then retrieve the docker image from the repository :</p>
<pre><code class="language-bash">$ docker pull gnuymir/9.3.0-amd64
</code></pre>
<p>The compiler is now accessible via the container.</p>
<pre><code class="language-bash">$ docker run -t -v $(pwd):/tmp -w /tmp gnuymir/9.3.0-amd64 --version 
gyc-9 (GCC) 9.3.0
Copyright (C) 2018 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</code></pre>
<p><br></p>
<p>To make it easier to use, you can add an alias in the <code>~/.local/bin</code> directory.
First open the file <code>~/.local/bin/gyc</code> and paste the following line :</p>
<pre><code class="language-bash">docker run -t -v $(pwd):/tmp -w /tmp gnuymir/9.3.0-amd64 $*
</code></pre>
<p><br></p>
<p>Make sure, that your <code>PATH</code> contains the <code>~/.local/bin</code>directory, and
then open a new shell, and run the following commands :</p>
<pre><code class="language-bash">$ chmod +x ~/.local/bin/gyc
$ gyc --version

gyc (GCC) 9.3.0
Copyright (C) 2019 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</code></pre>
<a class="header" href="print.html#hello-world" id="hello-world"><h1>Hello World</h1></a>
<p>The following source code is the <em>Ymir</em> version of the famous program &quot;Hello world !&quot;</p>
<pre><code class="language-ymir">import std::io // importation of the module containing io functions

// This is a comment 

/** This is a function declaration
  * The main function, is the first one to be called
  */
def main () {
    // Print 'Hello World !!' to the console
    println (&quot;Hello World !!&quot;);
}
</code></pre>
<p>A binary can be generated using <strong>GYC</strong>.</p>
<pre><code class="language-bash">$ gyc hello.yr
</code></pre>
<p>This command produces a binary <code>a.out</code> that can be executed.</p>
<pre><code class="language-bash">$ ./a.out
Hello World !!
</code></pre>
<p>The command line options of gyc are the same as those of all <a href="https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html#Overall-Options">gcc
suite
compilers</a>,
with few exceptions that will be clarified in this documentation.</p>
<p>The option <strong><code>-o</code></strong> can be used to define the name of the output executable.</p>
<pre><code class="language-bash">$ gyc hello.yr -o hello
$ ls
hello  hello.yr
$ ./hello
Hello World !!
</code></pre>
<a class="header" href="print.html#comments" id="comments"><h1>Comments</h1></a>
<p><em>Ymir</em> offers different types of comments.</p>
<ul>
<li>
<blockquote>
<p><code>// A line of comment that stop at the end of the line</code></p>
</blockquote>
</li>
<li>
<blockquote>
<p><code>/* Multi-line comment that stops at the final delimiter */</code></p>
</blockquote>
</li>
</ul>
<pre><code class="language-ymir">def main () 
    throws &amp;AssertError // Not what's important for the moment
{
    // This is an example of comment

    /* 
     * This is another example of comment
     * Where, the stars are optionnal
     */

    /*
    And this is the proof
    */

    // None of the comment lines have an influence on the compilation

    let x = 1 + /* 2 + */  3;
    assert (x == 4); 
}
</code></pre>
<p>In the above pogram, calling <strong><code>assert</code></strong> will throw an exception if
the test is false. Errors are presented in the <a href="https://gnu-ymir.github.io/Documentations/en/errors/main.html">Error
Handling</a>
chapter. For the moment, we can consider that the exception simply
stops the program when the test fails.</p>
<p>We will see in the
<a href="https://gnu-ymir.github.io/Documentations/en/documentation/main.html">Documentation</a>
chapter, that comments are very usefull, to generate documentations.</p>
<a class="header" href="print.html#basic-programming-concepts" id="basic-programming-concepts"><h1>Basic programming concepts</h1></a>
<p>This chapter covers the basic concepts of <em>Ymir</em> programming
language. Specifically, you will learn about variables, mutability,
native types, functions and control flows.</p>
<a class="header" href="print.html#variables-and-mutability" id="variables-and-mutability"><h1>Variables and Mutability</h1></a>
<p>Variables are declared with the keyword <strong><code>let</code></strong>. The grammar of a
variable declaration is presented in the following code block.</p>
<pre><code class="language-grammar">var_declaration := 'let' inner_var_decl (',' inner_var_decl)*
inner_var_decl  := (decorator)* identifier (':' type)? '=' expression
decorator := 'mut' | 'dmut' | 'ref'
identifier := ('_')* [A-z] ([A-z0-9_])*
</code></pre>
<p><br></p>
<p>The declaration of a variable is composed of four parts, 1) the
identifier that will be used to refer to the variable in the program,</p>
<ol start="2">
<li>the decorators, that will give a different behavior to the program
regarding the variable, 3) a value, that sets the initial value of the
variable, and 4) a type, optional part of a variable declaration,
which when omitted is infered from the type of the initial value of
the variable. Conversely, when specified the type of a variable is
statically checked and compared to the initial value of the variable.</li>
</ol>
<a class="header" href="print.html#variable-type" id="variable-type"><h2>Variable type</h2></a>
<p>The type of the variable, as presented in the introduction, is
specified in the variable declaration. This implies a static typing of
each variable, whereby a variable cannot change its type during its
lifetime. To illustrate this point, the following source code declares
a variable of type <strong><code>i32</code></strong>, and tries to put a value of type
<strong><code>f32</code></strong> in it. The language does not accept this behavior, and the
compiler returns an error.</p>
<pre><code class="language-ymir">def main () {
    let mut x = 12; // 12 is a literal of type i32
    //  ^^^ this decorator, presented in the following sub section, is not the point of this example
    
    x = 89.0f; // 89.0f is a literal of type f32 (floating point value)
}
</code></pre>
<p><br></p>
<p>The compiler, because the source code is not an acceptable <em>Ymir</em>
program, returns an error. The error presented in the following
block, informs that the variable <strong><code>x</code></strong> of type <strong><code>i32</code></strong>, is
incompatible with a value of type <strong><code>f32</code></strong>.</p>
<pre><code class="language-error">Error : incompatible types mut i32 and f32
 --&gt; main.yr:(5,4)
 5  ┃ 	x = 89.0f; // 89.0f is a literal of type f32 (floating point value)
    ╋ 	  ^


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<a class="header" href="print.html#variable-mutability" id="variable-mutability"><h2>Variable mutability</h2></a>
<p>The decorators are used to determine the behavior to adopt with the
variable. The keyword <strong><code>ref</code></strong> and <strong><code>dmut</code></strong> will be discussed in
another chapter (<em>cf.</em> <a href="https://gnu-ymir.github.io/Documentations/en/advanced/">Aliases and
References</a>). For
the moment, we will be focusing on the keyword <strong><code>mut</code></strong>. This keyword
is used to define a mutable variable, whose value can be changed. A
variable declared without the <strong><code>mut</code></strong> keyword is declared immutable
by default, making its value definitive.</p>
<p>In another word, if a variable is declared immutable, then it is bound
the a value, that the variable cannot change throughout the
life of the variable. The idea behind default immutability is to avoid
unwanted behavior or errors, by forcing the developpers to determine
which variables are mutable with the use of a deliberately more
verbose syntax, while making all the other variables immutable.</p>
<p>In the following source code a variable <strong><code>x</code></strong> of type <strong><code>i32</code></strong> is
declared. This variable is immutable, (as the decorator <strong><code>mut</code></strong> is
not used). Then the line <strong>7</strong>, which consist in trying to modify the
value of the variable <strong><code>x</code></strong> is not accepted by the language,
that's why the compiler does not accept to compile the program.
<br></p>
<pre><code class="language-ymir">import std::io

def main () {
    let x = 2;	
    println (&quot;X is equal to : &quot;, x); 
    
    x = 3; 
    println (&quot;X is equal to : &quot;, x);
}
</code></pre>
<p><br></p>
<p>For the given source file, the compiler generates the following
error. This error informs that the affectation is not allowed, due to
the nature of the variable <strong><code>x</code></strong>, which is not mutable. In <em>Ymir</em>,
variable mutability and, type mutability ensure, through static
checks, that when one declares that a variable has no write access to
a value, there is no way to get write access to the value through
this variable. Although this can sometimes be frustrating for the
user.</p>
<pre><code class="language-error">Error : left operand of type i32 is immutable
 --&gt; main.yr:(7,2)
    ┃ 
 7  ┃ 	x = 3; 
    ┃ 	^


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>The above example can be modified to make the variable <strong><code>x</code></strong>
mutable. This modification implies the use of the keyword <strong><code>mut</code></strong>,
which — placed ahead of a variable declaration — makes it
mutable. Thanks to that modification, the following source code is an
acceptable program, and thus will be accepted by the compiler.</p>
<p><br></p>
<pre><code class="language-ymir">import std::io

def main () {
    let mut x = 2;	
    println (&quot;X is equal to : &quot;, x); 
    
    x = 3; 
    println (&quot;X is equal to : &quot;, x);
}
</code></pre>
<p><br>
Result:</p>
<pre><code>X is equal to : 2
X is equal to : 3
</code></pre>
<p><br> In reality, mutability is not related to variables, but to
types. This language proposes a complex type mutability system, whose
understanding requires the comprehension of data types beforehand. In
the following sections, we will, for that reason, present the type
system, (and the different types of data that can be created in <em>Ymir</em> — <em>cf.</em>  chapter <a href="https://gnu-ymir.github.io/Documentations/en/primitives/types.html">Data
types</a>),
before coming back to the data mutability, — and have a full overview
of the mutability system in chapter <a href="https://gnu-ymir.github.io/Documentations/en/advanced/">Aliases and
references</a>.</p>
<a class="header" href="print.html#initial-value" id="initial-value"><h2>Initial value</h2></a>
<p>A variable is <strong>always</strong> declared with a value. The objective is to
ensure that any data in the program came from somewhere, and are not
initialized from a random memory state of the machine executing the
program (as we can have in C language).</p>
<p>One can argue, that static verification can be used to ensure that a
variable is set before being used, and argue that forcing an initial
value to a variable is not the best way to achieve data validity.  If
at this point, this is more a matter of opinion than of sound
scientific reasoning, we think that scattering the initialization of a
variable, makes programs more difficult to read. More, immutable
variables would be mutable for one affectation, making the
behavior of a program even more difficult to grasp.</p>
<p>In the following table, is presented two examples of source code, with
the same behavior. On the left, a valid source code accepted by the
Ymir language, and on the right, a source code that is not accepted
based on the arguments we put forward.</p>
<table>
<tr>
<th> A </th>
<th> B </th>
</tr>
<tr>
<td style="width: 50%;"><pre class="language-"><code class="lang-ymir"><span class="code-line"><span class="token keyword">import</span> <span class="token path">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token path">io</span><span class="token punctuation">;</span></span>
<span class="code-line"></span>
<span class="code-line"><span class="token keyword">def</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="code-line">    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token other-keyword">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="code-line">        <span class="token number">42</span></span>
<span class="code-line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="code-line">        <span class="token number">7</span></span>
<span class="code-line">    <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="code-line"><span class="token punctuation">}</span></span></code></i></pre></td>
<td style="width: 50%;"><pre class="language-"><code class="lang-ymir"><span class="code-line"><span class="token keyword">import</span> <span class="token path">std</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token path">io</span><span class="token punctuation">;</span></span>
<span class="code-line"></span>
<span class="code-line"><span class="token keyword">def</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="code-line">    <span class="token keyword">let</span> i <span class="token punctuation">:</span> <span class="token basic-types">i32</span><span class="token punctuation">;</span></span>
<span class="code-line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token other-keyword">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="code-line">        i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span></span>
<span class="code-line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="code-line">        i <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span></span>
<span class="code-line">    <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="code-line"><span class="token punctuation">}</span></span></code></pre></td>
</tr>
</table>
<p>One can note from the left
program, that an <strong><code>if</code></strong> expression has a value. Value computed by
the result of the expression (in that case the value <strong><code>42</code></strong> of type
<strong><code>i32</code></strong>). In point of fact, every expression can have a value in
Ymir, removing the limitation, introduced by the forcing of an initial
value to variables.</p>
<a class="header" href="print.html#global-variables" id="global-variables"><h2>Global variables</h2></a>
<p>Even if global variables have a rather bad reputation for many
justified reasons, we choose to let the possibility to define them,
since in spite of all, they allow some programmation paradigms that
would be undoable otherwise.</p>
<p>Global variables are defined as any local variable, except that the
keyword <strong><code>let</code></strong> is replaced by the keyword <strong><code>static</code></strong>. The
following source code presents an utilization of an immutable global
variable. This example is just a showcase, as the use of an
enumeration (<em>cf.</em>
<a href="https://gnu-ymir.github.io/Documentations/en/types/enum.html">Enum</a>)
would probably be more appropriate in this specific case.</p>
<pre><code class="language-ymir">import std::io

static pi = 3.14159265359

def main () {
    println (&quot;Pi value is : &quot;, pi);
}
</code></pre>
<p><br></p>
<p>All information presented on local variables are relevant to the case
of global variables. Here, we are refering to static typing,
mutability behavior, and default value initialization. No limitation
exists on the value that can be stored inside a global variable, nor
there exists on the nature of the initialization. Call of functions,
conditional expressions, class initializations, etc., nothing was left
out.</p>
<p>Global variables are initialized before the start of the program,
before the call of the <code>main</code> function. To illustrate that, the
following source code, creates a global variable of type <strong><code>i32</code></strong>
initialized from the value of the function <strong><code>foo</code></strong>. This function
<strong><code>foo</code></strong> by making a call of the function <strong><code>println</code></strong>, prints a
message to the console, and the <strong><code>main</code></strong> function also does it.</p>
<pre><code class="language-ymir">import std::io;

static __GLOBAL__ = foo ();

/**
  * This function print the message &quot;foo&quot;, and returns the value 42
  */
def foo ()-&gt; i32 {
  println (&quot;foo&quot;);
  42
}

def main () {
    println (&quot;__GLOBAL__ = &quot;, __GLOBAL__);
}
</code></pre>
<p><br></p>
<p>Result:</p>
<pre><code>foo
__GLOBAL__ = 42
</code></pre>
<a class="header" href="print.html#initialization-order" id="initialization-order"><h3>Initialization order</h3></a>
<p>There is no warranty on the order of initialization of global
variables. This is probably, the first limitation that we can point
out on the Ymir languages. <strong>Contribution</strong>, to allow such warranty would
be very welcomed, but seems unlikely to be possible when global
variables come from multiple modules (<em>cf.</em>
<a href="https://gnu-ymir.github.io/Documentations/en/modules">Modules</a>).</p>
<p>For the moment, because it is impossible to certify the good
initialization of a global variable, before the start of the program, it
is not allowed to initialize a global variable from the value of
another global variable. However, this verification is very limited,
as the value of a global variable can be used inside a function, and
this same function used to initialize the value of another global
variable. In the following source code, this behavior is illustrated.</p>
<pre><code class="language-ymir">static __A__ = 42;
static __B__ = __A__; 
static __C__ = foo ();

def foo () -&gt; i32 {
    __A__
}
</code></pre>
<p><br></p>
<p>The compiler will unfortunetaly be able to see only the dependent
initialization of <strong><code>__B__</code></strong>, and will let the initialization of
<strong><code>__C__</code></strong> from the function <strong><code>foo</code></strong> occur. Even if in that
specific case, the dependency appears very clearly, it may not be that
clear when the function <strong><code>foo</code></strong> come from an external module, that
only provides its prototype.</p>
<pre><code class="language-error">Error : the global var main::__B__ cannot be initialized from the value of main::__A__
 --&gt; main.yr:(2,8)
 2  ┃ static __B__ = __A__; 
    ╋        ^^^^^
    ┃ Note : 
    ┃  --&gt; main.yr:(1,8)
    ┃  1  ┃ static __A__ = 42;
    ┃     ╋        ^^^^^
    ┃ Note : 
    ┃  --&gt; main.yr:(2,16)
    ┃  2  ┃ static __B__ = __A__; 
    ┃     ╋                ^^^^^
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<a class="header" href="print.html#shadowing-and-scope" id="shadowing-and-scope"><h2>Shadowing and scope</h2></a>
<a class="header" href="print.html#lifetime" id="lifetime"><h3>Lifetime</h3></a>
<p>The lifetime of a variable is defined by a scope. Regrouping
expressions separated by semi-colons between curly brackets, a scope
is a semantic component well known in programming languages. It has
some particularities in Ymir, but these particularities will be
presented in forthcoming chapters
(<em>cf.</em> <a href="https://gnu-ymir.github.io/Documentations/en/primitives/functions.html">Functions</a>,
<a href="https://gnu-ymir.github.io/Documentations/en/errors/scope.html">Scope
guards</a>)
and are not of interest to us at this point.</p>
<pre><code class="language-ymir">import std::io;

def main () {
    {
        let x = 12;
    } // x does not exists past this scope end
    println (x);
}
</code></pre>
<p><br></p>
<p>When a variable is declared inside a scope and is never used during
its lifetime the compiler returns an error. To avoid this error, the
variable can be named <strong><code>_</code></strong>. If it may seem useless to declare a
variable that is not used, it can be useful sometimes (for example
when declaring function parameters of an overriden function, <em>cf.</em>
<a href="https://gnu-ymir.github.io/Documentations/en/objects/inheritance.html">Class
inheritence</a>).</p>
<p>A variable whose name is <strong><code>_</code></strong>, is anonymus, then there is no way to
retreive the value of this variable.</p>
<pre><code class="language-ymir">import std::io;

def main () {
    let _ = 12; // declare a anonymus variable
}
</code></pre>
<a class="header" href="print.html#shadowing" id="shadowing"><h3>Shadowing</h3></a>
<p>Two variables with the same name cannot be declared in colliding
scopes, i.e. if a variable is declared with the name of a living
variable in the current scope, the program is not acceptable, and the
compiler returns a shadowing error. The following source code
illustrates this point, where two variables are declared in the same
scope with the same name <strong><code>x</code></strong>.</p>
<pre><code class="language-ymir">def main () {
    let x = 1;	
    let x = 2;	
    { 
        let x = 3; 
    }
}
</code></pre>
<p><br></p>
<p>The compiler returns the following error. Even the last variable in
the scope opened at line <strong>4</strong> is not authorized. Many errors can be
avoided, by simply removing this possibility. Possibility, in our
opinion, that is not likely to bring anything of any benefit.</p>
<pre><code class="language-error">Error : declaration of x shadows another declaration
 --&gt; main.yr:(3,9)
 3  ┃     let x = 2;    
    ╋         ^
    ┃ Note : 
    ┃  --&gt; main.yr:(2,9)
    ┃  2  ┃     let x = 1;    
    ┃     ╋         ^
    ┗━━━━━┻━ 

Error : declaration of x shadows another declaration
 --&gt; main.yr:(5,13)
 5  ┃         let x = 3; 
    ╋             ^
    ┃ Note : 
    ┃  --&gt; main.yr:(2,9)
    ┃  2  ┃     let x = 1;    
    ┃     ╋         ^
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>Global variables do not create variable shadowing problems on local
variables. A global variable is a global symbol, and is accessible
through its parent module definition (<em>cf.</em>
<a href="https://gnu-ymir.github.io/Documentations/en/modules/">Modules</a>). Local
variables on the other hand, are only accessible for the function in
which they are declared. Symbol access gives the priority to local
variables, behavior illustrated in the following example.</p>
<pre><code class="language-ymir">mod Main; // declaration of a module named Main

import std::io;

static pi = 3.14159265359

def main ()
    throws &amp;AssertError
{
    {
        let pi = 3;
        assert (pi == 3); // using local pi
    } // by closing the scope, local pi does not exist anymore
    
    // because local pi does no longer exists
    // global pi is accessible
    assert (pi == 3.14159265359);
    
    // global pi can also be accessed from its parent module
    assert (Main::pi == 3.14159265359);
}
</code></pre>
<a class="header" href="print.html#primitives-types" id="primitives-types"><h1>Primitives types</h1></a>
<p>In <em>Ymir</em> language, each value has a certain type of data, which
indicates how the program must behave and how it should operate with
the value. <em>Ymir</em> is a statically typed language, which means that
all types of all values must be known at compile time. Usually, the
compiler is able to infer the data types from the values, and it is
not necessary to specify them when declaring a variable. But
sometimes, when it comes to the mutability of a variable or the
inheritance of a class for example, the inference can be wrong and
the behavior not adapted to what you might want to do.</p>
<p>Therefore, the type may be added when declaring a variable, as in the
following code.</p>
<pre><code class="language-ymir">let mut x : [mut i32] = [1, 2];
let mut y = [1, 2];
</code></pre>
<p><br></p>
<p>To understand the difference between the type of <strong><code>x</code></strong> and the type
of <strong><code>y</code></strong>, we invite you to read the chapter
<a href="https://gnu-ymir.github.io/Documentations/en/advanced/">Aliases and References</a>.</p>
<p>Each type has type attributes. Theses attributes are accessed using
the double colon operator <strong><code>::</code></strong> on a type expression.</p>
<pre><code class="language-ymir">let a = i32::init;  // i32 (0)
</code></pre>
<p><br></p>
<p>All primitive types have common attributes that are listed in the
table below. Attributes can be surrounded by the token <strong><code>_</code></strong>, to avoid some
ambiguity for some types (<em>cf.</em>
<a href="https://gnu-ymir.github.io/Documentations/en/types/enum.html">Enumeration</a>). For
example, the attribute <strong><code>typeid</code></strong> is equivalent to <code>__typeid__</code>, or
<code>_typeid</code>.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>init</code> </td><td> The initial value of the type </td></tr>
<tr><td> <code>typeid</code> </td><td>  The name of the type stored in a value of type <strong><code>[c32]</code></strong> </td></tr>
<tr><td> <code>typeinfo</code> </td><td> A structure of type TypeInfo, containing information about the type </td></tr>
</tbody></table>
<p>All the information about TypeInfo are presented in chapter <a href="https://gnu-ymir.github.io/Documentations/en/types_advanced/">Dynamic
types</a>.</p>
<a class="header" href="print.html#typeof-and-sizeof" id="typeof-and-sizeof"><h2><em>typeof</em> and <em>sizeof</em></h2></a>
<ol>
<li>The keyword <strong><code>typeof</code></strong> retreives the type of a value at
compilation time. This type can be used in any context, to retreive
type information. For example, in a variable declaration, a function
parameter, or return type, structure fields, etc..</li>
</ol>
<pre><code class="language-ymir">import std::io;

def bar () -&gt; i32 {
    42 
}

def foo () -&gt; typeof (bar ()) {
    bar ()
}

def main () {
    let x : typeof (foo ()) = foo ();
    
    println (typeof (x)::typeid, &quot; (&quot;, x, &quot;)&quot;);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>i32 (42)
</code></pre>
<p><br></p>
<ol start="2">
<li>The keyword <strong><code>sizeof</code></strong> retreive the size of a type in bytes at
compilation time. It is applicable only on types, not on value, but
the type of a value can be retreive using the <strong><code>typeof</code></strong>
keyword. This size is given in a value of type <strong><code>usize</code></strong> (this
scalar type is presented below).</li>
</ol>
<pre><code class="language-ymir">import std::io;

def main () {
    let x : usize = sizeof (i32);
    println (x, &quot; &quot;, sizeof (typeof (x)));
}
</code></pre>
<p><br></p>
<p>Results: (on a x86-64 arch)</p>
<pre><code>4 8
</code></pre>
<p><br></p>
<a class="header" href="print.html#scalar-types" id="scalar-types"><h2>Scalar types</h2></a>
<p>Scalar types represent all types containing a single value. <em>Ymir</em>
has five primitive scalar types: integers, floating point, characters,
booleans, and pointers. They can have different sizes for different
purposes.</p>
<a class="header" href="print.html#integer-types" id="integer-types"><h3>Integer types</h3></a>
<p>An integer is a number without decimal points. There are different
types of integers in <em>Ymir</em>, the signed one and the unsigned
one. Signed and unsigned refers to the possibility for a number to be
negative. Signed integer types begin with the letter <strong><code>i</code></strong>, while
unsigned integers begin with the letter <strong><code>u</code></strong>. The following table
lists all the different types of integers, and sorts them by memory
size.</p>
<table><thead><tr><th> size </th><th> signed </th><th> unsigned </th></tr></thead><tbody>
<tr><td> 8 bits </td><td> i8 </td><td> u8 </td></tr>
<tr><td> 16 bits </td><td> i16 </td><td> u16 </td></tr>
<tr><td> 32 bits </td><td> i32 </td><td> u32 </td></tr>
<tr><td> 64 bits </td><td> i64 </td><td> u64 </td></tr>
<tr><td> arch </td><td> isize </td><td> usize </td></tr>
</tbody></table>
<p>The <code>usize</code> and <code>isize</code> types are architecture dependent, and have the
size of a pointer, depending on the architecture targeted.</p>
<p>Each type of signed integer can store values ranging from <em>-(2
<sup>n - 1</sup>)</em> to <em>2 <sup>n - 1</sup> - 1</em>, where <em>n</em> is the size
of the integer in memory. Unsigned types, on the other hand, can store
numbers ranging from <em>0</em> to <em>2 <sup>n</sup> - 1</em>. For example, type
<strong><code>i8</code></strong>, can store values from <em>-128</em> to <em>127</em>, and type <strong><code>u8</code></strong> can
store values from <em>0</em> to <em>255</em>.</p>
<p>You can write an integer in two forms, decimal <code>9_234</code> and hexadecimal
<code>0x897A</code>. The <code>_</code> token, is simply ignored in a literal integer.</p>
<p>To make sure a literal value has the right type, a prefix can be added
at the end of it. For example, to get a <strong><code>i8</code></strong> with the value <em>7</em>,
the right literal is written <code>7i8</code>. By default, if no prefix is added
at the end of the literal, the language defines its type as a
<strong><code>i32</code></strong>.</p>
<p>As indicated above, each type has attributes, the following table
lists the integer-specific attributes:</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>max</code> </td><td> The maximal value </td></tr>
<tr><td> <code>min</code> </td><td> The minimal value </td></tr>
</tbody></table>
<p>An overflow check is performed on literals at compilation time, and an
error is returned by the compiler if the type of integer choosed to
encode the literal is not large enough to contain the value. For
example:</p>
<pre><code class="language-ymir">def main () {
    let x : i8 = 934i8;
}
</code></pre>
<p>Because a i8 can only store value ranging from <code>-127</code> to <code>128</code>, the
value <code>934</code> would not fit. For that reason the compiler returns the
following error.</p>
<pre><code class="language-error">Error : overflow capacity for type i8 = 943
 --&gt; main.yr:(12,18)
    ┃ 
12  ┃     let x : i8 = 943i8;
    ┃                  ^^^

ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p><strong>WARNING</strong> However, if the value cannot be known at compile time, the
overflow is not checked and can lead to strange behavior. For example,
if you try to add 1 to a variable of type <strong><code>i16</code></strong> that contains the
value <code>32767</code>, the result will be <code>-32768</code>. <em>Contribution:</em> Provide a
dynamic way to verify the overflow of arithmetic operation (at least
in debug mode).</p>
<a class="header" href="print.html#floating-point-types" id="floating-point-types"><h3>Floating-point types</h3></a>
<p>Floating-point types, refer to numbers with a decimal
part. <em>Ymir</em> provides two types of floating point numbers, <strong><code>f32</code></strong>
and <strong><code>f64</code></strong>, which have a size of 32 bits and 64 bits respectively.</p>
<p>You can add the prefix <strong><code>f</code></strong>, at the end of a literal floating point
to specify that you want a <strong><code>f32</code></strong>, instead of a <strong><code>f64</code></strong> as it is
by default.</p>
<pre><code class="language-ymir">def main () {
    let x = 1.0; 
    let y : f32 = 1.0f;
}
</code></pre>
<p>The following table lists the attributes specific to floating point
types.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>init</code> </td><td> The initial value - <code>nan</code> </td></tr>
<tr><td> <code>max</code> </td><td> The maximal finite value that this type can encode</td></tr>
<tr><td> <code>min</code> </td><td> The minimal finite value that this type can encode</td></tr>
<tr><td> <code>nan</code> </td><td> The value <strong>Not a Number</strong> </td></tr>
<tr><td> <code>dig</code> </td><td> The number of decimal digit of precision </td></tr>
<tr><td> <code>inf</code> </td><td> The value positive infinity </td></tr>
<tr><td> <code>epsilon</code> </td><td> The smallest increment to the value <code>1</code> </td></tr>
<tr><td> <code>mant_dig</code> </td><td> Number of bits in the  <strong>mantissa</strong> </td></tr>
<tr><td> <code>max_10_exp</code> </td><td>    maximum int value such that $$10^{max_10_exp}$$ is representable </td></tr>
<tr><td> <code>max_exp</code> </td><td> maximum int value such that $$2^{max_exp-1}$$ is representable</td></tr>
<tr><td> <code>min_10_exp</code> </td><td> minimum int value such that $$10^{min_10_exp}$$ is representable as a normalized value</td></tr>
<tr><td> <code>min_exp</code> </td><td> minimum int value such that $$2^{min_exp-1}$$ is representable as a normalized value</td></tr>
</tbody></table>
<a class="header" href="print.html#boolean-type" id="boolean-type"><h3>Boolean type</h3></a>
<p>A boolean is a very simple type that can take two values, either <code>true</code> or <code>false</code>.  For example:</p>
<pre><code class="language-ymir">def main () {
    let b = true;
    let f : bool = false;
}
</code></pre>
<p><br></p>
<p>The following table lists the attributes specific to boolean type.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>init</code> </td><td> The initial value - <code>false</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#character-type" id="character-type"><h3>Character type</h3></a>
<p>The <strong><code>c8</code></strong> and <strong><code>c32</code></strong> are the types used to encode the
characters. The <strong><code>c32</code></strong> character has a size of four bytes and can
store any unicode value.  Literal characters can have two forms, and
are always surrounded by the token <strong><code>'</code></strong>. The first form is the
character itself for example <strong><code>'r'</code></strong>, and the second is the unicode
value in the integer form <code>\u{12}</code> or <code>\u{0xB}</code>.</p>
<p>As with literal integers, it is necessary to add a prefix
to define the type of a literal. The prefix used to specify the type
of a literal character is <strong><code>c8</code></strong>, if nothing is specified, the
character type will be <strong><code>c32</code></strong>.</p>
<pre><code class="language-ymir">def main () {
    let x = '☺';	
    let y = '\u{0x263A}';
}
</code></pre>
<p><br></p>
<p>If the loaded literal is too long to be stored in the character type,
an error will be returned by the compiler. For example :</p>
<pre><code class="language-ymir">def main () {
    let x = '☺'c8; 
}
</code></pre>
<p><br></p>
<p>The error will be the following. This error means that you will need
at least 3 <strong><code>c8</code></strong> (or bytes) to store the value, so it doesn't fit into one
<strong><code>c8</code></strong> :</p>
<pre><code class="language-error">Error : malformed literal, number of c8 is 3
 --&gt; main.yr:(2,10)
    | 
 2  | 	let x = '☺'c8; 
    | 	        ^

ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>The following table lists the attributes specific to character types.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>init</code> </td><td> The initial value - <code>\u{0}</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#pointers" id="pointers"><h3>Pointers</h3></a>
<p>Pointer are values that stores an address of memory. They can be used
to store the location of a data in memory. In <em>Ymir</em>, pointers are
considered low level programming and are mainly used in the std, and
runtime to interface with machine level semantics. You can perfectly
write any program without needing pointers, and for that reason we
recomand to not use them.</p>
<p>Pointers are defined using the token <strong><code>&amp;</code></strong> on types, or on
values. They are aliasable types, as they borrow memory (<em>cf.</em> <a href="https://gnu-ymir.github.io/Documentations/en/advanced/">Aliasable
and
References</a>).</p>
<pre><code class="language-ymir">import std::io;

def main ()
    throws &amp;SegFault, &amp;AssertError
{
    let mut i = 12;
    let p : &amp;i32 = &amp;i; // creation of a pointer on i
    i = 42;
    assert (*p == 42); // dereference the pointer and access the value
}
</code></pre>
<p><br></p>
<p>Pointers are unsafe, and dereferencing a pointer can result in undefined
behavior depending on where it points. It can also sometimes raise a
segmentation fault. In <strong><code>Ymir</code></strong>, segmentation fault are recovered,
and an exception is thrown. Error handling is presented in chaper
<a href="https://gnu-ymir.github.io/Documentations/en/errors/main.html">Error
Handling</a>.</p>
<p><strong>WARNING</strong>, Note that the segmentation fault may not occur even if
the pointer is not properly set. The easiest way to avoid undefined
behavior is to not use pointers and use <code>std</code> verified functions, or
other semantically verified elements (cf <a href="https://gnu-ymir.github.io/Documentations/en/advanced/">Aliasable and
References</a>).</p>
<p><br></p>
<p>The following table lists the attributes specific to pointer types.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>inner</code> </td><td> The type of the inner value - for example : <code>i32</code> for <code>&amp;i32</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#compound-types" id="compound-types"><h2>Compound types</h2></a>
<p>Unlike scalar types, the compound can contain multiple values.  There are
three types of compounds: the tuple, the range and the arrays.</p>
<a class="header" href="print.html#tuple" id="tuple"><h3>Tuple</h3></a>
<p>A tuple is a set of values of different types. Tuples have a fixed
arity. The arity of a tuple is defined at compilation time, and
represent the number of values contained inside the tuple. Each
element of a tuple has a type, and a given order. Tuples are built
between parentheses, by a comma-separated list of values. A tuple of
one value can be defined, by putting a coma after the first
value. This way the compiler can understand the desire of creating a
tuple, and do not confuse it with a normal expression between
parentheses.</p>
<pre><code class="language-ymir">def main () {
    let t : (i32, c32, f64) = (1, 'r', 3.14);  // three value tuple
    let t2 : (i32,) = (1,); // single value tuple
    let t3 : i32 = (1); // single value of type i32
}
</code></pre>
<p><br></p>
<p>In the above example, the tuple <code>t</code>, is a single element, and can be
used as a function parameter or as a return value of a function. It
can also be destructured, to retrieve the values of its component
elements. There are three ways of tuple destructuring.</p>
<ol>
<li>the dot operator <strong><code>.</code></strong>, followed by an integer value, whose value
is known at compilation time. This value can be computed by a complex
expression, as long as the compiler is able to retreive the value at
compilation time (<em>cf.</em> <a href="https://gnu-ymir.github.io/Documentations/en/templates/cte.html">Compilation time
execution</a>).</li>
</ol>
<pre><code class="language-ymir">import std::io;

def main () {
    let t = (1, 'r', 3.14);
    let z : i32 = t._0;
    let y : c32 = t. (0 + 1); 
    println (t.2);
}
</code></pre>
<p><br></p>
<ol start="2">
<li>the tuple destructuring syntax. This syntax, close to variable
declaration, creates new variables that contains parts of the tuple
that is destructured. In the following example, one can note that the
tuple destructuring syntax allows to extract only some of the tuple
values. The type of the variable <strong><code>e</code></strong> is the tuple <strong><code>(c32, f64)</code></strong>, and its values are <strong><code>('r', 3.14)</code></strong>, when the variable
<strong><code>f</code></strong> contains the value <strong><code>1</code></strong> of type <strong><code>i32</code></strong>.</li>
</ol>
<pre><code class="language-ymir">def main () {
    let t = (1, 'r', 3.14);
    let (x, y, z) = t;
    
    let (f, e...) = t;
    println (f, &quot; &quot;, e.0);
}
</code></pre>
<p><br></p>
<ol start="3">
<li>the keyword <strong><code>expand</code></strong>. this keyword is a compile-time rewrite,
that expands the values of a tuple into a list of values. This list is
then used to create other tuples, call functions, etc. The following
example shows the use of the keyword <strong><code>expand</code></strong> to call a function
taking two parameters, with the value of a tuple containing two
values.</li>
</ol>
<pre><code class="language-ymir">import std::io

def add (a : i32, b : i32) -&gt; i32 
    a + b


def main () {
    let x = (1, 2);
    println (add (expand x)); 
    // ^^^^^^^^^^^^^^^^^^^^^^
    // Will be rewritten into : 	
    // println (add (x.0, x.1));
    
    let j : (i32, i32, i32) = (1, expand x);	
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // rewritten into : (1, x.0, x.1)
}
</code></pre>
<p><br></p>
<p>There is two other ways to destructurate a tuple. These ways are
presented in forthcoming chapters. The following table lists the
attributes specific to tuple types.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>arity</code> </td><td> The number of elements contained in the tuple (in a <strong><code>u32</code></strong>) </td></tr>
<tr><td> <code>init</code> </td><td> a tuple, where each element values are set to <code>init</code>  </td></tr>
</tbody></table>
<a class="header" href="print.html#ranges" id="ranges"><h3>Ranges</h3></a>
<p>Ranges are types that contain values defining an interval. A range is
named <strong><code>r!T</code></strong>, where <strong><code>T</code></strong> is the type of the range limits. They
are created by the token <strong><code>..</code></strong> and <strong><code>...</code></strong>. A range consists of
four values, which are stored in the fields shown in the following
table. These fields can be accessed using the dot operator <strong><code>.</code></strong>.</p>
<table><thead><tr><th> name </th><th> type </th><th> value </th></tr></thead><tbody>
<tr><td> fst </td><td> T </td><td> the first bound </td></tr>
<tr><td> scd </td><td> T </td><td> the second bound </td></tr>
<tr><td> step </td><td> mut T </td><td> the step of the interval </td></tr>
<tr><td> contain </td><td> bool </td><td> Is the scd bound contained in the interval ? </td></tr>
</tbody></table>
<pre><code class="language-ymir">def main () {
    let range : r!(i32) = 1 .. 8; 	
    let c_range : r!(i32) = 1 ... 8;
}
</code></pre>
<p><br></p>
<p>The <code>step_by</code> function takes a range as a parameter and returns a new
range, with a modified step. This function is a core function, thus
there is nothing to import.</p>
<pre><code class="language-ymir">def main () { 
    let range = (1 .. 8).step_by (2); 
} 
</code></pre>
<p><br></p>
<p>The <a href="https://gnu-ymir.github.io/Documentations/en/primitives/control.html">Control
flows</a>
section shows a use of these types.</p>
<a class="header" href="print.html#arrays" id="arrays"><h3>Arrays</h3></a>
<p>An array is a collection of values of the same type, stored in
contiguous memory.  Unlike tuples, the size of an array is unknown at
compile time, and in <em>Ymir</em>, they are similar to slices, and will be
refered as such. Slices are defined with a syntax close to the one of
tuple, but with brackets instead of parentheses, for example <strong><code>[1, 2, 3]</code></strong>.  The type of a slice is also defined using the brackets, for
example <strong><code>[i32]</code></strong>, meaning a slice containing <strong><code>i32</code></strong> values.</p>
<p>String literals, enclosed between double quotes are a special case of
slice literals. There is no string type in <em>Ymir</em>, but only slices
type. Because of this, string values are typed <strong><code>[c32]</code></strong> or
<strong><code>[c8]</code></strong> depending on the type of values contained in the
slice. String literals can be prefixed with the keyword <strong><code>s8</code></strong> or
<strong><code>s32</code></strong> to define the encoding system used. By default, when no
prefix is specified a string literal have a type <strong><code>[c32]</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

def main () { 
    let x = [1, 2, 3]; // a [i32] slice
    let y = &quot;Hello World !!&quot;; // a [c32] slice
    let z = &quot;Hello World !!&quot;s8; // a [c8] slice
}
</code></pre>
<p><br></p>
<p><strong>Warning</strong>: The length of a <strong><code>[c8]</code></strong> literals can seem incorrect
due to the encoding system. For example, the slice <strong><code>&quot;☺&quot;s8</code></strong> have a
length of <strong><code>3</code></strong>. To summarize, <strong><code>[c8]</code></strong> slices are utf-8 encoded
string literals, when <strong><code>[c32]</code></strong> are encoded in utf-32.</p>
<p>A slice is a two-word object, the first word is the length of the
slice, and the second is a pointer to the data stored in the slice. A
slice is an aliasable type, its mutability is a bit more complicated
than the mutability of scalar types (except pointers), because it
borrows memory which is not automatically copied when an assignment is
made. This section will not discuss the mutability of internal types
or aliasable types. This is discussed in the chapter <a href="https://gnu-ymir.github.io/Documentations/en/advanced/">Aliases and
References</a>.</p>
<p>The field <strong><code>len</code></strong> records the length of the slice and can be
retrieved with the dot operator <strong><code>.</code></strong>.  The length of the slice is
stored in a <strong><code>usize</code></strong> field.</p>
<pre><code class="language-ymir">import std::io
 
def main () {
   let x = [1, 2, 3];
   println (&quot;The value of x : &quot;, x); 
   println (&quot;The length of x : &quot;, x.len);
}
</code></pre>
<p><br></p>
<p>Similarly, the <strong><code>ptr</code></strong> field, gives access to the pointer of the
slice and its types depend on the inner type of the slice, and is
never mutable. Pointer type are absolutely not important for a
<em>Ymir</em> program, and we suspect that you will never have use of
them. They are defined to allow low level programming paradigms, and
are used in the std and runtime.</p>
<p>To access the elements of an array, the <strong><code>[]</code></strong> operator is used. It
takes either an integer value or a range value as parameter. If a
range value is given, a second slice that borrows a section of the
first is created. For now, the step of the range does not affect the
borrowing of the array. <em>Contribution</em> can be made here. On the other
hand if an integer value <strong><code>i</code></strong> is given as parameter, the value at
the index <strong><code>i</code></strong> is returned.</p>
<pre><code class="language-ymir">import std::io;

def main () 
    throws &amp;OutOfArray 
{
    let x = [1, 2, 3];
    let y = x [0 .. 2];
    let z = x [0];
    
    println (x, &quot; &quot;, y, &quot; &quot;, z); 
}
</code></pre>
<p><br></p>
<p>The length of a slice is unknown at compilation time, and access can
be made with dynamic integers whose values are also unknown at
compilation time. For that reason, it may happen that the parameters
used go beyond the slice length. With this in mind, slice access is
considered unsafe, and can throw an exception of type
<strong><code>&amp;OutOfArray</code></strong>. The exception system, and error handling is
detailed in the chapter <a href="https://gnu-ymir.github.io/Documentations/en/errors/main.html">Error
Handling</a>.</p>
<p>Slices can be concatenated, to form another slice. The concatenation
is made using the operator tilde on two operands. To work properly and
be accepted by the language, the two slice used as operands must share
the same type (but not necessarily mutability level, the mutability of
the operand with the lowest mutability level is choosed for the result
of the operation <em>cf.</em> <a href="https://gnu-ymir.github.io/Documentations/en/advanced/">Aliases and
References</a>).</p>
<pre><code class="language-ymir">import std::io

def foo () -&gt; [i32] {
    [8, 7, 6]
}

def main ()  {
    println ([1, 2, 3] ~ foo ());
}
</code></pre>
<p><br>
Results:</p>
<pre><code>[1, 2, 3, 8, 7, 6]
</code></pre>
<p><br></p>
<p>The tilde token was chosen to avoid some ambiguity. In some languages
such as Java, the concatenation is made using the token <strong><code>+</code></strong> that
sometimes creates some ambiguity when concatenating strings, and other
elements such as integers. For example, the expression <strong><code>&quot;foo&quot; + 1 + 2</code></strong>, is ambiguous.
One can note however, that since concatenation only works on slices of
the same type, the following expression <code>&quot;foo&quot; ~ 2</code>, is invalid as
&quot;foo&quot; is of type <strong><code>[c32]</code></strong>, and <strong><code>2</code></strong> of type <strong><code>i32</code></strong>.</p>
<p>Another syntax can be used to create slices. This syntax called <em>slice
allocation</em>, allocates a slice on the heap and set the same value to
every element of the slice.</p>
<pre><code class="language-ymir">import std::io
import std::random;

def main () {
    let a : [i32] = [0 ; new 100u64]; // this avoids the write of 100 zeros
                                      // but the result is the same
                              
    let b = [12 ; new uniform (10, 100)]; 
    //                ^^^^^^^ generates a random value between 10 and 100
    println (a, &quot; &quot;, b);
}
</code></pre>
<p><br></p>
<p>The following table lists the attributes specific to slice types.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>inner</code> </td><td> the inner type </td></tr>
<tr><td> <code>init</code> </td><td> an empty slice (with <code>len == 0us</code>) </td></tr>
</tbody></table>
<a class="header" href="print.html#static-arrays" id="static-arrays"><h3>Static Arrays</h3></a>
<p>Unlike the slice, static arrays are stored in the stack rather than on
the heap. To be possible, their size must be known at compilation
time. The syntax used to create a static array is close to the syntax
of a <em>slice allocation</em>, but the keyword <strong><code>new</code></strong> omitted.</p>
<pre><code class="language-ymir">import std::io

/**
  * Takes an array of size twelve as parameter
  */
def foo (a : [i32 ; 12]) {
    println (a);
}

def main ()
    throws &amp;OutOfArray
{
    let mut a : [mut i32 ; 12] = [0 ; 12];

    for i in 0 .. 12
        a [i] = i

    let b = [1; 12];

    foo (a);
    foo (b);
}
</code></pre>
<p><br></p>
<p>A static array can be transformed into a slice using the <code>alias</code>,
<code>copy</code> and <code>dcopy</code> keywords. The chapter <a href="https://gnu-ymir.github.io/Documentations/en/advanced/">Aliases and
references</a>
explains the difference between these keywords.</p>
<pre><code class="language-ymir">import std::io

def main () {
    let x : [i32; 12] = [0; 12];
    
    let a : [i32] = alias x;
    let b = copy x;
    
    println (a, &quot; &quot;, b);
}
</code></pre>
<p><br></p>
<p>One can argue that slice literals should be of static array type. We
made the choice to create slices from array literals rather than
static arrays to avoid verbosity, as we claim that slices are way more
commonly used than arrays with a static size. We are for the moment
considering the possibility to prefix slice literals, to define static
array literals, but the question is not yet decided.</p>
<p><br></p>
<p>The following table lists the attributes specific to array types.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>inner</code> </td><td> the inner type </td></tr>
<tr><td> <code>len</code> </td><td> the len of the array (<code>usize</code> value) </td></tr>
<tr><td> <code>init</code> </td><td> an array where each element is set to the <code>init</code> value of the inner type </td></tr>
</tbody></table>
<a class="header" href="print.html#option" id="option"><h3>Option</h3></a>
<p>The option typed values are values that may be set or not. They are
defined using the token <strong><code>?</code></strong> on types or values. Further
information on option type are given in the chapter <a href="https://gnu-ymir.github.io/Documentations/en/errors/main.html">Error
handling</a>,
as they are completely related to error management system.</p>
<pre><code class="language-ymir">import std::io;

def main () {
    let i : i32? = (12)?; // an option type containing the value 12
    let j : i32? = (i32?)::err; // an option value containing no value
}
</code></pre>
<p><br></p>
<p>The value of an option type can be retreived using functions in the
std, or pattern matching. In this chapter, we only focus on the
<strong><code>unwrap</code></strong> function, pattern matching being left for a future
chapter (<em>cf.</em> <a href="https://gnu-ymir.github.io/Documentations/en/pattern">Pattern
matchin</a>).  The
function <strong><code>unwrap</code></strong> from the module <strong><code>std::conv</code></strong>, get the value
contained inside an option type. If no value is contained inside the
option, the function throws an error of type <strong><code>&amp;CastFailure</code></strong>.</p>
<pre><code class="language-ymir">import std::io;
import std::conv;

def foo (b : bool)-&gt; (i32)? {
    if b { 
        19? // return the value 19, wrapped into an option
    } else {
        (i32?)::__err__ // return an empty value
    }
}


def main () 
    throws &amp;CastFailure 
{
    let x = foo (true);
    println (x.unwrap () + 23);
}
</code></pre>
<p><br></p>
<p>The following table lists the attributes specific to option types.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>err</code> </td><td> An empty option value </td></tr>
</tbody></table>
<a class="header" href="print.html#cast" id="cast"><h2>Cast</h2></a>
<p>Some value can be transformed to create value of another type. This
operation is done with the <strong><code>cast</code></strong> keywords, whose syntax is
presented in the code block below.</p>
<pre><code class="language-grammar">cast_expression := 'cast' '!' ('{' type '}' | type) expression
</code></pre>
<p><br></p>
<p>In the following example, a cast of a value of type <strong><code>i32</code></strong> to a
value of type <strong><code>i64</code></strong> is made. As said earlier, implicit casting is
not allowed. The mutability of the casted value is always lower or
equal to the mutability of the original value (for obvious reason).
<strong>Warning</strong> cast can cause loss of precision, or even sign problems.</p>
<pre><code class="language-ymir">let a = 0;
let b : i64 = cast!i64 (a);
</code></pre>
<p><br></p>
<p>The following table list the authorized casts of the primitive types :</p>
<table><thead><tr><th> From </th><th> To </th></tr></thead><tbody>
<tr><td> <code>i8</code> <code>i16</code> <code>i32</code> <code>i64</code> <code>isize</code> </td><td> <code>i8</code> <code>i16</code> <code>i32</code> <code>i64</code> <code>u8</code> <code>u16</code> <code>u32</code> <code>u64</code> <code>isize</code> <code>usize</code> </td></tr>
<tr><td> <code>u8</code> <code>u16</code> <code>u32</code> <code>u64</code> <code>usize</code> </td><td> <code>i8</code> <code>i16</code> <code>i32</code> <code>i64</code> <code>u8</code> <code>u16</code> <code>u32</code> <code>u64</code> <code>isize</code> <code>usize</code> <code>c8</code> <code>c32</code> </td></tr>
<tr><td> <code>f32</code> <code>f64</code> </td><td> <code>f32</code> <code>f64</code> </td></tr>
<tr><td> <code>c8</code> </td><td> <code>c8</code> <code>c32</code> <code>u8</code> </td></tr>
<tr><td> <code>c32</code> </td><td> <code>c8</code> <code>c32</code> <code>u32</code> </td></tr>
<tr><td> <code>&amp;(X)</code> for <code>X</code> = any type </td><td> <code>&amp;(void)</code> </td></tr>
</tbody></table>
<p>Cast if a very basic type transformation, and must be used with
precaution for basic operations. We will see in a forthecoming chapter
(<em>cf</em>. <a href="">Dynamic conversion</a>) a complex system of conversion, provided
by the standard library. This conversion system can be used to
transform value of very different type and encoding.</p>
<a class="header" href="print.html#functions" id="functions"><h1>Functions</h1></a>
<p>Function is a widely accepted concept for dividing a program into
small parts. A <em>Ymir</em> program starts with the <strong><code>main</code></strong> function that
you have already seen in previous chapters. All functions are declared
using the keyword <strong><code>def</code></strong> followed by a identifier, and a list of
parameters. A function is called by using its identifier followed by a
list of parameters separated by commas between parentheses.</p>
<pre><code class="language-ymir">import std::io 

/** 
 * The main function is the entry point of the program
 * It can have no parameters, and return an i32, or void
 */
def main () {
    foo ();
}


/** 
 * Declaration of a function named 'foo' with no parameters 
 */
def foo () {
    println (&quot;Foo&quot;);
        
    bar (); 
}


/**
 * Declaration of a function named 'bar' with one parameter 'x' of type 'i32'
*/
def bar (x : i32) {
    println (&quot;Bar &quot;, x);
}
</code></pre>
<p><br></p>
<p>The grammar of a function is defined in the following code block.</p>
<pre><code class="language-grammar">function := template_function | simple_function
simple_function := 'def' identifier parameters ('-&gt;' type)? expression
template_function := 'def' ('if' expression) identifier templates parameters ('-&gt;' type)? expression

parameters := '(' (var_decl (',' var_decl)*)? ')'
var_decl := identifier ':' type ('=' expression)?

identifier := ('_')* [A-z] ([A-z0-9_])*
</code></pre>
<p><br></p>
<p>The order of declaration of the symbol has no impact on the
compilation. The symbols are defined by the compiler before being
validated, thus contrary to C-like languages, even if the <code>foo</code>
function is defined after the <code>main</code> function (in the first example of
this chapter), it's symbol is accessible, and hence callable by the
<code>main</code> function. Further information about symbol declarations, and
accesses are presented in chapter
<a href="https://gnu-ymir.github.io/Documentations/en/modules/">Modules</a>.</p>
<a class="header" href="print.html#parameters" id="parameters"><h2>Parameters</h2></a>
<p>The parameters of a function are declared after its identifier between
parentheses. The syntax of declaration of a parameter is similar to
the syntax of declaration of a variable, except that the keyword
<strong><code>let</code></strong> is omitted. However, unlike variable declaration, a
parameter must have a type, and its value is optional.</p>
<pre><code class="language-ymir">import std::io 

/**
 * Declaration of a function 'foo' with one parameter 'x' of type 'i32'
 */
def foo (x : i32) {
    println (&quot;The value of x is : &quot;, x);
}

/**
 * Declaration of a function 'bar' with two parameters 'x' and 'y' whose respective types are 'i32' and 'i32'
 */
def bar (x : i32, y : i32) {
    println (&quot;The value of x + y : &quot;, x + y);
}

def main () {
    foo (5); // Call the function 'foo' with 'x' set to '5'
    bar (3, 4); // Call the function 'bar' with 'x' set to '3' and 'y' set to '4'
}
</code></pre>
<p><br></p>
<a class="header" href="print.html#default-value" id="default-value"><h3>Default value</h3></a>
<p>A function parameter can have a value, that is used by default when
calling the function. Therefore it is optional to specify the value of
a function parameter that have a default value, when calling it. To
change the value of a parameter with a default value, the <em>named
expression</em> syntax is used. This expression, whose grammar is
presented in the following code block, consists in naming a value.</p>
<pre><code>named_expression: Identifier '-&gt;' expression
</code></pre>
<p><br></p>
<p>The following source code presents an example of function with a
parameter with a default value, and the usage of a <em>named expression</em> to
call this function.</p>
<pre><code class="language-ymir">import std::io


/**
 * Function 'foo' can be called without specifying a value for parameter 'x'
 * '8' will be used as the default value for 'x'
 */
def foo (x : i32 = 8) {
    println (&quot;The value of x is : &quot;, x);
}

def main () {
    foo (); // call 'foo' with 'x' set to '8'
    foo (x-&gt; 7); // call 'foo' with 'x' set to '7'
}
</code></pre>
<p><br></p>
<p>The <em>named expression</em> can also be used for parameters without any
default value. Thanks to that <em>named expression</em>, it is possible to
specify the parameter in any order.</p>
<pre><code class="language-ymir">import std::io


/**
 * Parameters with default values, does not need to be last parameters
 * This function can be called with only two parameters ('x' and 'z'), or using named expression syntax
 */
def foo (x : i32, y : i32 = 9, z : i32) {
    println (x, &quot; &quot;, y, &quot; &quot;, z);
}

def main () {
    // Call the 'foo' function with 'x' = 2, 'y' = 1 and 'z' = 8 
    foo (8, y-&gt; 1, x-&gt; 2);
    foo (1, 8); // call the function 'foo' with 'x' = 1 and y = '9' and z = '8'
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>2 1 8
1 9 8
</code></pre>
<p><br></p>
<p>Any complex expression can be used, for the default value of a
function parameter. The creation of an object, a call of a function, a
code block, etc. The only limitation is that, you cannot refer to the
other parameters of the function. Indeed, they are not considered
declared in the scope of the default value.</p>
<pre><code class="language-ymir">def foo (x : i32) -&gt; i32 { ... }
def bar (x : i32) -&gt; i32 { ... }

/**
 * Declaration of a 'baz' function, where 'b' = bar(1) + foo(2), as a default value
 */
def baz (a : i32, b : i32 = {bar (1) + foo (2)}) {
 // ...
}

def main () {
    baz (12);
}
</code></pre>
<p><br></p>
<p>The symbols used in the default value of a parameters must be
accessible in the context of the function declaration. In the last
example, that means that the function <code>baz</code> must know the function
<code>bar</code> and the function <code>foo</code>, however, there is no need for the
function that calls it (here the function <code>main</code>) to know these
symbols. Further explanation on symbol declarations and accesses are
presented in chapter
<a href="https://gnu-ymir.github.io/Documentations/en/modules/">Modules</a>.</p>
<a class="header" href="print.html#recursive-default-value" id="recursive-default-value"><h3>Recursive default value</h3></a>
<p><br></p>
<p>Recursivity of default parameter is prohibited. To illustrate this
point, the following code example will not be accepted by the
compiler.</p>
<pre><code class="language-ymir">import std::io;

def foo (foo_a : i32 = bar ()) -&gt; i32 {
                    // ^^^ here there is a recursive call 
    foo_a
}

def bar (bar_a : i32 = foo ()) -&gt; i32 {
                    // ^^^ recursivity problem
                     
    println (&quot;Bar &quot;, bar_a);
    foo (foo_a-&gt; bar_a + 11) 
}

def main () {
    println (&quot;Main &quot;, bar ()); // no need to set bar_a
}
</code></pre>
<p>Errors:</p>
<pre><code class="language-error">Error : the call operator is not defined for main::bar and {}
 --&gt; main.yr:(3,28)
 3  ┃ def foo (foo_a : i32 = bar ()) -&gt; i32 {
    ╋                            ^^
    ┃ Note : candidate bar --&gt; main.yr:(8,5) : main::bar (bar_a : i32)-&gt; i32
    ┃ Note : 
    ┃  --&gt; main.yr:(3,10)
    ┃  3  ┃ def foo (foo_a : i32 = bar ()) -&gt; i32 {
    ┃     ╋          ^^^^^
    ┃ Note : 
    ┃  --&gt; main.yr:(8,24)
    ┃  8  ┃ def bar (bar_a : i32 = foo ()) -&gt; i32 {
    ┃     ╋                        ^^^
    ┃ Note : 
    ┃  --&gt; main.yr:(8,10)
    ┃  8  ┃ def bar (bar_a : i32 = foo ()) -&gt; i32 {
    ┃     ╋          ^^^^^
    ┃ Note : 
    ┃  --&gt; main.yr:(3,24)
    ┃  3  ┃ def foo (foo_a : i32 = bar ()) -&gt; i32 {
    ┃     ╋                        ^^^
    ┗━━━━━┻━
</code></pre>
<p><br></p>
<p>This recursivity problem can be easily resolved by setting a value to
the parameter <strong><code>bar_a</code></strong> when called in the default value of
<strong><code>foo_a</code></strong>.</p>
<pre><code class="language-ymir">def foo (foo_a : i32 = bar (bar_a-&gt; 20)) -&gt; i32 {
                    //      ^^^^^ resolve the recursive problem 
    foo_a
}

// no need to do the same in bar, the recursivity does not exists anymore
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>Bar 20
Bar 31
Main 42
</code></pre>
<a class="header" href="print.html#main-function-parameters" id="main-function-parameters"><h3>Main function parameters</h3></a>
<p>The <strong><code>main</code></strong> function can have a parameter. This parameter is of
type <strong><code>[[c8]]</code></strong>, and is the list of arguments passed to the program
in the command line when called.</p>
<pre><code class="language-ymir">import std::io;

def main (args : [[c8]]) {
    println (args);
}
</code></pre>
<p>Results:</p>
<pre><code class="language-bash">$ ./a.out foo bar 1
[./a.out, foo, bar, 1]
</code></pre>
<p>The std provides an argument parser in <strong><code>std::args</code></strong>, that will not
be presented here, but worth mentioning.</p>
<a class="header" href="print.html#function-body" id="function-body"><h2>Function body</h2></a>
<p>The body of a function is an expression. Every expression in <em>Ymir</em>
are typed, but that does not mean that every expression have a value,
as they can be typed as <code>void</code> expression. The expression (body of the
function) is evaluated when the function is entered, and its value is
used as the value of the function. A simple <strong><code>add</code></strong> function can be
written as follows:</p>
<pre><code class="language-ymir">def add (x : i32, y : i32)-&gt; i32 
    x + y
</code></pre>
<p><br></p>
<p>Or by using a more complex expression, such as scope, which is an
expression containing a list of expression. A scope is surrounded by
the curly brackets, and was presented in the section regarding
lifetime of local variables. The last expression in the list of
expression of a scope, is taken as the value of the scope.</p>
<pre><code class="language-ymir">
def add (x : i32, y : i32) -&gt; i32 { // start of a block
    x + y // last expression of the block is the value of the block
} // end of a block

def main () 
    throws &amp;AssertError
{
    let x = {
        let y = add (1, 2);
        y + 8 
    };
    assert (x == 11)
}
</code></pre>
<p><br></p>
<p>The semi-colon token <strong><code>;</code></strong> is a way of specifying that an expression
ends inside a scope, and that its value must be ignored. If the last
expression of a scope is terminated by a semi-colon, an empty
expression is added to the scope. This empty expression has no value,
giving to the scope an empty value of type <strong><code>void</code></strong> as well.</p>
<pre><code class="language-ymir">
/**
 * The value of foo is '9'
 */
def foo () -&gt; i32 
    9


def main () {
    let x = {
         foo (); // Call foo, but its value is ignored
    } // The value of the scope is 'void'
}
</code></pre>
<p><br></p>
<p>Because it is impossible to declare a variable with a void type, that
contains no value, the above example is no accepted by the
language. The compiler returns the error depicted below. One can note,
that it is however possible the declare a variable without value, but
its type must be an empty tuple, defined by the literal <strong><code>()</code></strong>.</p>
<pre><code class="language-error">Error : cannot declare var of type void
 --&gt; main.yr:(6,9)
    | 
 6  |     let x = {
    |         ^

ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="print.html#function-return-type" id="function-return-type"><h2>Function return type</h2></a>
<p>When the value of the body of a function is not of type <strong><code>void</code></strong>,
the function has as well a value with a type. This type must be
defined in the prototype of the function, to be visible from the other
function that can call it. This type declaration is made with the
single arrow token <strong><code>-&gt;</code></strong> after the declarations of the parameter of
the function. The return type of a function can be omitted if the
value of its body is of type <strong><code>void</code></strong>, but must be specified
otherwise.</p>
<pre><code class="language-ymir">def foo (x : i32)-&gt; i32 
    x + 1
    
def bar (x : i32, y : i32) -&gt; i32 {
    let z = x + y;
    println (&quot;The value of z : &quot;, z);
    foo (z)
}
</code></pre>
<p><br></p>
<p>It is not always convenient to define a body of a function in a way
that leads to return the right value, when many branches are
possible. To avoid verbosity, and return function prematuraly, the
keyword <strong><code>return</code></strong>, close a function and return the value of the
expression associated with it. This <strong><code>return</code></strong> statement can also be
used in a <strong><code>void</code></strong> function, if its expression is of type
<strong><code>void</code></strong>. The type of the value of the expression associated to the
<em>return statement</em> must be the same as the function return type
defined in its prototype.</p>
<pre><code class="language-ymir">def isDivisable (x : i32, z : i32) -&gt; bool {
    if (z == 0) return false; 
    
    (x % z) == 0
}
</code></pre>
<p><br></p>
<p>The compiler checks that every branches leads to a return statement or
to a value of the right type. If a function body has a type different
to the return type of the function, and it can happen that no return
statement is encountered, then the compiler returns an error.</p>
<pre><code class="language-ymir">import std::io

def add_one (x : i32)-&gt; i32 {
    x + 1; // the value of the block is void, due to the ';'
}

def main () {
    let x = add_one (5); 
    println (&quot;The value of x : &quot;, x);
}
</code></pre>
<p><br></p>
<p>In the above source code, the function <em>add_one</em> has a body of type
<strong><code>void</code></strong>, when the function prototype claims that the function
returns a <strong><code>i32</code></strong>, and no return statement can be encountered inside
the function, thus the compiler returns the following error.</p>
<pre><code class="language-error">Error : incompatible types i32 and void
 --&gt; main.yr:(3,29)
 3  ┃ def add_one (x : i32)-&gt; i32 {
    ╋                             ^
    ┃ Note : 
    ┃  --&gt; main.yr:(5,1)
    ┃  5  ┃ }
    ┃     ╋ ^
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="print.html#scope-declaration" id="scope-declaration"><h2>Scope declaration</h2></a>
<p>A scope is also the opening of a local module, in which declaration
can be made. These declarations can be other functions, structures,
classes, enumeration, etc. The declarations made inside a scope have
no access to the local variables defined in the function. Such access
is possible with the use of closures (<em>cf.</em> <a href="https://gnu-ymir.github.io/Documentations/en/functions">Function
advanced</a>),
but this is not be presented inside this chapter.</p>
<pre><code class="language-ymir">def foo () {
    import std::io;	 // imporation is local to foo
    let x = 12;
    {
    def bar () -&gt; i32 {
        println (x);
        12
    }
    println (x + bar ());
    }
    
    // bar is not accessible anymore
    bar (); // does not compile
}

def main () {
    foo ();
    
    bar ();
    println (&quot;In the main function !&quot;);
}
</code></pre>
<p><br></p>
<p>In the above example, the <strong><code>bar</code></strong> function is available in the scope
opened at line <strong>4</strong>, until its end at line <strong>10</strong>. For that reason,
it is also not available inside the <strong><code>main</code></strong> function. Moreover, the
<em>import statement</em> made at line <strong>2</strong> (importing the <strong><code>println</code></strong>
function) is only available in the scope opened at line <strong>1</strong>, and for
that reason not available in the <strong><code>main</code></strong> function. For these
reasons, the above example contains five errors, that are thrown by
the compiler.</p>
<pre><code class="language-error">Error : undefined symbol x
 --&gt; main.yr:(6,15)
 6  ┃ 	    println (x);
    ╋ 	             ^

Error : undefined symbol bar
 --&gt; main.yr:(9,15)
 9  ┃ 	println (x + bar ());
    ╋ 	             ^^^

Error : undefined symbol bar
 --&gt; main.yr:(13,5)
13  ┃     bar (); // does not compile
    ╋     ^^^

Error : undefined symbol bar
 --&gt; main.yr:(19,5)
19  ┃     bar ();
    ╋     ^^^

Error : undefined symbol println
 --&gt; main.yr:(20,5)
20  ┃     println (&quot;In the main function !&quot;);
    ╋     ^^^^^^^


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>Functions are not modules, this way of defining is used to define
private symbols only, in a future chapter we will see a way to define
public symbols available for other functions, and foreign modules
(<em>cf.</em>
<a href="https://gnu-ymir.github.io/Documentations/en/modules/">Modules</a>).</p>
<a class="header" href="print.html#uniform-call-syntax" id="uniform-call-syntax"><h2>Uniform call syntax</h2></a>
<p>The <em>uniform call syntax</em> is a syntax that allows to call a function
with the dot operator <strong><code>.</code></strong>. The <em>uniform call syntax</em> places the
first parameter of the function at the left of the dot
operation, and the rest of the arguments of the function after the
right operand as a list of expressions separated by comas enclosed
inside parentheses.</p>
<pre><code class="language-grammar">ufc := expression '.' expression '(' (expression (',' expression)*)? ')'
</code></pre>
<p>This syntax is used to perform continuous data processing and to make
the source code easier to read. This syntax is named <em>uniform call
syntax</em> because it is similar to the the syntax used to call methods
on class objects
(<em>cf.</em> <a href="https://gnu-ymir.github.io/Documentations/en/objects/">Objects</a>).</p>
<pre><code class="language-ymir">import std::io

def plusOne (i : i32) -&gt; i32 
    i + 1

def plusTwo (i : i32) -&gt; i32
    i + 2
    
def main () {
    let x = 12;
    x.plusOne ()
     .plusTwo ()
     .println ();	 	 
}	
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>15
</code></pre>
<p><br></p>
<p>The <em>uniform call syntax</em> can also be useful to define equivalent of
methods on structures. Because structures are presented in a future
chapter, we do not present this possibility here.</p>
<a class="header" href="print.html#control-flows" id="control-flows"><h1>Control flows</h1></a>
<p>When writing a program, the ability to decide to execute part of the
code conditionally, or to repeat part of the code, is a basic scheme
that is necessary.</p>
<a class="header" href="print.html#if-expression" id="if-expression"><h2>If expression</h2></a>
<p>An <strong><code>if</code></strong> expression is a control flow allowing to branch into the
program code by making decisions based on conditions. An <code>else</code> can be
placed after an <em>if</em> expression, to execute a part of code, if the
condition of the <em>if</em> expression is not met. The syntax of the <em>if
expression</em> is presented in the following code block.</p>
<pre><code class="language-grammar">if_expression := 'if' expression expression ('else' expression)?
</code></pre>
<p><br></p>
<p>The following source code present a basic utilization of the <em>if expression</em>.</p>
<pre><code class="language-ymir">def main () {
    let x = 5;
    
    if x &lt; 5 {
       println (&quot;X is lower than 5&quot;);
    } else if (x == 5) { // parentheses are optional
      println (&quot;X is exactly 5&quot;);
    } else {
      println (&quot;X is higher than 5&quot;);
    }
}
</code></pre>
<p><br></p>
<p>The value of an <em>if expression</em> is computed by the block of code that
is executed when branching on the condition. Each branch of the
<strong><code>if</code></strong> expression must have a value of the same type, otherwise an
error is returned by the compiler. The value of an <strong><code>if</code></strong>, can of
course be of type <strong><code>void</code></strong>.</p>
<pre><code class="language-ymir">def main () {
    let condition = true;
    let x = if condition {
        5 
    } else {
        7
    };
}
</code></pre>
<p><br></p>
<p>If there is a possibility for the program to enter none of the branch
of the <em>if expression</em>, then the value of the whole <em>if expression</em> is
of type <strong><code>void</code></strong>. For example, in the following source code, the
variable condition can be either <strong><code>true</code></strong> or <strong><code>false</code></strong>, leading to
the possibility for the <em>if expression</em> defined at line <strong>5</strong> to be
never entered, and to the possibility for that the value of <strong><code>x</code></strong> to
be never set.</p>
<pre><code class="language-ymir">def foo () -&gt; bool { // ... } // return a bool value

def main () {
    let condition = foo ();
    let x = if condition { // the condition can be false
        5 
    }; // and then the expression has no value
       // but the variable x cannot be of type void
}
</code></pre>
<p>Errors:</p>
<pre><code class="language-error">Error : incompatible types void and i32
 --&gt; main.yr:(5,10)
 5  ┃ 	let x = if condition { // the condition can be false
    ╋ 	        ^^
    ┃ Note : 
    ┃  --&gt; main.yr:(6,3)
    ┃  6  ┃ 		5 
    ┃     ╋ 		^
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<a class="header" href="print.html#loops" id="loops"><h2>Loops</h2></a>
<p>In <em>Ymir</em>, there are three kinds of loops: <code>loop</code>, <code>while</code> and <code>for</code>.</p>
<a class="header" href="print.html#infinite-repetitions" id="infinite-repetitions"><h3>Infinite repetitions</h3></a>
<p>The keyword <strong><code>loop</code></strong> is used to specify that a scope must be
repeated endlessly. The syntax of the <strong><code>loop</code></strong> expression is the
following:</p>
<pre><code class="language-grammar">loop_expression := 'loop' expression
</code></pre>
<p><br></p>
<p>In the following example, the program will never exit, and will print,
an infinite number of times, the string <code>&quot;I will be printed an infinite number of times&quot;.</code></p>
<pre><code class="language-ymir">def main () {
    loop { // the loop will never exit
         println (&quot;I will be printed an infinite number of times&quot;);
    }
}
</code></pre>
<p><br></p>
<p>A loop can be used to repeat an action until it succeeds, e.g. waiting
for the end of a thread, or waiting for incoming network connections,
etc.  The keyword <strong><code>break</code></strong> is used to stop a loop. A <em>break
statement</em> is associated with a value, which is following the
keyword. The value of a loop is defined by the value given by the
<em>break statement</em>. Every <em>break statement</em> in a <em>loop</em> must share the
same type. A loop can evidently be of type <strong><code>void</code></strong>.</p>
<pre><code class="language-ymir">import std::io

def main () {
    let mut counter = 0;
    
    let result = loop { 
        counter += 1;
        if counter == 10 {
            break counter + 1; // stop the loop and set its value to 'counter + 1'
        }
    };
    println (&quot;Result : &quot;, result);}

</code></pre>
<p>Results:</p>
<pre><code>Result : 11
</code></pre>
<p><br></p>
<a class="header" href="print.html#loop-while-condition-is-met" id="loop-while-condition-is-met"><h3>Loop while condition is met</h3></a>
<p>The keyword <strong><code>while</code></strong> creates a loop, which repeats until a
condition is no longer satisfied. As for the <em>loop</em>, it can be broken
with the keyword <strong><code>break</code></strong>. Unlike <em>loop</em> the value of a while loop
is always of type <strong><code>void</code></strong>, because it is impossible to ensure that
the <em>while</em> is entered at all. The <em>break statement</em> must follow that
rule, and break only with values of type <strong><code>void</code></strong>.
<em>Contribution:</em>
It is planned to add the possibility to write an <em>else</em> after a <em>while
loop</em> to give a value to the <em>while loop</em> when it is not entered.</p>
<p>The grammar of the <em>while</em> loop is presented, in the following code
block.</p>
<pre><code class="language-grammar">while_expression := 'while' expression expression
</code></pre>
<p><br></p>
<p>The following example, present an utilization of a <em>while</em> loop, where
the loop iterates 10 times, while the value of <strong><code>i</code></strong> is lower than
<strong>10</strong>.</p>
<pre><code class="language-ymir">import std::io

def main () {
    let mut i = 0;
    while i &lt; 10 {
        i += 1;	
    };
    
    println (&quot;I is : &quot;, i);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>I is : 10
</code></pre>
<p><br></p>
<a class="header" href="print.html#iterate-over-a-value" id="iterate-over-a-value"><h3>Iterate over a value</h3></a>
<p>The last type of loop is the <em>for loop</em> defined with the keyword
<strong><code>for</code></strong>. Like for the <em>while loop</em> the value of a <em>for loop</em> is
always <strong><code>void</code></strong> as it is impossible to garantee that the loop is
entered even once. The <em>for loop</em> iterates over an iterable
type. Primitive iterable types are ranges, tuple, slices and static
arrays.</p>
<pre><code class="language-grammar">for_expression := 'for' ('(' var_decls ')' | var_decls) 'in' expression expression

var_decls := var_decl (',' var_decl)
var_decl := (decorator)* identifier (':' type)?

decorator := 'ref' | 'mut' | 'dmut'
</code></pre>
<p><br></p>
<p><strong>1) Iteration over a range.</strong> In the following example, the <em>for
loop</em> is used to iterate over three ranges. The first loop at line
<strong>4</strong>, iterates between <strong>0</strong> and <strong>8</strong> (not included), by a step of
<strong>2</strong>. The second loop iterate between the value <strong>10</strong> and <strong>0</strong> (not
included) with a step of <strong>-1</strong>. The third loop iterates between the
value <strong>1</strong> and <strong>6</strong> (included this time).</p>
<pre><code class="language-ymir">import std::io
    
def main () {
    for i in (0 .. 8).step_by (2) {
        println (i);
    }	
    
    for i in 10 .. 0 {
        println (i);
    }
    
    for i in 1 ... 6 {
        println (i);
    }
}
</code></pre>
<p><br></p>
<p><strong>2) iteration over slices and static arrays.</strong> Slices are iterable
types. They can be iterated using one or two variables. When only one
variable is used, it is associated with the values contained inside
the slice. When two variable are used, the first variable is
associated to the current iteration index, and the second variable to
the values contained inside the slice. Static array iteration works
the same.</p>
<pre><code class="language-ymir">import std::io;

def main () {
    let a = [10, 11, 12];
    for i in a {
        print (i, &quot; &quot;);
    }
    
    println (&quot;&quot;);
    for i, j in a {
        print (i, &quot;-&gt; &quot;, j, &quot; &quot;);
    }
    println (&quot;&quot;);
}
</code></pre>
<p>Results:</p>
<pre><code>10 11 12 
0-&gt; 10 1-&gt; 11 2-&gt; 12
</code></pre>
<p><br></p>
<p><em>Contribution</em>: the iteration by reference over mutable slice, and
mutable static arrays is currently under development.</p>
<p><strong>3) iteration over tuples.</strong> Tuple are iterable types. But unlike slice,
or range the <em>for loop</em> is evaluated at compilation time. The tuple
can be iterated using only one variable, that is associated to the
values contained inside the tuple.</p>
<pre><code class="language-ymir">import std::io 

def main () {
    let x = (1, 'r');
    for i in x { 
        println (i);
    }
    
    // Is equivalent to 
    println (x.0);
    println (x.1);
}
</code></pre>
<p><br></p>
<p>One may note that the type of the variable <strong><code>i</code></strong> in the <em>for loop</em>
of the above example changes from one iteration to another, being of
type <strong><code>i32</code></strong> at first iteration and then of type <strong><code>c32</code></strong>. For that
reason, the <em>for loop</em> is not really dynamic, but flattened at
compilation time. This does not change anything from a user
perspective, but is worth mentioning, to avoid miscomprehension of
static type system, there is no hidden dynamicity here.</p>
<a class="header" href="print.html#assertion" id="assertion"><h2>Assertion</h2></a>
<p>The expression <em>assert</em> is an expression that verify the validity of a
condition and throws an exception if the condition is false. Error are
presented in the chapter <a href="https://gnu-ymir.github.io/Documentations/en/errors/main.html">Error
Handling</a>,
thus no detail are given in this section.</p>
<pre><code class="language-ymir">def foo (i : i32) throws &amp;AssertError 
{
    assert (i &lt; 10, &quot;i must be lower than 10&quot;)
}

def main () 
    throws &amp;AssertError
{
    foo (11);
}
</code></pre>
<a class="header" href="print.html#operator-priority" id="operator-priority"><h1>Operator priority</h1></a>
<p>The following table present the precedence of the operators, and
literals. This table presents the priority of the operators, but does
not specify how the operators are used, and their specific syntax. For
example, there are unary operators, and binary operators, that
require respectively one and two operands, but that is not specified
in the table.</p>
<table><thead><tr><th> Priority </th><th> Description </th><th> Operators </th><th> Comments </th></tr></thead><tbody>
<tr><td> 0 </td><td> Assignement operators </td><td> <code>=</code> <code>/=</code> <code>-=</code> <code>+=</code> <code>*=</code> <code>%=</code> <code>~=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> </td><td> </td></tr>
<tr><td> 1 </td><td> Logical Or </td><td> <code>||</code> </td><td> </td></tr>
<tr><td> 2 </td><td> Logical And </td><td> <code>&amp;&amp;</code> </td><td> </td></tr>
<tr><td> 3 </td><td> Comparison operators </td><td> <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code> <code>!=</code> <code>==</code> <code>of</code> <code>is</code> <code>in</code> <code>!of</code> <code>!is</code> <code>!in</code> </td><td> Cannot be chained </td></tr>
<tr><td> 4 </td><td> Range operators </td><td> <code>..</code> <code>...</code> </td><td> </td></tr>
<tr><td> 5 </td><td> Bitshift operators </td><td> <code>&lt;&lt;</code> <code>&gt;&gt;</code> </td><td> </td></tr>
<tr><td> 6 </td><td> Bit operators </td><td> <code>|</code> <code>^</code> <code>&amp;</code> </td><td> Warning there is no priority over these operators (or and and) </td></tr>
<tr><td> 7 </td><td> Additive operators </td><td> <code>+</code> <code>~</code> <code>-</code> </td><td> <code>~</code> is the concatenation operator </td></tr>
<tr><td> 8 </td><td> Multiplicative operators </td><td> <code>*</code> <code>/</code> <code>%</code> </td><td> </td></tr>
<tr><td> 9 </td><td> Power operator </td><td> <code>^^</code> </td><td> </td></tr>
<tr><td> 10 </td><td> Unary operators </td><td> <code>-</code> <code>&amp;</code> <code>*</code> <code>!</code> </td><td> Always prefixed </td></tr>
<tr><td> 11 </td><td> Option operator </td><td> <code>?</code> </td><td> Always postfixed </td></tr>
<tr><td> 12 </td><td> Keyword and Scope operators </td><td> <code>{</code> <code>if</code> <code>while</code> <code>assert</code> <code>break</code> <code>do</code> <code>for</code> <code>match</code> <code>let</code> <code>return</code> <code>fn</code> <code>dg</code> <code>loop</code> <code>throw</code> <code>__version</code> <code>__pragma</code> <code>with</code> <code>atomic</code> </td><td> This operators have a specific syntax that must be closed, to be completed </td></tr>
<tr><td> 13 </td><td> Postfix operators </td><td> <code>.</code> <code>(</code> <code>[</code> <code>:.</code> <code>#[</code> <code>#(</code> <code>#{</code> </td><td> <code>(</code> <code>[</code> <code>#{</code> <code>#[</code> <code>#(</code> must be closed by a balanced <code>]</code>, <code>)</code> or <code>}</code> to be completed </td></tr>
<tr><td> 14 </td><td> Path operator </td><td> <code>::</code> </td><td> </td></tr>
<tr><td> 15 </td><td> Literal operators </td><td> <code>(</code> <code>!</code> <code>[</code> <code>|</code> <code>cast</code> <code>move</code> </td><td> In that case <code>(</code> <code>[</code> <code>|</code> start a new expression, <code>move</code>  and <code>|</code> start a lambda literal, <code>(</code> a tuple, or a 0 priority expression, <code>[</code> a slice or array literal, <code>!</code> a template call</td></tr>
<tr><td> 16 </td><td> Decorated expression </td><td> <code>ref</code> <code>const</code> <code>mut</code> <code>dmut</code> <code>cte</code> </td><td> </td></tr>
<tr><td> 17 </td><td> Anything else </td><td> </td><td> A variable, a literal, etc. </td></tr>
</tbody></table>
<a class="header" href="print.html#alias-and-references" id="alias-and-references"><h1>Alias and References</h1></a>
<p>The alias and reference is one of the most important characteristics
of the <em>Ymir</em> language, which allows it to give guarantees on the
mutability of the data, and the explicit movement of the memory. It is
important to understand how memory works in <em>Ymir</em>, in order to
understand the error message you might get when you try to move data
from one variable to another.</p>
<p><em>Ymir</em> is a high level programming language, thus there is no need to
worry about memory management (memory leaks), the language using a
garbage collector. However, in terms of mutability and access rights,
the language provides an expressive system for managing memory
movements.</p>
<a class="header" href="print.html#standard-and-aliasable-types" id="standard-and-aliasable-types"><h2>Standard and Aliasable types</h2></a>
<p>In <em>Ymir</em>, there are two types, standard types and aliasable
types. A value whose type is a standard type, can be copied without
the need of explicitly inform the compiler. The standard types are all
primitive scalar types. On the other hand, aliasable types are types
that have borrowed data, which will not be copied unless it is
explicitly written into the code, to avoid performance loss.</p>
<p>To understand how data is represented in a program, you need to know
the difference between heap and stack. The stack is a space allocated
by the program when a function is entered, which is released when the
function is exited. On the other hand, the heap is a space that is
allocated when certain instructions in the program require it, such as
allocating a new slice, allocating  a new object instance, and so on.</p>
<p>When a slice is allocated, all its data is stored in the heap, and the
address of this data is stored in the stack, where the variables are
located. The following figure shows the data representation for this
program:</p>
<pre><code class="language-ymir">def foo () {
    let x = [1, 2, 3];
}
</code></pre>
<p><br></p>
<p><img src="https://gnu-ymir.github.io/Documentations/en/advanced/memory_x_foo.png" alt="drawing" height="500" style="display: block; margin-left: auto;  margin-right: auto;"></p>
<a class="header" href="print.html#mutability-level" id="mutability-level"><h2>Mutability level</h2></a>
<p>We define the level of mutability as the deepest level of the type
that is mutable. An example of a mutability level is shown in the
following table:</p>
<table><thead><tr><th> Type </th><th> Level </th></tr></thead><tbody>
<tr><td> mut [i32] </td><td> 1 </td></tr>
<tr><td> [i32] </td><td> 0 </td></tr>
<tr><td> mut [mut i32] </td><td> 2 </td></tr>
<tr><td> dmut [[[i32]]] </td><td> 4 </td></tr>
</tbody></table>
<p>This is mainly used to ensure that the borrowed data is not changed by
another variable in a foreign part of the program. The users have full
control over the data they have created. The example below shows
how the mutability level is used to ensure that the content of a
table is never changed.</p>
<pre><code class="language-ymir">import std::io

def main () 
    throws &amp;OutOfArray
{
    let mut x = [1, 2, 3];
    x = [2, 3, 4];

    x [0] = 8;
}
</code></pre>
<p><br></p>
<p>The type of <strong><code>x</code></strong> in the above example is <strong><code>mut [i32]</code></strong>. The
mutability of the internal part of the slice (<strong><code>i32</code></strong> value) is not
specified. The compiler, for security reasons, infered it as
immutable. The line <strong>5</strong> of the previous example is accepted, because
the variable <strong><code>x</code></strong> is mutable, however, the value pointed by the
slice contained in <strong><code>x</code></strong> is not. For that reason the line <strong>9</strong> is
not accepted and the compiler returns the following error.</p>
<pre><code class="language-error">Error : left operand of type i32 is immutable
 --&gt; main.yr:(7,7)
 7  ┃     x [0] = 8;
    ╋       ^


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>If the mutability level defines the write permission of every data, it
is assumed that every parts of the code that have access to a give
value have read permission on it. For that reason, in the previous
example, even if writting into <strong><code>x [0]</code></strong> is not permitted, reading
its value is allowed.</p>
<a class="header" href="print.html#deep-mutability" id="deep-mutability"><h3>Deep mutability</h3></a>
<p>Earlier we introduced the keyword <strong><code>dmut</code></strong>, this keyword is used to
avoid a very verbose type statement, and defines that every subtype
are mutable. This keyword is applicable to all types, but will only
have a different effect from the <strong><code>mut</code></strong> decorator on aliasable
types. The following table gives an example of an slice type, using
the keyword <code>dmut</code> :</p>
<table><thead><tr><th> Type </th><th> Verbose equivalent </th></tr></thead><tbody>
<tr><td> dmut [i32] </td><td> mut [mut i32] </td></tr>
<tr><td> dmut [[[i32]]] </td><td> mut [mut [mut [mut i32]]] </td></tr>
</tbody></table>
<p>If we come back to our previous example, and change the type of the
variable <strong><code>x</code></strong>, and use the keyword <strong><code>dmut</code></strong>. The variable <strong><code>x</code></strong>
now borrows mutable datas, that can be modified, thus the expression
at line <strong>9</strong> is accepted.</p>
<pre><code class="language-ymir">import std::io

def main () 
    throws &amp;OutOfArray
{
    let dmut x = [1, 2, 3];
    x = [2, 3, 4];
    
    x [0] = 8;
}
</code></pre>
<a class="header" href="print.html#const-keyword" id="const-keyword"><h3>Const keyword</h3></a>
<p>The <strong><code>const</code></strong> keyword is the perfect opposite of the <strong><code>dmut</code></strong>
keyword. This keyword has no interest when defining types directly
(because they are immutable by default), but coupled with the keyword
<strong><code>typeof</code></strong>, it can transform a mutable type into a immutable type.</p>
<pre><code class="language-ymir">import std::io;

def main () {
    let mut x = 12;
    println (typeof (x)::typeid);
    println ((const typeof (x))::typeid);
}
</code></pre>
<p>Results:</p>
<pre><code>mut i32
i32
</code></pre>
<a class="header" href="print.html#string-literal" id="string-literal"><h3>String literal</h3></a>
<p>Strings literal, unlike slice literals, are in the text segment of the
program (read-only part of a program). This means that the type of a
literal string is <strong><code>[c32]</code></strong> (or <strong><code>[c8]</code></strong> if the suffix <code>s8</code> is
specified), while the type of a literal array (of <code>i32</code> for example)
is <strong><code>mut [mut i32]</code></strong>. For that reason, it impossible to borrow the
data into a deeply mutable variable.</p>
<pre><code class="language-ymir">import std::io

def main () {
    let dmut x = &quot;Try to make me mutable !?&quot;;
}
</code></pre>
<p><br></p>
<p>The compiler returns an error. This error means that the mutability
level of the right operand is <strong>1</strong>, here <code>mut [c32]</code>, (the reference
of the array is mutable but not its content), and the code try to put
the reference inside a variable of mutability level <strong>2</strong>, that is to
say of type <code>mut [mut c32]</code>. If this was allowed the variable <code>x</code>
would have the possibility to change data that has been marked as
immutable at some point of the program, so the compiler does not allow
it, and returns the following error.</p>
<pre><code class="language-error">Error : discard the constant qualifier is prohibited, left operand mutability level is 2 but must be at most 1
 --&gt; main.yr:(4,11)
 4  ┃ 	let dmut x = &quot;Try to make me mutable !?&quot;;
    ╋ 	         ^
    ┃ Note : 
    ┃  --&gt; main.yr:(4,15)
    ┃  4  ┃ 	let dmut x = &quot;Try to make me mutable !?&quot;;
    ┃     ╋ 	             ^
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<a class="header" href="print.html#memory-borrowing" id="memory-borrowing"><h2>Memory borrowing</h2></a>
<p>When you want to make a copy of a value whose type is aliasable, you
must tell the compiler how you want to make the copy. There are four
ways to move or reference memory, which are provided with the four
keywords <code>ref</code>, <code>alias</code>, <code>copy</code> and <code>dcopy</code>. The following chapters
presents these keywords, and the semantic associated to them.</p>
<a class="header" href="print.html#reference" id="reference"><h1>Reference</h1></a>
<p>The keyword**<code>ref</code>** is a keyword that is placed before the
declaration of a variable. It is used to refer to a value, which is
usually borrowed from another variable. They are performing similar
operation as
<a href="https://gnu-ymir.github.io/Documentations/en/primitives/types.html#pointers">Pointers</a>,
with the difference that they does not need to be dereferenced (this
is done automatically), and pointer arithmetics is not possible with
references. In <em>Ymir</em> references are always set, and are always set
from another variable, hence they are way safer than pointers, and
must be prefered to them when possible.</p>
<pre><code class="language-ymir">def foo () {
    let x = [1, 2, 3];
    let ref y = ref x;
    //          ^^^    
    // Try to remove the keyword ref.
}
</code></pre>
<p><br></p>
<p>The above program can be represented in memory as shown in the
following figure.</p>
<p><br></p>
<p>&lt;img src=&quot;https://gnu-ymir.github.io/Documentations/en/advanced/memory_x__ref_y_foo.png&quot; alt=&quot;drawing&quot; height=&quot;500&quot;, style=&quot;display: block; margin-left: auto;  margin-right: auto;&quot;&gt;</p>
<p><br></p>
<p>In this figure, one can note that <strong><code>y</code></strong>, is a pointer to x, which
can be used as if it was directly <strong><code>x</code></strong>. This means that <strong><code>y</code></strong>
must have the same mutability properties (or lower) as <strong><code>x</code></strong>. And
that if <strong><code>x</code></strong> is mutable, changing the value of <strong><code>y</code></strong> would also
change <strong><code>x</code></strong>.</p>
<p>A first example of reference is presented in the following source
code. In this example, a mutable variable <strong><code>x</code></strong> contains a value of
type <strong><code>i32</code></strong>. This value is placed on the stack, as it is not a
aliasable type. Then a variable <strong><code>y</code></strong> is constructed as a reference
of the variable <strong><code>x</code></strong>. Modifying <strong><code>y</code></strong> in the following example, also
modifies <strong><code>x</code></strong>.</p>
<pre><code class="language-ymir">def main ()
    throws &amp;AssertError
{
    let mut x = 12; // place a value of type i32 and value 12 on the stack
    let ref mut y = ref x; // create a reference of x
    y = 42; // modify the value pointed by the reference
    assert (x == 42);
}
</code></pre>
<p><br></p>
<p>A more complexe example is presented in the following source code. In
this example, a deeply mutable array <strong><code>x</code></strong> is created. This array is
a reference on borrowed data in the heap. A deeply mutable reference
<strong><code>y</code></strong> is the, made on that variable <strong><code>x</code></strong>, which is allowed
because <strong><code>x</code></strong> is also deeply mutable and the mutability level of
<strong><code>x</code></strong> and <strong><code>y</code></strong> are the same. When changing the value of <strong><code>y</code></strong>
(here the reference of the slice), it does not only change the
reference of <strong><code>y</code></strong> but also the reference of <strong><code>x</code></strong>.</p>
<pre><code class="language-ymir">def main () {
    let mut x : [mut i32] = [1, 2, 3];
    let ref mut y : [mut i32] = ref x;
    y = [7, 8, 9]; // modify the value pointed by the reference (in the stack)
    y [0] = 89; // modify the value on the heap
    assert (x == [89, 8, 9]); 
}
</code></pre>
<a class="header" href="print.html#reference-as-function-parameter" id="reference-as-function-parameter"><h2>Reference as function parameter</h2></a>
<p>A parameter of a function can be a reference. As with the local
variable, when a value is passed to it, you must tell the compiler
that you understand that you are passing the value by reference, and
accept the side effects it may have on your values.</p>
<pre><code class="language-ymir">import std::io

def foo (ref mut x : i32) {
    x = 123;
}

def main () {
    let mut x = 12;
    //  ^^^
    // Try to remove the mut
    foo (ref x);
    //   ^^^
    // Try to remove the ref
    println (x); 
}
</code></pre>
<p><br></p>
<p>The following figure shows the memory status of the previous code:</p>
<p><img src="https://gnu-ymir.github.io/Documentations/en/advanced/memory_x_main_ref_x_foo.png" alt="drawing" width="450" style="display: block; margin-left: auto;  margin-right: auto;"></p>
<p>The keyword <code>ref</code> is not always associated with a mutable variable, it
can be used to pass a complex type to a function more efficiently,
when you don't want to make a complete copy, which would be much less
efficient. In this case, you should always specify that you pass the
variable by reference, to distinguish it from the function that passes
the variable directly by value. In practice, due to the existence of
aliasable types, which will be discussed in the next chapter, you will
never gain anything by doing this.</p>
<pre><code class="language-ymir">import std::io

def foo ( x : i32) {
//       ^
// Try to add mut here
    println (&quot;By value : &quot;, x);
}

def foo (ref x : i32) {
    println (&quot;By reference : &quot;, x);
}

def main () {
    let x = 89;
    foo (x);
    foo (ref x);
}
</code></pre>
<p>Results:</p>
<pre><code>By value : 89
By reference : 89
</code></pre>
<p><br></p>
<p>If you have done the exercise, and added the keyword <strong><code>mut</code></strong> to the
signature of the first function <strong><code>foo</code></strong>, you should get the following
error:</p>
<pre><code class="language-error">Error : a parameter cannot be mutable, if it is not a reference
 --&gt; main.yr:(3,15)
 3  ┃ def foo (mut  x : i32) {
    ╋               ^

</code></pre>
<p><br></p>
<p>This error means that the type of <strong><code>x</code></strong> is not aliasable, so if it is not
a reference, marking it as mutable will have no effect on the program,
so the compiler does not allow it.</p>
<a class="header" href="print.html#reference-as-a-value" id="reference-as-a-value"><h2>Reference as a value</h2></a>
<p>A reference is not a type, it is only a kind of variable, you cannot
store references in subtypes (for example, you cannot make an array of
references, or a tuple containing a reference to a value). This means
that with the following code, you should will get an error.</p>
<pre><code class="language-ymir">def main () {
    let x = 12;
    let y = (10, ref x);
}
</code></pre>
<p><br> The following error means that the source code intended to create
a reference on a variable, but the compiler will not make it, as it
has no interest and will be immediately dereferenced to be stored in
the tuple value.</p>
<pre><code class="language-error">Warning : the creation of ref has no effect on the left operand
 --&gt; main.yr:(3,22)
 3  ┃     let y = (10, ref x);
    ╋                      ^


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="print.html#reference-as-function-return" id="reference-as-function-return"><h2>Reference as function return</h2></a>
<p>You may be skeptical about the interest of returning a reference to a
variable, and we agree with you. That is why, it is impossible to
return a reference to a variable as a function return value.</p>
<pre><code class="language-ymir">import std::io

def foo () -&gt; ref i32 {
    let x = 12;
    ref x
}

def main () {
    let ref y = ref foo (); // x would no longer exists
    println (y); // and a seg fault would be raised, when using the reference
}
</code></pre>
<p><br></p>
<p>With the above source code, the compiler return this fairly straightforward error.</p>
<pre><code class="language-error">Error : cannot return a reference type
 --&gt; main.yr:(3,19)
 3  ┃ def foo () -&gt; ref i32 {
    ╋                   ^^^

</code></pre>
<a class="header" href="print.html#alias" id="alias"><h1>Alias</h1></a>
<p>All types that containing a pointer to data in the heap (or the stack)
are aliasable types. An aliasable type cannot be implicitly copied,
nor can it be implicitly referenced, for performance and security
reasons respectively. There are mainly three aliasable types, arrays
(or slices, there is no difference in <em>Ymir</em>), pointers, and
objects. Structures and tuples containing aliasable types are also
aliasable.</p>
<p>The keyword <strong><code>alias</code></strong> is used to inform the compiler that the used
understand that the data borrowed by a variable (or a value) will
borrowed by another values.</p>
<pre><code class="language-ymir">import std::io

def main () {
    let mut x : [mut i32] = [1, 2, 3];
    let mut y : [mut i32] = alias x; // allow y to borrow the value of x
    //                      ^^^^^
    // Try to remove the alias
    println (y);
}
</code></pre>
<p><br></p>
<p>This source code can be represented in memory by the following figure.</p>
<p><img src="https://gnu-ymir.github.io/Documentations/en/advanced/memory_x_alias_main.png" alt="drawing" height="500"  style="display: block; margin-left: auto;  margin-right: auto;"></p>
<p>The alias keyword is only mandatory when the variable that will borrow
the data is mutable and may impact the value. It is obvious that one
cannot borrow immutable data from a variable that is mutable. For
example, the compiler must return an error on the following code.</p>
<pre><code class="language-ymir">import std::io

def main () {
    let x = [1, 2, 3];
    let mut y : [mut i32] = alias x; // try to borrow immutable data in deeply mutable variable y  
    //                      ^^^^^
    // Try to remove the alias
    println (y);
}
</code></pre>
<p><br>
Errors:</p>
<pre><code class="language-error">Error : discard the constant qualifier is prohibited, left operand mutability level is 2 but must be at most 1
 --&gt; main.yr:(5,13)
 5  ┃     let mut y : [mut i32] = alias x; // try to borrow immutable data in deeply mutable variable y  
    ╋             ^
    ┃ Note : 
    ┃  --&gt; main.yr:(5,29)
    ┃  5  ┃     let mut y : [mut i32] = alias x; // try to borrow immutable data in deeply mutable variable y  
    ┃     ╋                             ^^^^^
    ┗━━━━━┻━ 

Error : undefined symbol y
 --&gt; main.yr:(8,14)
 8  ┃     println (y);
    ╋              ^


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>However, if the variable that will borrow the data is not mutable,
there is no need to add the keyword <strong><code>alias</code></strong>, and the compiler will
create an implicit alias, which will have no consequences.</p>
<pre><code class="language-ymir">import std::io

def main () {
    let x = [1, 2, 3];
    let y = x; // implicit alias is allowed, 'y' is immutable
    println (y);
}
</code></pre>
<p><br></p>
<p>In the last example, <strong><code>y</code></strong> can be mutable, as long as its internal
values are immutable, i.e. its type is <code>mut [i32]</code>, you can change the
value of <strong><code>y</code></strong>, but not the values it borrows. There is no problem,
the values of <strong><code>x</code></strong> will not be changed, no matter what is done with
<strong><code>y</code></strong>.</p>
<pre><code class="language-ymir">import std::io

def main () {
    let x = [1, 2, 3];
    let mut y = x; 
    // y [0] = 9;
    // Try to add the above line 
    
    y = [7, 8, 9];
    println (y);
}
</code></pre>
<p><br></p>
<p>You may have noticed that even though the literal is actually the
element that creates the data, we do not consider it to be the owner
of the data, so the keyword <strong><code>alias</code></strong> is implied when it is literal. We
consider the data to have an owner only once it has been assigned to a
variable.</p>
<p>There are other kinds of <code>alias</code> that are implicitly allowed, such
as code blocks or function calls. Those are implicit because
the alias is already made within the value of these elements.</p>
<pre><code class="language-ymir">import std::io

def foo () -&gt; dmut [i32] {
    let dmut x = [1, 2, 3];
    alias x // alias is done here and mandatory
}

def main ()
    throws &amp;AssertError
{
    let x = foo (); // no need to alias, it must have been done in the function
    assert (x == [1, 2, 3]);
}
</code></pre>
<p><br></p>
<a class="header" href="print.html#alias-a-function-parameter" id="alias-a-function-parameter"><h2>Alias a function parameter</h2></a>
<p>As you have noticed, the keyword <strong><code>alias</code></strong>, unlike the keyword <code>ref</code>,
does not characterize a variable. The type of a variable will indicate
whether the type should be passed by alias or not, so there is no
change in the definition of the function. When the type of a parameter
is an aliasable type, this parameter can be mutable without being a
reference.</p>
<pre><code class="language-ymir">import std::io

// The function foo will be allowed to modify the internal values of y
def foo (mut y : [mut i32])
    throws &amp;OutOfArray
{
    y [0] = y [1];
    y = [8, 3, 4]; // has no impact on the x of main,
    // y is a reference to the data borrowed not to the variable x itself
}

def main ()
    throws &amp;OutOfArray, &amp;AssertError
{
    let dmut x = [1, 2, 3];
    foo (alias x);
    //   ^^^^^
    // Try to remove the alias
    assert (x == [2, 2, 3]);
}
</code></pre>
<p><br></p>
<p>As with the variable, if the function parameter cannot affect the
values that are borrowed, the alias keyword is not required.</p>
<pre><code class="language-ymir">import std::io

def foo (x : [i32]) {
    println (x); // just reads the borrowed data, but doesn't modify them
}

def main () {
    let dmut x = [1, 2, 3];	
    foo (x); // no need to alias
}
</code></pre>
<p><br></p>
<a class="header" href="print.html#alias-in-uniform-call-syntax" id="alias-in-uniform-call-syntax"><h3>Alias in <em>uniform call syntax</em></h3></a>
<p>We have seen in the function chapter, the <em>uniform call syntax</em>. This
syntax is used to call a function using the dot operator <strong><code>.</code></strong>, by
putting the first parameter of the function on the left of the
operation. When the first parameter is of an aliasable type, the first
argument must be aliased explicitely, leading to a strange and verbose
syntax.</p>
<pre><code class="language-ymir">let dmut a = [1, 2, 3];
(alias a).foo (12); // same a foo (alias a, 12);
</code></pre>
<p><br>
To avoid verbosity, we added the operator <strong><code>:.</code></strong>, to use the
<em>uniform call syntax</em> with an aliasable first parameter.</p>
<pre><code class="language-ymir">let dmut a = [1, 2, 3];
a:.foo (12); // same as foo (alias a, 12);
</code></pre>
<p><br></p>
<p>This operator is very usefull when dealing with classes, where the
<em>uniform call syntax</em> is mandatory, as we will see in chapter
<a href="https://gnu-ymir.github.io/Documentations/en/objects/class.html">Class</a>.</p>
<a class="header" href="print.html#special-case-of-struct-and-tuple" id="special-case-of-struct-and-tuple"><h2>Special case of struct and tuple</h2></a>
<p>In the chapter
<a href="https://gnu-ymir.github.io/Documentations/en/types/struct.html">Structure</a>
you will learn how to create a structure containing several fields of
different types. You have already learned how to make tuples. These
types are sometimes aliasable, depending on the internal type they
contain. If a tuple, or a structure, has a field whose type is aliasable,
then the tuple or structure is also aliasable.</p>
<p>The table below presents some examples of aliasable tuples :</p>
<table><thead><tr><th> Type </th><th> Aliasable </th><th> Reason </th></tr></thead><tbody>
<tr><td> (i32, i32) </td><td> false </td><td> i32 is not aliasable </td></tr>
<tr><td> ([i32],) </td><td> true </td><td> [i32] is a slice, and hence aliasable </td></tr>
<tr><td> ([i32], f64) </td><td> true </td><td> [i32] is a slice, and hence aliasable </td></tr>
<tr><td> (([i32], i32), f64) </td><td> true </td><td> [i32] is a slice, and hence aliasable </td></tr>
</tbody></table>
<p>In the introduction of this chapter we presented the notion of
<a href="https://gnu-ymir.github.io/Documentations/en/advanced/#mutability-level">Mutability
level</a>. One
can note that mutability level is not suitable for tuple, as aliasable
tuple are trees of type and not simply a list. However, this does not
change much, the compiler just check the mutability level of the inner
types of the tuple, recursively.</p>
<a class="header" href="print.html#copy-data-to-make-them-mutable" id="copy-data-to-make-them-mutable"><h1>Copy data to make them mutable</h1></a>
<p>Sometimes it is not possible to allow data to be borrowed by foreign
functions or variables. This can be due to the facts that data are
immutable for example. To solve this problem, <em>Ymir</em> provides two
keywords, <strong><code>copy</code></strong> and <code>dcopy</code>.</p>
<a class="header" href="print.html#copy" id="copy"><h2>Copy</h2></a>
<p>The <strong><code>copy</code></strong> keyword makes a copy of the first level of a value,
whose type is aliasable. This copy transform an immutable type into a
mutable one, by increasing its mutability level by one. The following
table shows some examples of the types of copied values :</p>
<table><thead><tr><th> Type </th><th> Type of copied value </th></tr></thead><tbody>
<tr><td> [i32] </td><td> mut [mut i32] </td></tr>
<tr><td> mut [i32] </td><td> mut [mut i32] </td></tr>
<tr><td> mut [[i32]] </td><td> mut [mut [i32]] </td></tr>
</tbody></table>
<p>An example of what can be achieved by <strong><code>copy</code></strong> keyword is shown in
the following code. The representation of the memory is also shown in
the figure underneath. In this example, the variable <strong><code>x</code></strong> is copied
and the result value is placed in the variable <strong><code>y</code></strong>. In this
example, each variable are borrowing different data placed on the
heap, whose values are equivalent.</p>
<pre><code class="language-ymir">import std::io
    
def main ()
    throws &amp;AssertError, &amp;OutOfArray
{
    let x = [1, 2, 3];
    let dmut y = copy x; // create a copy of x
    assert (x == y); // y and x have the same value, but at different location

    y [0] = 9; 
    assert (x == [1, 2, 3]); // modifying y does not affect x
    assert (y == [9, 2, 3]); // but still affects y
}
</code></pre>
<p><br></p>
<p>We can see from the figure below, that the variable <strong><code>y</code></strong> points to
data at a different location, from the data pointed by <strong><code>x</code></strong>. This
implies a new memory allocation, and a memory copy, that cost some cpu
time, and memory place. For that reason, copies are never hidden by
the language, and are made only when the keyword <strong><code>copy</code></strong> is placed
in the source code.</p>
<p><img src="https://gnu-ymir.github.io/Documentations/en/advanced/memory_x_copy_main.png" alt="drawing" height="500" style="display: block; margin-left: auto;  margin-right: auto;"></p>
<p><strong>Exercise :</strong> Modify <code>x</code> that is initialised with an imutable string literal :</p>
<pre><code class="language-ymir">import std::io

def main () 
    throws &amp;OutOfArray 
{
    let x = &quot;hello !&quot;;
    x [0] = 'H'; // Make this line work
    assert (x == &quot;Hello !&quot;);
}
</code></pre>
<div class="spoiler_head"> <strong>Correction</strong> (spoiler) : </div>
{%s%}
<pre class="language-" style="position: relative;" class="spoiler"><code class="lang-ymir">import std::io
<p>def main ()
throws &amp;OutOfArray, &amp;AssertError
{
let dmut x = copy &quot;hello !&quot;;
x [0] = 'H'; // Well done
assert (x == &quot;Hello !&quot;);
}
</code></pre>
{%ends%}</p>
<a class="header" href="print.html#deep-copy" id="deep-copy"><h2>Deep copy</h2></a>
<p>The deep copy will make a copy of the value and all internal values,
it must be used in special cases because it is much less efficient
than the simple copy, which copies only one level of the data. There
is nothing complex to understand in deep copy, it simply creates a
value, deeply mutable, which is an exact copy.</p>
<pre><code class="language-ymir">import std::io

def main () {
    let x = [[1], [2, 3], [4]];
    let dmut y = dcopy x;
    let mut z : [mut [i32]] = copy x;
    println (x, &quot; &quot;, y, &quot; &quot;, z);
}
</code></pre>
<p><br></p>
<p>The structure of the copy respect the structure of the initial value
that has been copied, meaning that even recursive values can be copied
without any worries. To make recursive values, we need to use objects,
that are described in the chapter
<a href="https://gnu-ymir.github.io/Documentations/en/objects/">Objects</a>, and
traits described in the chapter
<a href="https://gnu-ymir.github.io/Documentations/en/objects/traits.html">Traits</a>
to make the objects deeply copiable. To avoid the scattering of the
information, we will assume that you will have already read these
chapters and came back here to understand the deep copy on objects.</p>
<p>In the following example, the object <strong><code>A</code></strong> contains a field of type
<strong><code>A</code></strong>. The initialization of this field is made using the either
<strong><code>self</code></strong> or another object in the constructor defined at line
<strong><code>1</code></strong> and <strong><code>2</code></strong>. Thus the state of the memory in the <strong><code>main</code></strong>
function, at line <strong><code>1</code></strong> can be described by the figure depicted just
underneath the source code.</p>
<pre><code class="language-ymir">import std::io;

class A {
    
    let _i : i32;
    let dmut _a : &amp;A;
    
    pub self (i : i32, dmut a : &amp;A) with _a = alias a, _i = i {
        self._a._a = alias self;
    }
    
    pub self (i : i32) with _a = alias self, _i = i {}
    
    impl Copiable, Streamable; // to make A deep copiable, and printable
}

def main () {
    let dmut a = A::new (1);
    let dmut b = A::new (2, alias a);
    
    println (a);
    println (b);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>main::A(1, main::A(2, main::A(...)))
main::A(2, main::A(1, main::A(...)))
</code></pre>
<p><br></p>
<p>Memory state at line <strong><code>20</code></strong> :</p>
<p><img src="https://gnu-ymir.github.io/Documentations/en/advanced/memory_recursive_main.png" alt="drawing" height="500"  style="display: block; margin-left: auto;  margin-right: auto;"></p>
<p>Now let's add a deep copy of the value contained inside the variable
<strong><code>a</code></strong> into a variable <strong><code>c</code></strong>. This deep copy copies the values of
the object inside <strong><code>a</code></strong>, and the object inside the field <strong><code>_a</code></strong>,
the copy is recursive, and correctly keeps the structure.</p>
<pre><code class="language-ymir">let c = dcopy a;
</code></pre>
<p><br></p>
<p>The following figure represents the memory state of the program after
the deep copy.</p>
<p><img src="https://gnu-ymir.github.io/Documentations/en/advanced/memory_recursive_main_copy.png" alt="drawing" height="500"  style="display: block; margin-left: auto;  margin-right: auto;"></p>
<a class="header" href="print.html#best-practice" id="best-practice"><h1>Best practice</h1></a>
<p>The <em>copy</em> is never hidden in the source code that is available to the
user. However, many codes that we are using on a daily basis, are
provided by libraries. In libraries, only the prototypes of the
functions are presented to the user, and therefore if a copy is made
inside a function, the copy is hidden from the user. We cannot
guarantee that such copy are not made (at least for the moment), so we
propose a best practice advice to avoid hidden copies inside
libraries.</p>
<p>This advice is simple, never take a immutable parameter in a function,
if you have to make a copy of it inside the function. For example, let
say we have a function that sorts a slice. This function should
preferably take a mutable slice as input and modify it directly.</p>
<pre><code class="language-ymir">def good (dmut slc : [i32])-&gt; dmut [i32] {
    // perform the sort on slc
    alias slc
}

def bad (slc : [i32])-&gt; dmut [i32] {
    let dmut res = copy slc;
    // perform the sort on res
    alias res}
    
</code></pre>
<p><br></p>
<p>This way, the function calling the sort function has the choice of
making the <em>copy</em> or not. In the following example, the user has the
choice when calling the function <strong><code>good</code></strong>, but never when calling
the function <strong><code>bad</code></strong>, making the copy hidden. One can note from the
following example, that the copy is never hidden when calling
<strong><code>good</code></strong>, and that it is also possible to make no copy at all.</p>
<pre><code class="language-ymir">def main () {
    let dmut slc = [9, 3, 7];
    let dmut aux = good (copy slc); // slc is unchanged, and aux is sorted
    let dmut slc2 = good (alias slc); // slc is sorted, and slc2 points the data of slc
    
    good (slc); // impossible, implicit alias is not allowed
    
    bad (slc); // here there is not need for alias, nor copy, 
               // the data of slc won't be modified in bad
               // the copy is alway made and hidden
}
</code></pre>
<p><br></p>
<p>From the above example, the compiler returns an error, when trying to
call the function <strong><code>good</code></strong> without <em>aliasing</em> nor <em>copying</em> at line
<strong>6</strong>. This error prevents from copying values implicitely without
writting it down, nor making <em>aliasing</em> of the values and giving the
write permission to foreign functions without informing the compiler
of our agreement. All the other calls are valid, the wish of the user
being totally explicit.</p>
<pre><code class="language-error">Error : the call operator is not defined for main::good and {mut [mut i32]}
 --&gt; main.yr:(17,7)
17  ┃ 	good (slc); // impossible, implicit alias is not allowed
    ╋ 	     ^   ^
    ┃ Note : candidate good --&gt; main.yr:(1,5) : main::good (slc : mut [mut i32])-&gt; mut [mut i32]
    ┃     ┃ Error : discard the constant qualifier is prohibited, left operand mutability level is 2 but must be at most 1
    ┃     ┃  --&gt; main.yr:(17,8)
    ┃     ┃ 17  ┃ 	good (slc); // impossible, implicit alias is not allowed
    ┃     ┃     ╋ 	      ^^^
    ┃     ┃     ┃ Note : implicit alias of type mut [mut i32] is not allowed, it will implicitly discard constant qualifier
    ┃     ┃     ┃  --&gt; main.yr:(17,8)
    ┃     ┃     ┃ 17  ┃ 	good (slc); // impossible, implicit alias is not allowed
    ┃     ┃     ┃     ╋ 	      ^^^
    ┃     ┃     ┗━━━━━┻━ 
    ┃     ┃ Note : for parameter slc --&gt; main.yr:(1,16) of main::good (slc : mut [mut i32])-&gt; mut [mut i32]
    ┃     ┗━━━━━━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p><em>Contribution</em>: Maybe it is possible to complitely avoid hidden copies ? (I don't have any clue for the moment).</p>
<a class="header" href="print.html#pure-values" id="pure-values"><h1>Pure values</h1></a>
<p>A pure value is a value that cannot change. In other word it is a
value, that ensure that there is no variable in the program that has a
mutable access to it. Pure values are different to const values, in
the sense that const values just give the guarantee that the current
access is not mutable, however they does not guarantee that there is no
other variable in the program with mutable access.</p>
<p>The different guarantees on values can be listed as follows :</p>
<ol>
<li>No guarantee, the value is mutable <strong><code>mut</code></strong></li>
<li>Guarantee that the value is no writable in the current context <strong><code>const</code></strong></li>
<li>Guarantee that the value is completely immutable in every context <strong><code>pure</code></strong></li>
</ol>
<a class="header" href="print.html#limitation-of-const-values" id="limitation-of-const-values"><h2>Limitation of const values</h2></a>
<p>To understand the limitation of <strong><code>const</code></strong> values, the following
program has two variable defined in the function <strong><code>main</code></strong>. The first
one <strong><code>a</code></strong> has a mutable access to the value, and the variable
<strong><code>b</code></strong> has a const access to the same value. Because the variable
<strong><code>a</code></strong> modifies the value, the value pointed by <strong><code>b</code></strong> is also
modified even if it was <strong><code>const</code></strong>. Thus, it is important to
understand that <strong><code>const</code></strong> is only referering to the permission of
the variable <strong><code>b</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

def main () {
    let dmut a = [1, 2, 3];
    let b = a;
    
    a [0] = 98;
    
    println (b);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>[98, 2, 3]
</code></pre>
<p><br></p>
<p>We have seen in a previous chapter that the keywords <strong><code>copy</code></strong> and
<strong><code>dcopy</code></strong> can be used to remove this limitation, and ensure that the
value of <strong><code>b</code></strong> is the same as the value of <strong><code>a</code></strong>, but that
modifying the value of <strong><code>a</code></strong> does not modify the value of
<strong><code>b</code></strong>. This mechanism is the base of the one provided by <strong><code>pure</code></strong>
values.</p>
<pre><code class="language-ymir">import std::io;

def main () 
    throws &amp;OutOfArray
{
    let dmut a = [1, 2, 3];
    let b = dcopy a;
    
    a [0] = 98;
    
    println (b);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>[1, 2, 3]
</code></pre>
<p><br></p>
<p>Now let's add a third variable to the equation, and let's name it
<strong><code>c</code></strong>. In this variable we want to store the value of <strong><code>b</code></strong>, and
ensure that the variable is never modified. If the initialization of
the variable <strong><code>b</code></strong> is made in an obscure way (for example in a
function that is not readable, here the <strong><code>foo</code></strong> function), then the
only way to ensure that the value of <strong><code>c</code></strong> is never modified, is to
make a copy of it inside the value of <strong><code>c</code></strong>. If the memory movement
are easy in the following example, it may not be the case in complex
program with many variable and memory movement.</p>
<pre><code class="language-ymir">import std::io;

def foo (a : [i32])-&gt; [i32] {
    a
}

def main () 
    throws &amp;OutOfArray
{
    let dmut a = [1, 2, 3];
    let b = foo (a);
    
    let c = dcopy b;
    let d = b;
    
    a [0] = 98;
    
    println (c);
    println (d);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>[1, 2, 3]
[98, 2, 3]
</code></pre>
<a class="header" href="print.html#purity-and-the-pure-keyword" id="purity-and-the-pure-keyword"><h2>Purity and the pure keyword</h2></a>
<p><br> In the above example, both variable <strong><code>b</code></strong> and <strong><code>d</code></strong> have no
guarantees, and there values are indeed modified. The <strong><code>pure</code></strong>
keyword can be added to their definitions. In that case, the compiler
checks the initialization of the values that are used, and ensure that
they came from a deep copy, or another pure value.</p>
<pre><code class="language-ymir">def foo (a : [i32]) -&gt; [i32] {
    a
}

def main () 
    throws &amp;OutOfArray 
{
    let dmut a = [1, 2, 3];
    
    let pure b = foo (a);
}
</code></pre>
<p><br></p>
<pre><code class="language-error">Error : discard the constant qualifier is prohibited
 --&gt; main.yr:(10,11)
10  ┃ 	let pure b = foo (a);
    ╋ 	         ^
    ┃ Note : implicit pure of type [i32] is not allowed, it will implicitly discard constant qualifier
    ┃  --&gt; main.yr:(10,19)
    ┃ 10  ┃ 	let pure b = foo (a);
    ┃     ╋ 	                 ^
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br> To avoid the above error, there is two possibilities. Either we
add a <strong><code>dcopy</code></strong> on the function call of <strong><code>foo</code></strong>, or we add
<strong><code>pure</code></strong> to the return type of <strong><code>foo</code></strong> and make a deep copy of the
value of <strong><code>a</code></strong> in this function. The function <strong><code>bar</code></strong> of the
following example perform the second possibility.</p>
<pre><code class="language-ymir">import std::io;

def foo (a : [i32])-&gt; [i32] {
    a
}

def bar (a : [i32])-&gt; pure [i32] {
    return dcopy a;
}

def main () 
    throws &amp;OutOfArray 
{
    let dmut a = [1, 2, 3];
    let pure b = dcopy foo (a);
    
    let pure c = bar (a);
    
    let pure d = b;
    let pure e = c;
    
    a [0] = 98;
    
    println (d);
    println (e);
}	
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>[1, 2, 3]
[1, 2, 3]
</code></pre>
<p><br> One can note that not copy are needed to move the value contained
in the variable <strong><code>c</code></strong> into the variable <strong><code>e</code></strong>. This is due to the
fact that <strong><code>c</code></strong> is pure, so the guarantee of purity is already
made. Thanks to the <strong><code>pure</code></strong> mechanism some copies can be avoided.</p>
<a class="header" href="print.html#modules" id="modules"><h1>Modules</h1></a>
<p>When creating a large project, it is very important to organize your
code. <em>Ymir</em> offers a system of modules, which is used to manage
different parts of the code that have different purposes. Each source
file in <em>Ymir</em> is a module.</p>
<a class="header" href="print.html#file-hierarchy" id="file-hierarchy"><h2>File hierarchy</h2></a>
<p>Lets have a look at the following file hierarchy :</p>
<pre><code>.
├── main.yr
└── extern_modules
    ├── bar.yr
    └── foo.yr

1 directory, 3 files
</code></pre>
<p><br>
In this file hierarchy there are three files, which contain modules, the
first module in the file <code>main.yr</code> will be named <code>main</code>. The second
one in the <code>extern_modules/bar.yr</code> file will be named <code>extern_modules::bar</code>,
and the third one in the <code>extern_modules/foo.yr</code> file will be named
<code>extern_modules::foo</code>.</p>
<p>To be properly importable, the module must be defined from the
relative path of the compilation, i.e. if the file is located in
<code>$(pwd)/relative/path/to/file</code>, its module name must be
<code>relative::path::to::file</code>.</p>
<p>The name of a module is defined by the first line of the source code,
by keyword <code>mod</code>. If this line is not given by the user, the path of
the module will only be the file name, so you will not always be able
to import the module, depending on its relative path. You can consider
this line mandatory for the moment.</p>
<p>For example, in the file <code>foo.yr</code>, the first line must look like :</p>
<pre><code class="language-ymir">mod extern_modules::foo
</code></pre>
<p><br></p>
<p>And, it will therefore be importable everywhere, for example in the
<code>main</code> module, when writing the import declaration :</p>
<pre><code class="language-ymir">import extern_modules::foo
</code></pre>
<p><br></p>
<p>The syntax of the import statement is the following :</p>
<pre><code class="language-grammar">import_statement := 'import' path (',' path)* (';')?
path := Identifier ('::' Identifier)* ('::' '_')?
</code></pre>
<a class="header" href="print.html#sub-modules" id="sub-modules"><h2>Sub modules</h2></a>
<p>Sub modules are local modules, declared inside a global modules, are
inside another sub module. Unlike global module, the access to the
symbols defined inside them is not implicit. For that reason they have
to be explicitely mentionned when trying to access to their
symbols. This mention is done with the double colon binary operator
<strong><code>::</code></strong>, where the first operand is the name of the module, and the
second the name of the symbol to access.</p>
<pre><code class="language-ymir">mod main
import std::io;

mod InnerModule {

    pub def foo () {
        println (&quot;Foo&quot;);
    }

}

def main () {
    InnerModule::foo (); // access of the function declared in InnerModule
}
</code></pre>
<p>The access operator <strong><code>::</code></strong>, can also be used to access to symbols
declared inside global modules. This will be discussed after talking
about privacy of symbols.</p>
<a class="header" href="print.html#privacy" id="privacy"><h2>Privacy</h2></a>
<p>All symbols defined in a module are private by default. The privacy of
a given symbol <em>s</em> refer to the possibility for foreign modules, and
symbols to access to this given symbol <em>s</em>. When a symbol <em>s</em> is
declared private in a module <em>s</em>, then only the other symbols of the
module <em>m</em> have access to it. Module privacy can be seen as a tree,
where a global module is a root, and module symbols are the branches
and leaves of the tree. In such a tree, symbols have access to their
parent, siblings, and the siblings of their parents.</p>
<p>In the following figure an example of a module tree is presented,
where a global module named <em>A</em>, has three symbols, 2 sub modules
<em>A::X</em> and <em>A::Y</em>, and a function <em>A::foo</em>. In this tree, we assume
that every symbols are declared private. For that reason, the function
<em>A::foo</em> has access to <em>A</em>, <em>A::X</em>, <em>A::Y</em>, but not to <em>A::X::bar</em>,
nor <em>A::Y::baz</em>. The symbol <em>A::X::bar</em>, has access to every symbols
(<em>A</em>, <em>A::X</em>, <em>A::Y</em>, <em>A::foo</em>), except <em>A::Y::baz</em>.</p>
<p><br></p>
<p><img src="https://gnu-ymir.github.io/Documentations/en/modules/tree.png" alt="drawing" height="300" style="display: block; margin-left: auto;  margin-right: auto;"></p>
<p><br></p>
<p>Global modules are always tree roots, for that reason they don't have
parents. For example, the module <strong><code>extern_modules::foo</code></strong>, does not
have access to the symbols declared inside the module
<strong><code>extern_modules</code></strong>, (if they are privates).</p>
<p>The keyword <strong><code>pub</code></strong> flag a symbol as <em>public</em>, and accessible by
foreign modules. This keyword can be used as a block, or for only one
symbol. Its syntax grammar is presented in the following code block.</p>
<pre><code class="language-grammar">pub :=   'pub' '{' symbol* '}' 
       | 'pub' symbol	
</code></pre>
<a class="header" href="print.html#example" id="example"><h3>Example</h3></a>
<ol>
<li>Module <em><code>extern_modules/foo.yr</code></em></li>
</ol>
<pre><code class="language-ymir">mod extern_modules::foo;

/**
 * foo is public, it can be accessed from foreign modules
 */
pub def foo () {}

/**
 * The bar function is private by default
 * Thus only usable in this module
 */
def bar () {}
</code></pre>
<p><br></p>
<ol start="2">
<li>Module <em><code>main.yr</code></em></li>
</ol>
<pre><code class="language-ymir">/**
 * This importation will give access to all the symbols in the module
 * 'extern_modules::foo' that have been declared 'public'
 */
import extern_modules::foo

def main () {
    foo (); // foo is public we can call it
    bar (); // however, bar is private thus not accessible
}
</code></pre>
<p>Errors:</p>
<pre><code class="language-error">Error : undefined symbol bar
 --&gt; main.yr:(7,5)
 7  ┃     bar (); // however, bar is private thus not accessible
    ╋     ^^^
    ┃ Note : bar --&gt; extern_modules/foo.yr:(8,5) : extern_modules::foo::bar is private within this context
    ┗━━━━━━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<a class="header" href="print.html#symbol-conflict-resolution" id="symbol-conflict-resolution"><h2>Symbol conflict resolution</h2></a>
<p>When two external global modules declare two symbols with the same
name, it may be impossible to know which symbol the user is refereing
to. In this case, the double colon operator <strong><code>::</code></strong> can be used with
the name of the module declaring the symbol to resolve the
ambiguity. To give an example of symbol conflict, let's say that we
have two module <code>extern_modules::foo</code> and <code>extern_modules::bar</code>
declaring a function with the same signature <code>foo</code>.</p>
<ol>
<li>Module <em><code>extern_modules/bar.yr</code></em></li>
</ol>
<pre><code class="language-ymir">mod extern_modules::bar
import std::io

pub def foo () {
    println (&quot;Bar&quot;);
}
</code></pre>
<p><br></p>
<ol start="2">
<li>Module <em><code>extern_modules/foo.yr</code></em></li>
</ol>
<pre><code class="language-ymir">mod extern_modules::foo
import std::io

pub def foo () {
    println (&quot;Foo&quot;);
}
</code></pre>
<p><br></p>
<p>In the <code>main</code> module, both modules <code>extern_modules::bar</code> and
<code>extern_modules::foo</code>, are imported. The main function presented below
refers to the symbol <strong><code>foo</code></strong>. In that case, there is no way to tell
which function will be used, <code>extern_modules::foo::foo</code> or
<code>extern_modules::bar::foo</code>. The compiler returns an error. One can
note that this errors occurs only because the signature of the two
function <code>foo</code> are the same (taking no parameters), and they are both
public. If there was a difference in their prototypes, for example if
the function in the module <code>extern_modules::bar</code> would take a value of
type <code>i32</code> as parameter, the conflict would be resolved by itself, as
the call expression will be different.</p>
<ol start="3">
<li>Module <em><code>main.yr</code></em></li>
</ol>
<pre><code class="language-ymir">import extern_modules::bar, extern_modules::foo

def main () {
    foo ();
}
</code></pre>
<p>Errors:</p>
<pre><code class="language-error">Error : {extern_modules::bar::foo ()-&gt; void, extern_modules::foo::foo ()-&gt; void, mod extern_modules::foo} x 3 called with {} work with both
 --&gt; main.yr:(4,6)
 4  ┃ 	foo ();
    ╋ 	    ^
    ┃ Note : candidate foo --&gt; extern_modules/bar.yr:(4,9) : extern_modules::bar::foo ()-&gt; void
    ┃ Note : candidate foo --&gt; extern_modules/foo.yr:(4,9) : extern_modules::foo::foo ()-&gt; void
    ┗━━━━━━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>.page-inner {
width: 95%;
}
In the above error, we can see that three modules are presented. The
two functions <strong><code>foo</code></strong> — in <strong><code>extern_modules::bar</code></strong>, and
<strong><code>extern_modules::foo</code></strong> — and the <strong><code>extern_modules::foo</code></strong> module
itself. Obviously, it is not possible to use the call operator
<strong><code>()</code></strong> on a module, that is why it is not presented as a possible
canditate in the notes of the error.</p>
<p>The conflict problem can be resolved by changing the calling
expression, and using the double colon operator <strong><code>::</code></strong>. In the
following example, the full name of the module is used. This is not
always necessary, as <strong><code>bar::foo</code></strong> is sufficient to refer to
<strong><code>extern_modules::bar::foo</code></strong>, and <strong><code>foo::foo</code></strong> for function
<strong><code>foo</code></strong> in <strong><code>extern_modules::foo</code></strong>.</p>
<pre><code class="language-ymir">import extern_modules::bar, extern_modules::foo

def main () {
    extern_modules::bar::foo (); 
    extern_modules::foo::foo (); 
    
    foo::foo (); 
    bar::foo ();
}
</code></pre>
<p>Results:</p>
<pre><code>Bar
Foo
Foo
Bar
</code></pre>
<p><br></p>
<a class="header" href="print.html#public-importation" id="public-importation"><h2>Public importation</h2></a>
<p>As for all declaration, importation are private. It means that the
importation is not recursive. For example, if the module
<code>extern_modules::foo</code> imports the module <code>extern_modules::bar</code>, and the
module <code>main</code> import the module <code>extern_modules::foo</code>, all the public
symbols declared in <code>extern_modules::bar</code> will not be accessible in the
module <code>main</code>.</p>
<p>You can of course, make a <code>pub</code> importation, to make the symbols of
the module <code>extern_modules::bar</code> visible for the module <code>main</code>.</p>
<ol>
<li>Module <em><code>extern_modules/bar.yr</code></em></li>
</ol>
<pre><code class="language-ymir">mod extern_modules::bar
import std::io

pub def bar () {
    println (&quot;Bar&quot;);
}
</code></pre>
<p><br></p>
<ol start="2">
<li>Module <em><code>extern_modules/foo.yr</code></em></li>
</ol>
<pre><code class="language-ymir">mod extern_modules::foo

pub import extern_modules::bar
</code></pre>
<p><br></p>
<ol start="3">
<li>Module <em><code>main.yr</code></em></li>
</ol>
<pre><code class="language-ymir">mod main
import extern_modules::foo;

def main () {
    bar ();
}
</code></pre>
<p><br></p>
<p>In the example above, the function <strong><code>bar</code></strong> defined in the module
<strong><code>extern_modules::bar</code></strong>, is imported (because the function is public
is public) by the module <strong><code>extern_modules::foo</code></strong>. This importation
is public, thus when the module <strong><code>main</code></strong> imports the module
<strong><code>extern_modules::foo</code></strong>, it also imports the module
<strong><code>extern_modules::bar</code></strong>, and has access to the function <strong><code>bar</code></strong>.</p>
<a class="header" href="print.html#best-practice-1" id="best-practice-1"><h3>Best practice</h3></a>
<p>Public importation must be used with caution, to avoid polluting other
modules. A good practice, is to define some modules only to make
public importations. These modules should be named <strong><code>_</code></strong>. For
example, with our previous file hierarchy, a file
<strong><code>extern_modules/_.yr</code></strong> would be added, and no public imports made
in the modules <strong><code>extern_modules::foo</code></strong>, nor in the module
<strong><code>extern_modules::bar</code></strong>.</p>
<pre><code class="language-ymir">mod extern_modules::_;

pub import extern_modules::foo;
pub import extern_modules::bar;
</code></pre>
<p><br></p>
<p>These modules are not automatically generated by <em>Ymir</em> — even if it
seems trivial —, to allow importing only a subset of the modules
contained in a sub directory. These importation modules are optional
and left to the choice of the user.</p>
<a class="header" href="print.html#include-directory" id="include-directory"><h2>Include directory</h2></a>
<p>You can use the <code>-I</code> option, to add a path to the include
directory. This path will be used as if it was the current <code>$(pwd)</code>. In
other words, if you add the <code>I -path/to/modules</code> option, and you have a
file in <code>path/to/modules/relative/to/my/file</code>, the name of the module
must be <code>relative::to::my::file</code>.</p>
<pre><code class="language-bash">gyc -I ~/libs/ main.yr
</code></pre>
<p>This is how the standard library is included in the build, and how you
can access modules in <code>std::</code> that are not located in <code>$(pwd)/std/</code>.</p>
<a class="header" href="print.html#compilation-of-modules" id="compilation-of-modules"><h2>Compilation of modules</h2></a>
<p>All modules must be compiled, the <code>import</code> declaration is just a
directive of for symbols access, but does not compile the imported
symbols. For example, in the following example, there are two modules,
one declaring a function <strong><code>foo</code></strong>, and the other importing it and
calling it.</p>
<ol>
<li>Module <em><code>main.yr</code></em></li>
</ol>
<pre><code class="language-ymir">mod main
import extern_modules::foo;

def main () {
    foo ();
}
</code></pre>
<p><br></p>
<ol start="2">
<li>Module <em><code>extern_modules/foo.yr</code></em></li>
</ol>
<pre><code class="language-ymir">mod extern_modules::foo

pub def foo () {}
</code></pre>
<p><br></p>
<p>By compiling only the <strong><code>main</code></strong> function, the compiler returns a link
error. This error means that the symbol <code>foo</code> declared in the module
<code>extern_modules::foo</code> was not found during the symbol linkage.</p>
<pre><code>$ gyc main.yr
/tmp/ccCOeXDq.o: In function `_Y4mainFZv':
main.yr:(.text+0x3e): undefined reference to `_Y14extern_modules3foo3fooFZv'
collect2: error: ld returned 1 exit status
</code></pre>
<p><br></p>
<p>To avoid this error, and create a valid executable, where all symbols
can be found, the module <strong><code>extern_modules::foo</code></strong> has to be compiled
as well. <em>GYC</em> is able to manage object files (containing pre compiled
symbols), and compiled libraries. The way <em>GYC</em> manage these kind of
objects is similar to all compiler of the <em>GCC suite</em>, and is not
presented in this documentation (<em>cf.</em> <a href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/gcc/Link-Options.html#Link-Options">GCC options for linking</a>).</p>
<pre><code>$ gyc main.yr extern_modules/foo.yr
</code></pre>
<a class="header" href="print.html#user-defined-types" id="user-defined-types"><h1>User defined types</h1></a>
<p>There are four different custom types:</p>
<ul>
<li>Structure</li>
<li>Enumeration</li>
<li>Aka</li>
<li>Class</li>
</ul>
<p>The following chapters present the structure, enumeration and aka.</p>
<a class="header" href="print.html#structure" id="structure"><h1>Structure</h1></a>
<p>Structure is a common design used in many languages to define users'
custom types. They contains multiple values of different types,
accessible by identifiers. Structures are similar to tuples, in terms
of memory management (located in the stack). Unlike tuples, structures
are named, and all their internal fields are named as well.</p>
<p>The complete grammar of structure definition is presented in the
following code block. One can note the possibility to add templates to
the definition of the structure. These templates will only be
discussed in the chapter
<a href="https://gnu-ymir.github.io/Documentations/en/templates/">Templates</a>,
and are not of interest to us at the moment.</p>
<pre><code class="language-grammar">struct_type := 'struct' ('|' var_decl)* '-&gt;' identifier (templates)?
var_decl := ('mut'?) identifier ':' type ('=' expression)?
identifier := ('_')* [A-z] ([A-z0-9_])*	 
</code></pre>
<p><br></p>
<p>The fields of the structure are defined using the same syntax as the
declaration of function parameters, i.e. the same syntax as variable
declaration but with the keyword <strong><code>let</code></strong> omitted. The following
source code presents a definition of a structure <strong><code>Point</code></strong> with two
fields <strong><code>x</code></strong> and <strong><code>y</code></strong> of type <strong><code>i32</code></strong>. The two fields of this
structure are immutable, and have no default values.</p>
<pre><code class="language-ymir">import std::io

struct 
| x : i32
| y : i32 
 -&gt; Point;
 
def main () {
    let point = Point (1, 2); // initialize the value of the structure
    println (point); // structures are printable
} 
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>main::Point(1, 2)
</code></pre>
<p><br></p>
<p>It is possible to declare a structure with no fields. Note, however,
that such structure has a size of 1 byte in memory.</p>
<p><strong>Contribution</strong> this is a limitation observed in gcc, maybe
this can be corrected ?</p>
<pre><code class="language-ymir">import std::io;

struct -&gt; Unit;

def main () {
    let x = Unit ();
    println (x, &quot; of size &quot;, sizeof (x));
}
</code></pre>
<p>Results:</p>
<pre><code>main::Unit() of size 1
</code></pre>
<a class="header" href="print.html#structure-construction" id="structure-construction"><h2>Structure construction</h2></a>
<p>The construction of a structure is made using the same syntax as a
function call, that is to say using its identifier and a list of
parameters inside parentheses and separated by comas. Like function
calls, structure can have default values assigneted to fields. The
value of these fields can be changed using the <em>named expression</em>
syntax, which is constructed with the arrow operator <code>-&gt;</code>. Field
without default value can also be constructed using the <em>named
expression</em> syntax. In that case, the order of field construction is
not important.</p>
<pre><code class="language-ymir">import std::io

struct 
| x : i32 = 0
| y : i32 
 -&gt; Point;
  
def main () {
    let point = Point (y-&gt; 12, x-&gt; 98);
    println (point);

    let point2 = Point (1);
    println (point2);
}
</code></pre>
<p>Results:</p>
<pre><code>main::Point(98, 12)
main::Point(0, 1)
</code></pre>
<p><br></p>
<a class="header" href="print.html#field-access" id="field-access"><h2>Field access</h2></a>
<p>The fields of a structure are always public, and accessible using the
dot binary operator <strong><code>.</code></strong>, where the left operand is a value whose
type is a structure, and the right operand is the identifier of the
field.</p>
<pre><code class="language-ymir">import std::io

struct 
| x : i32
| y : i32 
 -&gt; Point;
 
def main ()
    throws &amp;AssertError
{
    let point = Point (1, 2); 
    assert (point.x == 1 &amp;&amp; point.y == 2);
}
</code></pre>
<a class="header" href="print.html#structure-mutability" id="structure-mutability"><h2>Structure mutability</h2></a>
<p>The mutability of a field of a structure is defined in the structure
declaration. As with any variable declaration, the fields of a
structure are by default immutable. By adding the keyword <strong><code>mut</code></strong>
before the identifier of a field, the field becomes mutable. However,
the mutability is transitive in <em>Ymir</em>, meaning that a immutable value
of a struct type, cannot be modified even if its field are marked
mutable. Consequently, for a field to be really mutable, it must be
marked as such, and be a field of a mutable value.</p>
<pre><code class="language-ymir">import std::io

struct 
| x : i32
| mut y : i32
 -&gt; Point;
 
def main () {
    let mut p1 = Point (1, 2);
    p1.y = 98; // y is mutable
                  // and p1 is mutable no problem
    
    p1.x = 34; // x is not mutable, this won't compile
    
    let p2 = Point (1, 2);
    p2.y = 98; // p2 is not mutable, this won't compile	
}
</code></pre>
<p>Errors:</p>
<pre><code class="language-error">Error : left operand of type i32 is immutable
 --&gt; main.yr:(13,4)
13  ┃ 	p1.x = 34; // x is not mutable, this won't compile
    ╋ 	  ^

Error : left operand of type i32 is immutable
 --&gt; main.yr:(16,4)
16  ┃ 	p2.y = 98; // p2 is not mutable, this won't compile	
    ╋ 	  ^


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="print.html#memory-borrowing-of-structure" id="memory-borrowing-of-structure"><h2>Memory borrowing of structure</h2></a>
<p>By default structure data are located in the value that contains them,
i.e. in the stack inside a variable, on the heap inside a slice,
etc. They are copied by value, at assignement or function call. This
copy is static, and does not require allocation, so it is allowed
implicitely.</p>
<pre><code class="language-ymir">import std::io

struct 
| mut x : i32
| mut y : i32
 -&gt; Point;

def main ()
    throws &amp;AssertError
{
    let p = Point (1, 2);
    let mut p2 = p; // make a copy of the structure
    p2.y = 12;

    assert (p.y == 2);
    assert (p2.y == 12);
}
</code></pre>
<p><br></p>
<p>Structure may contain aliasable values, such as slice. In that case,
the copy is no longer allowed implicitely (if the structure is
mutable, and the field containing the <em>aliasable</em> value is also
mutable, and the element that will borrow the data is also
mutable). To resolve the problem, the keywords <code>dcopy</code>, and <code>alias</code>
presented in <a href="https://gnu-ymir.github.io/Documentations/en/advanced/">Aliases and
References</a>
can be used.</p>
<pre><code class="language-ymir">import std::io

struct 
| mut y : [mut [mut i32]]
 -&gt; Point;

def main ()
    throws &amp;OutOfArray
{
    let mut a = Point ([[1, 23, 3], [4, 5, 6]]);
    let mut b = dcopy a;
    let mut c = alias a;
    
    b.y [0][0] = 9; // only change the value of 'b'
    c.y [0][1] = 2; // change the value of 'a' and 'c'
    
    println (a);
    println (b);
    println (c);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>main::Point([[1, 2, 3], [4, 5, 6]])
main::Point([[9, 23, 3], [4, 5, 6]])
main::Point([[1, 2, 3], [4, 5, 6]])
</code></pre>
<p><br></p>
<p>It is impossible to make a simple copy of a structure with the keyword
<strong><code>copy</code></strong>, the mutability level being set once and for all in the
structure definition. For example, if a structure <em>S</em> contains a field
whose type is <strong><code>mut [mut [i32]]</code></strong>, every value of type <em>S</em> have a
field of type <strong><code>mut [mut [i32]]</code></strong>. For that reason, by making a
first level <em>copy</em>, the mutability level would not be respected.</p>
<a class="header" href="print.html#packed-and-union" id="packed-and-union"><h2>Packed and Union</h2></a>
<p>This part only concerns advanced programming paradigms, and is close
to the machine level. It is unlikely that you will ever need it,
unless you try to optimize your code at a binary level.</p>
<a class="header" href="print.html#packed" id="packed"><h3>Packed</h3></a>
<p>The size of a structure is calculated by the compiler, which decides
the alignment of the different fields. This is why the size of a
structure containing an <code>i64</code> and a <code>c8</code> is <strong>16</strong> bytes, not <strong>9</strong>
bytes. There is no guarantee about the size or the order of the fields
in the generated program. To force the compiler to remove the
optimized alignment, the <em>special modifier</em> <strong><code>packed</code></strong> can be
used.</p>
<pre><code class="language-ymir">import std::io

struct @packed
| x : i64
| c : c8
 -&gt; Packed;
 
struct 
| x : i64
| c : c8
 -&gt; Unpacked;


def main () {
    println (&quot;Size of packed : &quot;, sizeof Packed);
    println (&quot;Size of unpacked : &quot;, sizeof Unpacked);
}
</code></pre>
<p>Results:</p>
<pre><code>Size of packed : 9
Size of unpacked : 16
</code></pre>
<a class="header" href="print.html#union" id="union"><h3>Union</h3></a>
<p>The <strong><code>union</code></strong> <em>special modifier</em> , on the other hand, informs the
compiler that all fields in the structure must share the same memory
location. In the following example, the <strong><code>union</code></strong> <em>modifier</em> is used
on a structure containing two fields. The largest field of the
structure is the field <strong><code>y</code></strong> of type <strong><code>f64</code></strong>. The size of this
field is <strong>8</strong> bytes, thus the structure has a size of <strong>8</strong> bytes as
well. All the fields are aligned at the beginning of the strucures,
meaning that the field <strong><code>x</code></strong>, and <strong><code>y</code></strong> shares the same address in
memory.</p>
<pre><code class="language-ymir">struct @union 
| x : i32
| y : f64
 -&gt; Dummy;
</code></pre>
<p><br></p>
<p>The construction of a structure with <strong><code>union</code></strong> <em>modifier</em> requires
only one argument. This argument must be passed as a <em>named
expression</em> with the arrow operator <code>-&gt;</code>.</p>
<pre><code class="language-ymir">import std::io

struct @union
| x : i32
| y : f32
 -&gt; Dummy;

def main ()
    throws &amp;AssertError
{
    let x = Dummy (y-&gt; 12.0f);

    // Comparison of pointer is only possible on pointer of the same type
    // Any pointer can be casted into a pointer of &amp;void (the contrary is not possible)
    // is operator, checks if two pointer are equals
    assert (cast!(&amp;void) (&amp;(x.x)) is cast!(&amp;void) (&amp;(x.y)));

    // The value of x depends on the value of y
    assert (x.x == 1094713344);
    assert (x.y == 12.0f);
}
</code></pre>
<a class="header" href="print.html#structure-specific-attributes" id="structure-specific-attributes"><h2>Structure specific attributes</h2></a>
<p>Structures have type specific attributes, as any types, accessible with
the double colon binary operator <strong><code>::</code></strong>. The table below presents
these specific attributes. These attributes are accessible using a
type of struct, and not a value. A example, under the table presents
usage of struct specific attributes.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>init</code> </td><td> The initial value of the type </td></tr>
<tr><td> <code>typeid</code> </td><td>  The name of the type stored in a value of type <strong><code>[c32]</code></strong> </td></tr>
<tr><td> <code>typeinfo</code> </td><td> A structure of type TypeInfo, containing information about the type </td></tr>
</tbody></table>
<p>All the information about TypeInfo are presented in chapter <a href="">Dynamic types</a>.</p>
<pre><code class="language-ymir">mod main;

import std::io;

struct
| x : i32
| y : i32 = 9
 -&gt; Point; 
 
def main ()
    throws &amp;AssertError
{
    let x = Point::init;
    
    // the structure is declared in the main module, thus its name is main::Point	
    assert (Point::typeid == &quot;main::Point&quot;);
    
    assert (x.x == i32::init &amp;&amp; x.y == 9);
}
</code></pre>
<a class="header" href="print.html#enumeration" id="enumeration"><h1>Enumeration</h1></a>
<p>Enumerations are user-defined types that enumerates a list of
values. The keyword <code>enum</code> is used to define an enumeration type. The
type of the fields can be inferred from the value associated to the
fields. This type can be forced using the type operator <strong><code>:</code></strong>, after
the keyword <strong><code>enum</code></strong>. All the fields of an enumeration shares the
same type.</p>
<p>The complete grammar of an enumeration is presented in the following
source block. As for struct declaration, templates can be used, but
this functionnality will only be discussed in the
<a href="https://gnu-ymir.github.io/Documentations/en/templates/">Templates</a>
chapter.</p>
<pre><code class="language-grammar">enum_type := 'enum' (':' type)? (inner_value)+ '-&gt;' identifier (templates)?;
inner_value := '|' identifier '=' expression
identifier := ('_')* [A-z] ([A-z0-9_])*	
</code></pre>
<p><br></p>
<p>In the following source code, an example of an enumeration of type
<strong><code>[c32]</code></strong> is presented. This enumeration lists the names of the
days.</p>
<pre><code class="language-ymir">import std::io

enum
| MONDAY = &quot;Mon&quot;
| TUESDAY = &quot;Tue&quot;
| WEDNESDAY = &quot;Wed&quot;
| THURSDAY = &quot;Thu&quot;
| FRIDAY = &quot;Fri&quot;
| SATURDAY = &quot;Sat&quot;
| SUNDAY = &quot;Sun&quot;
 -&gt; Day;

def foo (day : Day) {
    println (day);
}

def main () {
    let d = Day::MONDAY;
    foo (d);
}
</code></pre>
<a class="header" href="print.html#value-access" id="value-access"><h2>Value access</h2></a>
<p>The values of an enumeration are accessible using the double colon
binary operator <strong><code>::</code></strong>. In practice, access a value of the
enumeration will past the content value of the field at the caller
location. The value - result of the expression - is of the type of the
enumeration (for example the type <strong><code>Day</code></strong> in the example below).</p>
<a class="header" href="print.html#value-types" id="value-types"><h3>Value types</h3></a>
<p>An example of enumeration access is presented in the following source
code. In this example, implicit casting is perform from a <strong><code>Day</code></strong> to
a <strong><code>[c32]</code></strong>, when calling the function <strong><code>foo</code></strong>, at line
<strong>23</strong>. This implicit cast is allowed.</p>
<pre><code class="language-ymir">import std::io

enum : [c32] // the type is optional
| MONDAY = &quot;Mon&quot;
| TUESDAY = &quot;Tue&quot;
| WEDNESDAY = &quot;Wed&quot;
| THURSDAY = &quot;Thu&quot;
| FRIDAY = &quot;Fri&quot;
| SATURDAY = &quot;Sat&quot;
| SUNDAY = &quot;Sun&quot;
 -&gt; Day;

def foo (day : [c32]) {
    println (day);
}

def bar (day : Day) {
    println (day);
}

def main () {
    // the internal type Day is of type [c32], so it can be implicitely casted into [c32]
    foo (Day::MONDAY);
    
    bar (Day::MONDAY);

    // However, it is impossible to transform a [c32] into a Day implicitely
    bar (&quot;Mon&quot;)
}
</code></pre>
<p><br></p>
<p>However, the contrary is not allowed, because the source code tries to
cast a <strong><code>[c32]</code></strong> into a <strong><code>Day</code></strong> at line <strong>28</strong>, the compiler
returns an error. The error is presented in the code block below. Such
cast is forbidden, to avoid enumeration value to contain a value that
is actually not defined in the list of the field of the
enumeration. For example, if this was accepted, the string
<strong><code>&quot;NotADay&quot;</code></strong> would be castable into a <strong><code>Day</code></strong> (<em>note:</em> the value
of the string being possibly unknown at compilation time).</p>
<pre><code class="language-error">Error : the call operator is not defined for main::bar and {mut [c32]}
 --&gt; main.yr:(28,9)
28  ┃     bar (&quot;Mon&quot;)
    ╋         ^     ^
    ┃ Note : candidate bar --&gt; main.yr:(17,5) : main::bar (day : main::Day([c32]))-&gt; void
    ┃     ┃ Error : incompatible types main::Day and mut [c32]
    ┃     ┃  --&gt; main.yr:(28,10)
    ┃     ┃ 28  ┃     bar (&quot;Mon&quot;)
    ┃     ┃     ╋          ^
    ┃     ┃ Note : for parameter day --&gt; main.yr:(17,10) of main::bar (day : main::Day([c32]))-&gt; void
    ┃     ┗━━━━━━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<a class="header" href="print.html#value-constructions" id="value-constructions"><h3>Value constructions</h3></a>
<p>Enumeration values can be more complex than literals. Any kind of
value can be used, for example call functions, condition block, scope
guards, etc. In the following example, an enumeration creating
structure from function call is presented. The type of the enumeration
is <strong><code>Ipv4Addr</code></strong>.</p>
<pre><code class="language-ymir">import std::io

struct
| a : i32
| b : i32
| c : i32
| d : i32
 -&gt; Ipv4Addr;

enum
| LOCALHOST = localhost ()
| BROADCAST = broadcast ()
 -&gt; KnownAddr;

def localhost ()-&gt; Ipv4Addr {
    println (&quot;Call localhost&quot;);
    Ipv4Addr (127, 0, 0, 1)
}

def broadcast ()-&gt; Ipv4Addr {
    println (&quot;Call broadcast&quot;);	
    Ipv4Addr (255, 255, 255, 255)
}

def main ()
    throws &amp;AssertError
{
    let addr = KnownAddr::LOCALHOST; // will call localhost here

    assert (KnownAddr::LOCALHOST.a == 127); // a second time here
    assert (KnownAddr::BROADCAST.d == 255); // call broadcast here
    assert (addr.a == 127);
}
</code></pre>
<p><br></p>
<p>The enumeration value of a field is constructed at each access, this
means for example that when enumeration values are constructed using
function call, the function is called each time the enumeration field
is accessed. Thus the result of the execution of the compiled source
code above is the following:</p>
<pre><code>Call localhost
Call localhost
Call broadcast
</code></pre>
<p><br></p>
<a class="header" href="print.html#value-context" id="value-context"><h3>Value context</h3></a>
<p>If the value of the enumeration seems to be passed at the caller
location, they don't share the context of the caller. In other words,
the fields of an enumeration have access to the symbol accessible from
the enumeration context, and not from the caller context. An example,
of enumeration trying to access symbols is presented in the source
code bellow.</p>
<pre><code class="language-ymir">import std::io

static __GLOB__ = true;

enum 
| FOO = (if (x) { 42 } else { 11 })
| BAR = (if (__GLOB__) { 42 } else { 11 })
 -&gt; ErrorEnum;
 
def main () {
    let x = false;
    
    println (ErrorEnum::FOO); 
}
</code></pre>
<p><br></p>
<p>From the above example, the compiler returns an error. In this error,
the compiler informs that the variable <strong><code>x</code></strong> is not defined from the
context of the enumeration. Even if the variable is declared inside
the <strong><code>main</code></strong> function, it is not accessible from the enumeration
context. The global variable <strong><code>__GLOB__</code></strong> is accessible from the
enumeration context, and thus accessing it is not an issue.</p>
<pre><code class="language-error">Note : 
 --&gt; main.yr:(6,3)
 6  ┃ | FOO = (if (x) { 42 } else { 11 })
    ╋   ^^^
    ┃ Error : undefined symbol x
    ┃  --&gt; main.yr:(6,14)
    ┃  6  ┃ | FOO = (if (x) { 42 } else { 11 })
    ┃     ╋              ^
    ┗━━━━━┻━ 

Note : 
 --&gt; main.yr:(13,11)
13  ┃ 	println (ErrorEnum::FOO); 
    ╋ 	         ^^^^^^^^^
    ┃ Error : the type main::ErrorEnum is not complete due to previous errors
    ┃  --&gt; main.yr:(8,5)
    ┃  8  ┃  -&gt; ErrorEnum;
    ┃     ╋     ^^^^^^^^^
    ┃     ┃ Note : 
    ┃     ┃  --&gt; main.yr:(13,11)
    ┃     ┃ 13  ┃ 	println (ErrorEnum::FOO); 
    ┃     ┃     ╋ 	         ^^^^^^^^^
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="print.html#enumeration-specific-attributes" id="enumeration-specific-attributes"><h2>Enumeration specific attributes</h2></a>
<p>As for any type, enumeration have specific type attributes. The table
below lists the enumeration type specific attributes.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>members</code> </td><td> A slice containing all the values of the enumeration </td></tr>
<tr><td> <code>member_names</code> </td><td> A slice of [c32], containing all the names of the fields of the enumeration (same order than <code>members</code>)</td></tr>
<tr><td> <code>typeid</code> </td><td> The type identifier of the enumeration type in a <code>[c32]</code> typed value </td></tr>
<tr><td> <code>typeinfo</code> </td><td> The typeinfo of the inner type of the enumeration (cf. <a href="">Dynamic types</a>) </td></tr>
<tr><td> <code>inner</code> </td><td> The inner type of the enumeration </td></tr>
</tbody></table>
<p><br></p>
<p>One may note that the operator to access specific attributes and field
is the same (double colon binary operator <strong><code>::</code></strong>), and therefore
that if an enumeration have a field named as a specific attributes
there is a conflict. To avoid conflict, the priority is given to the
fields of the enumeration, and specific attributes can be accessed
using their identifier surrounded by <strong><code>_</code></strong> tokens. For example,
accessing the <code>members</code> specific attributes can be made using the
identifier <code>__members__</code>. An example of the principle is presented in
the following source code. The specific attribute surrounding is
applicable to all types, but can be really usefull here.</p>
<pre><code class="language-ymir">mod main;

enum
| typeid       = 1
| typeinfo     = 2
| members      = 3
| member_names = 4
| inner        = 5
 -&gt; AnnoyingEnum;

def main ()
    throws &amp;AssertError
{
    assert (AnnoyingEnum::typeid == 1);
    assert (AnnoyingEnum::__typeid == AnnoyingEnum::__typeid__);
    assert (AnnoyingEnum::__typeid == &quot;main::AnnoyingEnum&quot;);	
}
</code></pre>
<a class="header" href="print.html#aka" id="aka"><h1>AKA</h1></a>
<p>An aka create a symbol that is an alias for another
expression. Everything can be used to create an alias, not necessarily
a value, or a type. The keyword <strong><code>aka</code></strong> was choosed to avoid
confusion with <strong><code>alias</code></strong>, that has a completely different meaning in
<em>Ymir</em>.</p>
<p>The grammar of <em>akas</em> is presented in the following code block.</p>
<pre><code class="language-grammar">aka_decl := 'aka' Identifier (templates)? = expression (';')?
</code></pre>
<a class="header" href="print.html#aka-as-a-value" id="aka-as-a-value"><h2>Aka as a value</h2></a>
<p>Aka can be used as a single value enumeration. As for enumeration
values, <em>akas</em> are constructed at each access, and are for that reason
closer to enumeration, than to global variable. In addition, <em>akas</em> are
only defined during compilation time, and are not defined inside the
executable, library, etc. generated by the compiler, contrary to
global variables.</p>
<p>An example of an aka is presented in the source code below. In that
example, the aka refers to the call of the <strong><code>foo</code></strong> function, that is
called each time the aka is used.</p>
<pre><code class="language-ymir">import std::io

aka CallFoo = foo ()

def foo () -&gt; i32 {
    println (&quot;Foo&quot;);
    42
}

def main () {
    println (CallFoo);
    println (CallFoo);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>Foo
42
Foo
42
</code></pre>
<p><br></p>
<p>Because <em>akas</em> are not global variable, they don't have an address,
and are always immutable. They don't really have a type, and simply
stick their content, at the location of the caller. However, like
enumeration values, their context is the one of their declaration, not
the context of the caller. For that reason by compiling the following
example, the compiler returns an error.</p>
<pre><code class="language-ymir">import std::io

aka FOO = x // x is not defined in this context

def main () {
    let x = 12; // this x is local, and not accessible from FOO
    println (FOO); // does not work
}
</code></pre>
<p><br>
Error:</p>
<pre><code class="language-error">Error : undefined type x
 --&gt; main.yr:(3,11)
 3  ┃ aka FOO = x
    ╋           ^

</code></pre>
<a class="header" href="print.html#aka-as-a-type" id="aka-as-a-type"><h2>Aka as a type</h2></a>
<p><em>Akas</em> do not always referes to values, but can also refer to
type. The symbol access rules are the same as value <em>akas</em>.</p>
<pre><code class="language-ymir">import std::io

aka MyTuple = (i32, i32)

def foo (a : MyTuple) {
    println (&quot;x: &quot;, a.0, &quot;, y: &quot;, a.1);
}

def main () {
    let x = (1, 2);
    foo (x);
}
</code></pre>
<p><br>
Results:</p>
<pre><code>x: 1, y: 2
</code></pre>
<p><br></p>
<p><em>Akas</em> type are not real type, meaning that the definition of <strong><code>foo</code></strong> in the previous example, is strictly equivalent to</p>
<pre><code class="language-ymir">def foo (a : (i32, i32)) {
    println (&quot;x: &quot;, a.0, &quot;, y: &quot;, a.1);
}
</code></pre>
<a class="header" href="print.html#aka-as-symbols" id="aka-as-symbols"><h2>Aka as symbols</h2></a>
<p><em>Akas</em> are not confined to type, and values. They can create symbols
to refer to other symbols. For example modules, functions, structures,
etc.</p>
<pre><code class="language-ymir">import std::io

aka IO = std::io

def println (a : i32) {
    IO::println (&quot;My println : &quot;, a);
}

def main () {
    IO::println (12);
    println (12);
}
</code></pre>
<p><br>
Results:</p>
<pre><code>12
My println : 12
</code></pre>
<p><br></p>
<p><strong>Contribution</strong> : enable aka on import, with the syntax : <code>import path aka name</code>. This is already possible, as we can see in the
previous example, but needs two lines.</p>
<a class="header" href="print.html#objects" id="objects"><h1>Objects</h1></a>
<p><em>Ymir</em> is a object oriented language, with polymorph types. In this
chapter, we assume that you are familiar with object oriented
programming paradigm (if not, you will benefit from reading
information on that paradigm first <em>cf.</em>  <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">object oriented
programming</a>.).</p>
<p>In <em>Ymir</em>, object instances are dynamically allocated on the
heap. Indeed, because object types are polymorph, their size cannot be
known at compile time, and consequently cannot be placed in the
stack. To illustrate this point, the following figure presents the UML
definition of a class <strong><code>A</code></strong>, and an heir class <strong><code>B</code></strong>. The class
<strong><code>A</code></strong> contains a field <strong><code>x</code></strong>, of type <strong><code>i32</code></strong>, thus of size
<strong>4</strong> bytes. The class <strong><code>B</code></strong>, contains another field <strong><code>y</code></strong> of size
<strong>4</strong>, leading to a class <strong><code>B</code></strong> of size <strong>8</strong>.</p>
<p><br>
<img src="https://gnu-ymir.github.io/Documentations/en/objects/UML.png" alt="drawing" height="400" style="display: block; margin-left: auto;  margin-right: auto;">
<br></p>
<p>Because we want to following source code to be accepted (basic
principle of polymorphism), the size of <strong>A</strong>, cannot be statically
set to <strong>4</strong> bytes, (nor to <strong>8</strong>, the class <strong><code>B</code></strong> can come from a
totally different part of the source code - from a library for example
-, and unknown when using the type <strong><code>A</code></strong>, without talking of the
huge loss of memory if only <strong><code>A</code></strong> values are used).</p>
<pre><code class="language-ymir">def foo (a : &amp;(A)) // ...	

def main () {
    let b : &amp;B = // ...
    foo (b); // calling foo with a B, heir of A
}
</code></pre>
<p><br></p>
<p>For that reason, object instances are aliasable types, and only
contains a pointer to the values of the class. You may have notice the
syntax <strong><code>&amp;(A)</code></strong>, in the above example. If this syntax is similar to
pointer, this is because objects are basically pointers. However,
unlike basic pointers, these cannot be used in pointer arithmetics,
cannot be <strong><code>null</code></strong>, and does not need to be dereferenced to access
the value. In other words, these are reference, more than pointers.
Yes, unlike other object oriented language such as <code>java</code> or <code>D</code>,
<strong>object instances cannot be <code>null</code></strong>. This is a really important part
of the object system in <em>Ymir</em> guaranteeing that every objects are
pointing to a valid value, and that value is correctly initialized
(constructor was called).</p>
<p>We will see in the coming chapters, that removing the possibility of
<strong><code>null</code></strong> objects does not remove any capacity on the language, while
adding strong safety, the number one error of <strong><code>java</code></strong> programs
being <strong>NullPointerException</strong> (<em>cf.</em> <a href="https://blog.samebug.io/which-java-exceptions-are-the-most-frequent-f830b113c37f">Which Java exceptions are the
most
frequent?</a>,
<a href="https://www.overops.com/blog/the-top-10-exceptions-types-in-production-java-applications-based-on-1b-events/">The Top 10 Exception Types in Production Java Applications – Based on
1B
Events</a>).</p>
<a class="header" href="print.html#class" id="class"><h1>Class</h1></a>
<p>An object is an instance of a class. A class is declared using the
keyword <strong><code>class</code></strong>, followed by the identifier of the class.  The
complete grammar of a class definition is presented in the following
code block.</p>
<pre><code class="language-grammar">class_decl := simple_class_decl | template_class_decl

simple_class_decl := 'class' (modifiers)? Identifier ('over' type)? '{' class_content '}'
template_class_decl := 'class' ('if' expression)? (modifiers)? Identifier templates ('over' type)? '{' class_content '}'
class_content :=   field
                 | method
                 | constructor
                 | impl
                 | destructor
modifiers := '@' ('{' modifier (',' modifier)* '}') | (modifier)
modifier := 'final' | 'abstract'
</code></pre>
<p><br></p>
<p>As many symbols, the class can be a template symbols. Templates are
not presented in this chapter, and are left for a future chapter
(<em>cf.</em>
<a href="https://gnu-ymir.github.io/Documentations/en/templates/">Templates</a>).</p>
<a class="header" href="print.html#fields" id="fields"><h2>Fields</h2></a>
<p>A class can contain fields. A field is declared as a variable, using
the keyword <code>let</code>. A field can have a default value, in that case the
type is optional, however if the value is not set, the field must have
a type. Multiple fields can be declared within the same <strong><code>let</code></strong>,
with coma separating them.</p>
<pre><code class="language-ymir">class Point4D {
    let _x : i32;
    let _y = 0;
    let _z : i32, _w = 0;
}
</code></pre>
<a class="header" href="print.html#field-privacy" id="field-privacy"><h3>Field privacy</h3></a>
<p>All fields are protected by default, i.e. only the class defining them
and its heirs have access to them. The keyword <strong><code>pub</code></strong> can be used
to make the fields public, and accessible from outside the class
definition. The keyword <strong><code>prv</code></strong>, on the other hand, can be use to
make the field totally hidden from outside the class. Unlike
<strong><code>prot</code></strong>, <strong><code>prv</code></strong> fields are not accessible by the heirs of a
class.</p>
<p>A good practice is to enclose the privacy of the fields in their name
definition. For example, a public field is named <strong><code>x</code></strong>, without any
<strong><code>_</code></strong> token. A protected fields always starts with a single
underscore, <strong><code>_y</code></strong>, and private fields are surrounded by two
underscores before and after the identifier. This is just a convention,
the name has no impact on the privacy.</p>
<pre><code class="language-ymir">class A {
    pub  let x = 12;
    prot let _y : i32;
    prv  let __z__ : i32;
}
</code></pre>
<a class="header" href="print.html#constructor" id="constructor"><h2>Constructor</h2></a>
<p>To be instancible, a class must declare at least one constructor. The
constructor is always named <code>self</code>, and takes parameters to build the
object. The object is accessible within the constructor body through
the variable <strong><code>self</code></strong>.</p>
<a class="header" href="print.html#field-construction" id="field-construction"><h3>Field construction</h3></a>
<p>The constructor must set the value to all the fields of the
class, with the keyword <strong><code>with</code></strong>. Fields with default values are not
necessarily set by this <strong><code>with</code></strong> statement, but can be
redefined. The with statement has the effect of the initial value of
the fields, meaning that the value of immutable fields is set by them.</p>
<pre><code class="language-ymir">class Point {
    let _x : i32;
    let _y = 0;
    
    /**
     * _y is already initialized
     * it is not mandatory to add it in the with initialization
     */
    pub self () with _x = 12 {}
    
    /**
     * But it can be redefined
     */
    pub self (x : i32, y : i32) with _x = x, _y = y {}
}
</code></pre>
<p><br></p>
<p>Field value is set only once. For example, if a class has a field
<strong><code>_x</code></strong> with a default value, calling a function <strong><code>foo</code></strong>. And the
constructor use the <strong><code>with</code></strong> statement to set the value of the field
from the return value of the <strong><code>bar</code></strong> function, the function
<strong><code>foo</code></strong> is never called.</p>
<pre><code class="language-ymir">def foo () -&gt; i32 {
    println (&quot;Foo&quot;);
    42
}

def bar () -&gt; i32 {
    println (&quot;bar&quot;)
    33
}

class A {
    let _x = foo ();
    
    pub self () with _x = bar () {} // foo is not called, bar is call instead
}
</code></pre>
<p><br></p>
<p>The point behind <strong><code>with</code></strong> field construction, is to ensure that all
fields have a value, when entering the constructor body. This way,
when instruction are made inside the constructor body, such as
printing the value of the fields, their value is already set, and the
object instance is already valid.</p>
<pre><code class="language-ymir">class A {
    let _x : i32;
    
    pub self () with _x = 42 {
        println (self._x); // access the field _x, of the current object instance
    } 
}
</code></pre>
<a class="header" href="print.html#create-an-object-instance" id="create-an-object-instance"><h3>Create an object instance</h3></a>
<p>Class are used to create object instance, by calling a
constructor. This call is made using the double colon binary operator
<strong><code>::</code></strong>, with the left operand being the name of the class to
instantiate, and the right operand the keyword <strong><code>new</code></strong>. After the
keyword <strong><code>new</code></strong> a list of argument is presented, this list is the
list of argument to pass to the constructor. The constructor with the
best affinity is choosed and called on a allocated instance of the
class. Constructor affinity is computed as function affinity (based on
type mutability, and type compatibility – <em>cf.</em> <a href="https://gnu-ymir.github.io/Documentations/en/advanced/">Aliases and
References</a>).</p>
<pre><code class="language-ymir">import std::io

class A {

    pub self (x : i32) {
        println (&quot;Int : &quot;, x);
    }
    
    pub self (x : f32) {
        println (&quot;Float : &quot;, x);
    }

}

def main () {
    let _ = A::new (12);
    let _ = A::new (12.f);
}
</code></pre>
<p><br>
Results</p>
<pre><code>Int : 12
Float : 12.000000
</code></pre>
<a class="header" href="print.html#named-constructor" id="named-constructor"><h3>Named constructor</h3></a>
<p>A name can be added to the constructor. This name is an Identifier,
and follows the keyword <strong><code>self</code></strong>. A named constructor can be called
by its name when constructing a class. This way two constructor can
share the same prototype, and be called from their name. A named
constructor is <strong>not</strong> ignored when constructing a class with the
<strong><code>new</code></strong> keyword, its named is just not considered.</p>
<p>In the following example, a class <strong><code>A</code></strong> contains two constructors,
<strong><code>foo</code></strong> and <strong><code>bar</code></strong>, these constructors have one parameter of type
<strong><code>i32</code></strong>.</p>
<pre><code class="language-ymir">import std::io

class A {
    let _x : i32;
    
    pub self foo (x : i32) with _x = x {
        println (&quot;Foo &quot;, self._x);
    }
    
    pub self bar (x : i32) with _x = x {
        println (&quot;Bar &quot;, self._x);
    }
}

def main () {
    let _ = A::foo (12);
    let _ = A::bar (12); 
    
    let _ = A::new (12);
}
</code></pre>
<p><br></p>
<p>The last object construction at line <strong>19</strong> is not possible, the call
working with both <strong><code>foo</code></strong> and <strong><code>bar</code></strong>. The other constructions
work fine, that is why the compiler returns only the following error.</p>
<pre><code class="language-error">Error : {self foo (x : i32)-&gt; mut &amp;(mut main::A), self bar (x : i32)-&gt; mut &amp;(mut main::A)} x 2 called with {i32} work with both
 --&gt; main.yr:(19,17)
19  ┃ 	let _ = A::new (12);
    ╋ 	               ^
    ┃ Note : candidate self --&gt; main.yr:(6,6) : self foo (x : i32)-&gt; mut &amp;(mut main::A)
    ┃ Note : candidate self --&gt; main.yr:(10,6) : self bar (x : i32)-&gt; mut &amp;(mut main::A)
    ┗━━━━━━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="print.html#construction-redirection" id="construction-redirection"><h3>Construction redirection</h3></a>
<p>To avoid redondent code, a constructor can call another constructor in
the <strong><code>with</code></strong> statement. This call redirection is performed by using
the <strong><code>self</code></strong> keyword. In that case, because the fields are already
constructed by the called constructor, they must not be reconstructed.</p>
<pre><code class="language-ymir">import std::io;

class A {
    let _x : i32;

    pub self () with self (12) {
        println (&quot;Scd &quot;, self._x);
    }

    pub self (x : i32) with _x = x {
        println (&quot;Fst &quot;, self._x);
    }
    
}


def main () {
    let _ = A::new (); // construct an instance of the class A
                       // from the constructor at line 6
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Fst 12
Scd 12
</code></pre>
<p><br></p>
<p><em>Contribution:</em> Redirection to named constructor does not work for the moment. This is not complicated, but has to be done.</p>
<a class="header" href="print.html#constructor-privacy" id="constructor-privacy"><h3>Constructor privacy</h3></a>
<p>As fields, the privacy of the constructor is protected by default. The
keyword <strong><code>prv</code></strong> and <strong><code>pub</code></strong> can be used to change it.</p>
<a class="header" href="print.html#destructors" id="destructors"><h2>Destructors</h2></a>
<p>Object instances are destroyed by the garbage collector. Meaning that
there is no way to determine when or even if an object instance will
be destroyed. But lets say that such operation effectively happen
(which is quite probable, let's no lie either), then a last function
can be called just before the object instance is destroyed and
irrecoverable. The destructor is called <strong><code>__dtor</code></strong>, and takes the
parameter <strong><code>mut self</code></strong>. There is only one destructor per class, this
destructor is optional and always public.</p>
<pre><code class="language-ymir">import std::io;

static mut I = 0;

class A {
    let _x : i32;
    pub self () with _x = I {
        I += 1;
    }
    
    __dtor (mut self) {
        println (&quot;Destroying me ! &quot;, self._x); 
    }

}

def foo () {
    let _ = A::new (); 
} // the object instance is irrecoverable at the end of the function

def main () {
    loop {
        foo ();
    }
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>Destroying me ! 765
Destroying me ! 1022
Destroying me ! 764
Destroying me ! 1023
Destroying me ! 763
Destroying me ! 1024
Destroying me ! 762
Destroying me ! 1025
Destroying me ! 761
Destroying me ! 1026
...
</code></pre>
<p><br></p>
<p>One can note from the result, that the order of destruction is totally
unpredictible. Rely on class destructor is not the best practice. We
will see in a future chapter disposable objects, that are destroyed in
a more certain way. Destructors are a last resort to free unmanaged
memory, if this was forgotten (for example, file handles, network
socket, etc. if not manually disposed).</p>
<a class="header" href="print.html#mutability" id="mutability"><h1>Mutability</h1></a>
<p>Objects are aliasable types. The data being allocated on the heap, and
not copied - for efficiency reasons - on affectations (<em>cf.</em> <a href="https://gnu-ymir.github.io/Documentations/en/advanced/">Aliases
and
References</a>).</p>
<a class="header" href="print.html#object-mutability" id="object-mutability"><h2>Object mutability</h2></a>
<p>The type of an object instance is a reference to a class type. This
reference can mutable, and the data pointed data as well. In the
following example, a variable <strong><code>a</code></strong> containing an object instance of
the class <strong><code>A</code></strong> is created. This variable contains a mutable
reference, but the data borrowed by the reference are not mutable.</p>
<pre><code class="language-ymir">class A {
    
    pub let mut x : i32;
    
    pub self (x : i32) with x = x {}
    
}


def main () {
    let mut a : &amp;(A)= A::new (12);
    
    a = A::new (42); // ok the reference if mutable
    
    a.x = 33; // the borrowed data are not mutable
}
</code></pre>
<p><br></p>
<p>Because the data borrowed by <strong><code>a</code></strong> are not mutable, the
compiler returns an error.</p>
<pre><code class="language-error">Error : left operand of type i32 is immutable
 --&gt; main.yr:(15,3)
15  ┃ 	a.x = 33; // the borrowed data are not mutable
    ╋ 	 ^


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>This error can be avoided, by making the borrowed data mutable as
well. Either by using the <strong><code>dmut</code></strong> modifier, or by writing <strong><code>mut &amp;(mut A)</code></strong>.</p>
<pre><code class="language-ymir">def main () {
    let dmut a = A::new (12);
    a.x = 42; // no problem a is mutable, and its borrowed data as well.
    println (a.x); 
}
</code></pre>
<p>Because classes are aliasable types, the keyword <strong><code>alias</code></strong> has to be
used when trying to make a mutable affectation. Information about
aliasable types is presented in chapter
<a href="https://gnu-ymir.github.io/Documentations/en/advanced/alias.html">Aliases</a>,
and is not rediscussed here.</p>
<pre><code class="language-ymir">def main () 
    throws &amp;AssertError
{
    let dmut a = A::new (12);
    let dmut b = alias a;
    b.x = 42;
    
    assert (a.x == 42);
}
</code></pre>
<a class="header" href="print.html#field-mutability" id="field-mutability"><h2>Field mutability</h2></a>
<p>Field mutability is set once and for all, in the definition of the
class. The information about field mutability presented in the chapter
about structure is applicable to classes.</p>
<p>However, unlike structures, classes are not copiable by default, but
have to implement a specific traits. Trait and implementation is
presented in a future chapter, and copy is discussed in there
chapter. (<em>cf.</em>
<a href="https://gnu-ymir.github.io/Documentations/en/objects/traits.html">Traits</a>).</p>
<pre><code class="language-ymir">class A {
    
    pub let mut x : i32;
    pub let y : i32;
    
    pub self (x : i32, y : i32) with x = x, y = y {}
    
}


def main () {
    let dmut a = A::new (0, 1);
    a.x = 43;
    a.y = 89;
}
</code></pre>
<p><br>
Errors:</p>
<pre><code class="language-error">Error : left operand of type i32 is immutable
 --&gt; main.yr:(14,3)
14  ┃ 	a.y = 89;
    ╋ 	 ^


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="print.html#methods" id="methods"><h1>Methods</h1></a>
<p>Methods are functions associated to object instances. Methods are
described inside a class definition. Information about function
presented in chapter
<a href="https://gnu-ymir.github.io/Documentations/en/primitives/functions.html">Functions</a>
are applicable to methods. The grammar of a method is presented in the
following code block.</p>
<pre><code class="language-grammar">method := simple_method | template_method

simple_method := 'def' Identifier method_params ('-&gt;' type)? expression
template_method := 'def' ('if' expression)? Identifier templates  ('-&gt;' type)? expression

method_params := '(' ('mut')? 'self' (',' param_decl)* ')'
</code></pre>
<p><br></p>
<p>Methods are accessible using an object instance, of the dot binary
operator <strong><code>.</code></strong>. Once accessed, a method can be called using a list
of arguments separated by comas inside parentheses. The first
parameter of a method is the object instance, and is the left operand
of the dot operator, so it must not be repeated inside the
parentheses.</p>
<pre><code class="language-ymir">import std::io

class A {
    let _a : i32;

    pub self (a : i32) with _a = a {}
    
    
    pub def foo (self, x : i32) -&gt; i32 {
        println (&quot;Foo &quot;, self._a);
        x + self._a 
    }
}

def main () {
    let a = A::new (29);
    println (a.foo (13));
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Foo 29
42
</code></pre>
<p><br></p>
<p>The access to the fields, and to the methods of the object instance
inside the body of a method is made using the first parameter of the
method, the variable <strong><code>self</code></strong>. Unlike some object oriented language,
such as <em>Java</em>, <em>C++</em>, <em>Scala</em>, <em>D</em>, etc. <strong><code>self</code></strong> is never
implicit, e.g. accessing to the field <strong><code>_a</code></strong> in the above example,
cannot be made by just writing <strong><code>_a</code></strong>, but must be accessed by
writing <strong><code>self._a</code></strong>. This is a conceptual choice, whose purpose is
to improve code readability and sharing, by avoiding useless and
preventable search for the source of the variables.</p>
<a class="header" href="print.html#privacy-1" id="privacy-1"><h2>Privacy</h2></a>
<p>Methods are protected by default. Meaning that only the class that
have defined them, and its heir class have acces to them. The keyword
<strong><code>pub</code></strong> and <strong><code>prv</code></strong> can be used to change the privacy of a
method. A public method is accessible everywhere, using an object
instance, and private methods are only accessible by the class that
have defined them. Unlike protected methods, private methods are not
accessible by heir classes. Privacy of methods is the same as privacy
of fields.</p>
<pre><code class="language-ymir">import std::io

class A {

    pub self () {}
    
    pub def foo (self) {
        println (&quot;Foo&quot;);
        self.bar ();
    }
    
    prv def bar (self) {
        println (&quot;bar&quot;);
    }
}


def main () {
    let a = A::new ();
    a.foo ();
    a.bar ();
}
</code></pre>
<p><br></p>
<p>Because the method <strong><code>bar</code></strong> is private in the context of the
<strong><code>main</code></strong> function, the compiler returns the following error. One
can note, that the compiler tried to rewrite the expression into a
<em>uniform call syntax</em> (i.e. <strong><code>bar (a)</code></strong>), but failed, because the
function <strong><code>bar</code></strong> does not exists.</p>
<pre><code class="language-error">Error : undefined field bar for element &amp;(main::A)
 --&gt; main.yr:(21,3)
21  ┃ 	a.bar ();
    ╋ 	 ^^^^
    ┃ Note : bar --&gt; main.yr:(12,10) : (const self) =&gt; main::A::bar ()-&gt; void is private within this context
    ┃ Note : when using uniform function call syntax
    ┃ Error : undefined symbol bar
    ┃  --&gt; main.yr:(21,4)
    ┃ 21  ┃ 	a.bar ();
    ┃     ╋ 	  ^^^
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="print.html#method-mutability" id="method-mutability"><h2>Method mutability</h2></a>
<p>The mutability of the object instance must be defined in the prototype
of the method. By default the object instance refered to by <strong><code>self</code></strong>
is immutable, meaning that the instance cannot be modified.</p>
<pre><code class="language-ymir">class A {
    
    let mut _x : i32;
    
    pub self (x : i32) with _x = x {}
    
    pub def setX (self, x : i32) {
        self._x = x;
    }	
    
}
</code></pre>
<p><br>
Error:</p>
<pre><code class="language-error">Error : when validating main::A
 --&gt; main.yr:(1,7)
 1  ┃ class A {
    ╋       ^
    ┃ Error : left operand of type i32 is immutable
    ┃  --&gt; main.yr:(8,7)
    ┃  8  ┃ 		self._x = x;
    ┃     ╋ 		    ^
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br> By using the keyword <strong><code>mut</code></strong>, the method can be applicable to
mutable instance. In that case the instance refered to by <strong><code>self</code></strong>
is mutable, and its mutable fields can be modified. Such methods can
be accessed only using mutable object instance - not only mutable
reference, the borrowed data located on the heap must be mutable. To
call such method, aliases is necessary and cannot be implicit.</p>
<pre><code class="language-ymir">class A {
    let mut _x : i32;
    
    pub self (x : i32) with _x = x {}
    
    pub def setX (mut self, x : i32) {
        self._x = x;
    }	
    
}

def main () {
    let a = A::new (12);
    a.setX (42); 
    
    let dmut b = A::new (12);
    b.setX (42);
    
    (alias b).setX (42);	
}
</code></pre>
<p><br></p>
<p>The first call at line <strong>14</strong> is not possible, <strong><code>a</code></strong> having only
read access to the object instance it contains. The second error, the
call at line <strong>17</strong>, is due to the fact that even <strong><code>b</code></strong> have write
permission to the object instance it contains, it cannot be passed to
the method implicitely, and have to be aliased, in order to certify
explicitely that the user is aware that the value of the object
contained in <strong><code>b</code></strong> will be modified by calling the method. The
errors returned by the compiler are the following.</p>
<pre><code class="language-error">Error : the call operator is not defined for (a).setX and {i32}
 --&gt; main.yr:(14,9)
14  ┃ 	a.setX (42); 
    ╋ 	       ^  ^
    ┃ Error : discard the constant qualifier is prohibited, left operand mutability level is 2 but must be at most 1
    ┃  --&gt; main.yr:(14,9)
    ┃ 14  ┃ 	a.setX (42); 
    ┃     ╋ 	       ^
    ┃     ┃ Note : implicit alias of type &amp;(main::A) is not allowed, it will implicitly discard constant qualifier
    ┃     ┃  --&gt; main.yr:(14,2)
    ┃     ┃ 14  ┃ 	a.setX (42); 
    ┃     ┃     ╋ 	^
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 

Error : the call operator is not defined for (b).setX and {i32}
 --&gt; main.yr:(17,9)
17  ┃ 	b.setX (42);
    ╋ 	       ^  ^
    ┃ Error : discard the constant qualifier is prohibited, left operand mutability level is 2 but must be at most 1
    ┃  --&gt; main.yr:(17,9)
    ┃ 17  ┃ 	b.setX (42);
    ┃     ╋ 	       ^
    ┃     ┃ Note : implicit alias of type mut &amp;(mut main::A) is not allowed, it will implicitly discard constant qualifier
    ┃     ┃  --&gt; main.yr:(17,2)
    ┃     ┃ 17  ┃ 	b.setX (42);
    ┃     ┃     ╋ 	^
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>We have seen in the chapter about function, and more specifically
about <em>uniform call syntax</em> that the operator <strong><code>:.</code></strong> can be used to
pass a aliased value as the first parameter of a function. This
operator is also applicable for method calls, and is to be prefered to
the syntax <strong><code>(alias obj).method</code></strong> which is a bit verbose.</p>
<pre><code class="language-ymir">def main () {
    let dmut a = A::new (12);
    
    a:.setX (42); // same as (alias a).setX (42)
}
</code></pre>
<p><br></p>
<p>Method mutability is also applicable inside the body of a method. In
the example below, the method <strong><code>foo</code></strong> is mutable, and call another
mutable method <strong><code>bar</code></strong>, it also calls a immutable method
<strong><code>baz</code></strong>. Implicit aliasing is mandatory when calling the method
<strong><code>bar</code></strong>, but not when calling the method <strong><code>baz</code></strong>.</p>
<pre><code class="language-ymir">class A {
    let _x : i32;
    pub self (x : i32) with _x = x {}

    pub def foo (mut self, x : i32) {
        self:.bar (x); // :. is mandatory
        self.baz (x);
    }
    
    pub def bar (mut self, x : i32) {
        self._x = x;
    }

    pub def baz (self) {
        println (&quot;X : &quot;, self._x);
    }
}
</code></pre>
<p><br></p>
<p><em>Contribution</em>: Calling a immutable method with explicit alias is
possible. Maybe that is not a good idea, and will lead to the use of
the operator <strong><code>:.</code></strong> all the time, and misleading read of the code.</p>
<a class="header" href="print.html#method-mutability-override" id="method-mutability-override"><h2>Method mutability override</h2></a>
<p>It is possible to define two methods with the same prototype, with the
only exception that one of them is mutable and not the other. In that
case the method with the best affinity is choosed when called. That is
to say, the mutable method is called on explicitly aliased object
instances, and the immutable method the rest of the time.</p>
<pre><code class="language-ymir">import std::io

class A {

    pub self () {}
    
    pub def foo (mut self) {
        println (&quot;Mutable&quot;);
    }
    
    pub def foo (self) {
        println (&quot;Const&quot;);
    }   	
}

def main () {
    let dmut a = A::new ();
    a.foo ();
    a:.foo ();
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Const
Mutable
</code></pre>
<a class="header" href="print.html#inheritance" id="inheritance"><h1>Inheritance</h1></a>
<p>One of the most important point of the object oriented programming
paradigm is the possibility for a class to be derived from a base
class. This capability enables type polymorphism. In <em>Ymir</em> the
keyword <code>over</code> is used for class derivation, and overriding. A class
can have only one ancestor. We will see in the chapter about traits,
that multiple inheritance can be in some way achieved in another way.</p>
<pre><code class="language-ymir">class Shape {
}

/**
 * A circle is a shape
 */
class Circle over Shape {
    let _center : i32 = 0;
    let _radius : i32 = 1;
}
</code></pre>
<a class="header" href="print.html#fields-1" id="fields-1"><h2>Fields</h2></a>
<p>The fields of an ancestor cannot be redeclared by an heir class. Even
if they are hidden to the heir class (private fields). This choice was
made to avoid miscomprehension, as two different variables would be
named the same way.</p>
<pre><code class="language-ymir">import std::io;
        
class Shape {
    let _x : i32 = 0;
    
    pub self () {}
}

class Circle over Shape {
    let _x : i32;
    
    pub self () {
        println (self._x);
    }	
}
</code></pre>
<p><br></p>
<p>Error:</p>
<pre><code class="language-error">Error : when validating main::Circle
 --&gt; main.yr:(9,7)
 9  ┃ class Circle over Shape {
    ╋       ^^^^^^
    ┃ Error : declaration of _x shadows another declaration
    ┃  --&gt; main.yr:(4,13)
    ┃  4  ┃     prv let _x : i32 = 0;
    ┃     ╋             ^^
    ┃     ┃ Note : 
    ┃     ┃  --&gt; main.yr:(10,9)
    ┃     ┃ 10  ┃     let _x : i32;
    ┃     ┃     ╋         ^^
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="print.html#parent-class-construction" id="parent-class-construction"><h2>Parent class construction</h2></a>
<p>All object instances must be constructed. This means that when a class
override a base class, the constructor of the base class must be
called inside the constructor of the heir class. This call can be made
implicitly if the constructor of the parent class takes no
arguments. However, if no constructor in the parent class takes no
arguments, then the call must be made explicitly. This explicit call
is made inside the with statement.</p>
<pre><code class="language-ymir">class Shape {	
    let _x = 0;
    pub self () {}
    
    pub self (x : i32) with _x = x {}
}

class Circle over Shape {
    let _radius : f32;
    
    // Same as : with super ()
    pub self () with _radius = 1.0f {} 
    
    // call the second parent constructor, at line 5
    pub self (x : i32) with super (x), _radius = 1.0f {} 
}
</code></pre>
<p><br></p>
<p>The call of the parent constructor is the first thing performed inside
a constructor. Meaning, that the construction of the fields of the
heir class are made afterward. To illustrate this point, the following
example presents a base class <strong><code>Foo</code></strong> with a constructor printing
<strong><code>foo</code></strong>, and a heir class <strong><code>Bar</code></strong>, calling the function <strong><code>bar</code></strong>*
(printing the value <strong><code>bar</code></strong>) to initialize its field <strong><code>_x</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

def bar () -&gt; i32 {
    println( &quot;Bar&quot;);
    42
}

class Foo {    
    pub self () {
        println (&quot;Foo&quot;);
    }
}

class Bar over Foo {
    let _x : i32;

    pub self () with _x = bar () {}
}

def main () {
    let _ = Bar::new ();
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Foo
Bar
</code></pre>
<p><br></p>
<p>However, because constructor redirection does not call parent
constructor, and let that work to the called constructor, to which
they are redirected, the following program has a different
behavior. The arguments of the redirection are computed first, then
the call to the parent constructor, and finally the construction of
the fields of the heir class.</p>
<pre><code class="language-ymir">import std::io;

def bar () -&gt; i32 {
    println( &quot;Bar&quot;);
    29
}

def baz () -&gt; i32 {
    println( &quot;Baz&quot;);
    13
}

class Foo {
    pub self () {
        println (&quot;Foo&quot;);
    }
}

class Bar over Foo {
    let _x : i32;

    /**
     * Call parent constructor at line 14, and then bar
     */
    pub self (x : i32) with _x = bar () + x {}

    /**
     * Call baz first, then self at line 25
     */
    pub self () with self (baz ()) {} 
}

def main () {
    let _ = Bar::new ();
}
</code></pre>
<p><br>
Results:</p>
<pre><code class="language-ymir">Baz
Foo
Bar
</code></pre>
<p><br> The construction order is perfectly predictible, but should not
have an impact on the program behavior. So it is probably not a good
idea to rely on it.</p>
<a class="header" href="print.html#parent-class-destruction" id="parent-class-destruction"><h2>Parent class destruction</h2></a>
<p>In contrast to construction, the parent destructor is the last
operation of the destruction of a heir class. The parent destructor is
always called, there is no way to avoid it (aside exiting the
program).</p>
<pre><code class="language-ymir">import std::io;

class Foo {    
    pub self () {}
    __dtor (mut self) {
        println (&quot;Destroying Foo&quot;);
        println (&quot;====&quot;);
    }
}

class Bar over Foo {
    pub self () {}

    __dtor (mut self) {
        println (&quot;====&quot;);
        println (&quot;Destroying Bar&quot;);
        return {} // desperately trying to avoid parent destruction
    }
}

def foo () {
    let _ = Bar::new ();
}

def main () {
    loop {
        foo ();
    }
}
</code></pre>
<p><br>
Results:</p>
<pre><code>====
Destroying Bar
Destroying Foo
====
====
Destroying Bar
Destroying Foo
====
====
Destroying Bar
Destroying Foo
====
...
</code></pre>
<a class="header" href="print.html#method-overriding" id="method-overriding"><h2>Method overriding</h2></a>
<p>The keyword <code>over</code> is used to override a method. Methods <strong>cannot</strong> be
implicitly overriden by omitting the <code>over</code> keyword and using the
<code>def</code> keyword. The signature of the method must be strictly identical
to the one of the ancestor method, including privacy, and argument
mutability. Of course, private methods cannot be overriden, because
hidden to heir classes, but protected and public methods can be
overriden. In the following example, a class <strong><code>Shape</code></strong> define the
method <strong><code>area</code></strong>. This method is public, and then can be overriden
by heir classes. The class <strong><code>Circle</code></strong> and <strong><code>Rectangle</code></strong> overrides
the methods.</p>
<pre><code class="language-ymir">import std::io
    
class Shape {
    pub self () {}
    
    pub def area (self) -&gt; f64 
    0.0
}

class Circle over Shape {
    let _radius : f64;
    pub self (radius : f64) with _radius = radius {}
    
    pub over area (self) -&gt; f64 {
        import std::math;
        math::PI * (self._radius * self._radius)
    }
}

class Square over Shape {
    let _side : f64;
    pub self (side : f64) with _side = side {}
    
    pub over area (self) -&gt; f64 {
        self._side * self._side
    }
    
}

def main () {
    let mut s : &amp;Shape = Circle::new (12.0);
    println (s.area ());
    
    s = Square::new (3.0);
    println (s.area ());	
}
</code></pre>
<p><br>
Results:</p>
<pre><code>452.389342
9.000000
</code></pre>
<a class="header" href="print.html#override-mutable-method" id="override-mutable-method"><h3>Override mutable method</h3></a>
<p>The mutability of the method must be respected in the heir class. This
means that mutable method must be mutable in the heir, and immutable
methods must be immutable in the heir.</p>
<pre><code class="language-ymir">class Foo {
    pub self () {}
    
    pub def foo (mut self)-&gt; void {}
    
    pub def bar (self)-&gt; void {}
}

class Bar over Foo {
    pub self () {}
    
    pub over foo (self)-&gt; void {}
    
    pub over bar (mut self)-&gt; void {}
}
</code></pre>
<p><br>
Errors:</p>
<pre><code class="language-error">Error : when validating main::Bar
 --&gt; main.yr:(9,7)
 9  ┃ class Bar over Foo {
    ╋       ^^^
    ┃ Error : the method (const self) =&gt; main::Bar::foo ()-&gt; void marked as override does not override anything
    ┃  --&gt; main.yr:(12,11)
    ┃ 12  ┃ 	pub over foo (self)-&gt; void {}
    ┃     ╋ 	         ^^^
    ┃     ┃ Note : candidate foo --&gt; main.yr:(4,10) : (mut self) =&gt; main::Foo::foo ()-&gt; void
    ┃     ┗━━━━━━ 
    ┃ Error : the method (mut self) =&gt; main::Bar::bar ()-&gt; void marked as override does not override anything
    ┃  --&gt; main.yr:(14,11)
    ┃ 14  ┃ 	pub over bar (mut self)-&gt; void {}
    ┃     ╋ 	         ^^^
    ┃     ┃ Note : candidate bar --&gt; main.yr:(6,10) : (const self) =&gt; main::Foo::bar ()-&gt; void
    ┃     ┗━━━━━━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="print.html#final-methods" id="final-methods"><h3>Final methods</h3></a>
<p>A base class can flag its method to avoid overriding. This flag is
placed as a <em>custom modifier</em> before the name of the method.</p>
<pre><code class="language-ymir">class Foo {
    pub self () {}
    
    pub def @final foo (self) {}
}

class Bar over Foo {
    pub self () {}

    pub over foo (self) {}
}
</code></pre>
<p><br></p>
<p>Errors:</p>
<pre><code class="language-error">Error : when validating main::Bar
 --&gt; main.yr:(7,7)
 7  ┃ class Bar over Foo {
    ╋       ^^^
    ┃ Error : cannot override final method (const self) =&gt; main::Foo::foo ()-&gt; void
    ┃  --&gt; main.yr:(10,14)
    ┃ 10  ┃     pub over foo (self) {}
    ┃     ╋              ^^^
    ┃     ┃ Note : 
    ┃     ┃  --&gt; main.yr:(4,20)
    ┃     ┃  4  ┃     pub def @final foo (self) {}
    ┃     ┃     ╋                    ^^^
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>This flag can also be used on an overriden method inside a heir
class to avoid further overriding.</p>
<pre><code class="language-ymir">class Foo {
    pub self () {}
    
    pub def foo (self) {}
}

class Bar over Foo {
    pub self () {}

    pub over @final foo (self) {}
}

class Baz over Bar {
    pub self () {}

    pub over foo (self) {}
}
</code></pre>
<p><br>
Errors:</p>
<pre><code class="language-error">Error : when validating main::Baz
 --&gt; main.yr:(13,7)
13  ┃ class Baz over Bar {
    ╋       ^^^
    ┃ Error : cannot override final method (const self) =&gt; main::Bar::foo ()-&gt; void
    ┃  --&gt; main.yr:(16,14)
    ┃ 16  ┃     pub over foo (self) {}
    ┃     ╋              ^^^
    ┃     ┃ Note : 
    ┃     ┃  --&gt; main.yr:(10,21)
    ┃     ┃ 10  ┃     pub over @final foo (self) {}
    ┃     ┃     ╋                     ^^^
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="print.html#abstract-class" id="abstract-class"><h2>Abstract class</h2></a>
<p>A class can be abstract, this means that the class cannot be
instantiated even if it has a constructor. An abstract class can
declare methods without body, these methods must be overriden by heir
classes. An abstract must have a constructor to be heritable, this
constructor being called by the heir classes. Not that an abstract
class can have no public constructors, but that a class that have no
public constructors is not necessarily abstract.</p>
<pre><code class="language-ymir">class @abstract Shape {
    prot self () {} // need a constructor to be inheritable
    
    pub def area (self)-&gt; f64; // Method does not need a body
}

class Circle over Shape {
    let _radius : f64;
    pub self (radius : f64) with _radius = radius {}
    
    pub over area (self) -&gt; f64 {
        import std::math;
        math::PI * (self._radius * self._radius)
    }
}

def main () {
    let s : Shape = Circle::new (12);
    println (s.area ());
}
</code></pre>
<a class="header" href="print.html#method-with-no-body" id="method-with-no-body"><h3>Method with no body</h3></a>
<p>A method of an abstract class can have a body, and thus behave as any
method of any class. It can also have no body, but in that case heir
class must override this method. Otherwise the class is
incomplete. Abstract class can be heir class, in that case they don't
need to override the methods without body.</p>
<pre><code class="language-ymir">class @abstract Foo {
    pub self () {}
    
    pub def foo (self);
}

class @abstract Bar over Foo {
    pub self () {}
}

class Baz over Bar {
    pub self () {}
}
</code></pre>
<p><br>
Error:</p>
<pre><code class="language-error">Error : when validating main::Baz
 --&gt; main.yr:(11,7)
11  ┃ class Baz over Bar {
    ╋       ^^^
    ┃ Error : the class main::Baz is not abstract, but does not override the empty parent method (const self) =&gt; main::Foo::foo ()-&gt; void
    ┃  --&gt; main.yr:(11,7)
    ┃ 11  ┃ class Baz over Bar {
    ┃     ╋       ^^^
    ┃     ┃ Note : 
    ┃     ┃  --&gt; main.yr:(4,13)
    ┃     ┃  4  ┃     pub def foo (self);
    ┃     ┃     ╋             ^^^
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="print.html#final-class" id="final-class"><h2>Final class</h2></a>
<p>Final classes declared with the custom attributes <code>@final</code> defines
classes that cannot have heirs. A final class, can be an heir class,
or a base class. If the class is a base class, strong optimization can
be made by the compiler, (no vtable required, and call of the methods
are direct and way faster). For that reason, it is a good practice to
flag classes for which we are certain they cannot be inheritable. This
optimization is also done on final methods (if they are not overriden,
i.e. final when define for the first time), thus this is a good
practice to flag methods for which we are certain they won't be
overriden. This optimization cannot be done if the class is not a base
class.</p>
<pre><code class="language-ymir">class @final Foo {
    pub self () {}
    
    pub def foo (self) {}
}

class Bar over Foo {
    pub self () {}
}
</code></pre>
<p><br>
Error:</p>
<pre><code class="language-error">Error : the base class main::Foo is marked as final
 --&gt; main.yr:(7,16)
 7  ┃ class Bar over Foo {
    ╋                ^^^


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p><em>Contribution</em>: It is possible to have an abstract and final class. I
didn't find any use case for that, maybe that is completely useless,
and must be prohibited.</p>
<a class="header" href="print.html#casting-base-class-objects-to-heir-class" id="casting-base-class-objects-to-heir-class"><h2>Casting base class objects to heir class</h2></a>
<p>In many languages (such as C++, D, Java, or Scala) polymorphism gives
the possibility to cast an object of a base class into an object of an
heir class. This is not possible in <em>Ymir</em> because this behavior is
not safe. We will see in the chapter <a href="https://gnu-ymir.github.io/Documentations/en/pattern/">Pattern
matching</a> how
to achieve a cast of an object into a heir class, in a safe way.</p>
<p>However, the <em>std</em> provides a safe shortcut that can be used to
achieve the cast. This shortcut is by using the template function
<strong><code>to</code></strong> of the module <strong><code>std::conv</code></strong>. This function throws a
<strong><code>CastFailure</code></strong> exception when the cast failed, (safe in <em>Ymir</em>
means that the error can be managed, and has to be managed in fact, as
we will see in the chapter on <a href="https://gnu-ymir.github.io/Documentations/en/errors/main.html">Error
handling</a>). In
the following example, two objects are stored in the variable <strong><code>x</code></strong>
and <strong><code>y</code></strong>, whose type are <strong><code>&amp;Foo</code></strong>. The first cast at line <strong><code>18</code></strong>
works, because the variable <strong><code>x</code></strong> indeed contains an object of type
<strong><code>&amp;Bar</code></strong>, however the cast at line <strong><code>19</code></strong> does not work, the
variable <strong><code>y</code></strong> stores an object of type <strong><code>&amp;Foo</code></strong>.</p>
<pre><code class="language-ymir">import std::conv;

class Foo {
    pub self () {}
}

class Bar over Foo {
    pub self () {}
}


def main ()
    throws &amp;CastFailure // the possible errors are rethrown, so the program ends if there is an error 
{
    let x : &amp;Foo = Bar::new ();
    let y : &amp;Foo = Foo::new ();
    
    let _ : &amp;Bar = x.to!(&amp;Bar) (); // possibly throw a &amp;CastFailure
    let _ : &amp;Bar = y.to!(&amp;Bar) (); // here as well, (and actually throw it)
}
</code></pre>
<p><br></p>
<p>The following result happens because an error is thrown by the main
function, and then unmanaged by the program. The stacktrace is printed
because the program was compiled in debug mode. We can see in this
trace (at line <strong><code>11</code></strong>) that the error was effectively thrown by the
conversion at line <strong><code>19</code></strong>.</p>
<pre><code>Unhandled exception
Exception in file &quot;/home/emile/gcc/gcc-install/bin/../lib/gcc/x86_64-pc-linux-gnu/9.3.0/include/ymir/std/conv.yr&quot;, at line 820, in function &quot;std::conv::to(&amp;(main::Bar),&amp;(main::Foo))::to&quot;, of type std::conv::CastFailure.
╭  Stack trace :
╞═ bt ╕ #1
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #2
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #3 in function std::conv::toNP94main3BarNP94main3Foo::to (...)
│     ╘═&gt; /home/emile/gcc/gcc-install/bin/../lib/gcc/x86_64-pc-linux-gnu/9.3.0/include/ymir/std/conv.yr:820
╞═ bt ╕ #4 in function main (...)
│     ╘═&gt; /home/emile/Documents/test/ymir/main.yr:19
╞═ bt ╕ #5
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #6 in function main
│     ╘═&gt; /home/emile/Documents/test/ymir/main.yr:12
╞═ bt ╕ #7
│     ╘═&gt; /lib/x86_64-linux-gnu/libc.so.6:??
╞═ bt ═ #8 in function _start
╰
Aborted (core dumped)
</code></pre>
<a class="header" href="print.html#trait" id="trait"><h1>Trait</h1></a>
<p>Traits are used to define as their name suggest traits that can be
implemented by a class. To define them, the keyword <strong><code>trait</code></strong> is
used. A <em>trait</em> is not a type, and can only be implemented by class,
for that reason, a variable or a value cannot be of a <em>trait</em> type.</p>
<p>An example of a trait, is presented in the following source block. The
idea of this trait, is to ensure that every class, implementing it,
have a public method named <strong><code>print</code></strong> that can be called without
parameters.</p>
<pre><code class="language-ymir">trait Printable {
    pub def print (self);	
}
</code></pre>
<p><br></p>
<p>When a class implements a trait, all the method declared in the trait
are added in the definition of the class. If the class is not abstract
all the method of the traits must have a body. For example, if a non
abstract class implement the trait <strong><code>Printable</code></strong>, thus it must
override the method <strong><code>print</code></strong> to add a body to it.</p>
<pre><code class="language-ymir">import std::io

class Point {
    // ... Constructors and attributes
    
    impl Printable {
        // Try to remove the following definition
        pub over print (self) {
            print (&quot;Point {&quot;, self._x, &quot;, &quot;, self._y, &quot;}&quot;);
        }
    }	
}
</code></pre>
<p><br></p>
<p>A trait can provide a default behavior for the method it defines. The
body of the method is validated for each implementation. In the
following example, the method <strong><code>print</code></strong> defined in the trait
<strong><code>Printable</code></strong>, prints the typeid of the class that implement the
traits. One can note, that the behavior of this function is different
for each class that implements it, that is why it is only validated
when a class implement the trait.</p>
<pre><code class="language-ymir">mod main; 

trait Printable {
    pub def print (self) {
        import std::io;
        print (typeof (self)::typeid);
        // Here we don't know the type yet
    }
}

class Point {
    // ... Constructors and attributes

    impl Printable;  // 'print' method prints (&quot;main::Point&quot;)
}

class Line {
    // ... Constructors and attributes

    impl Printable;  // 'print' method prints (&quot;main::Line&quot;)
}
</code></pre>
<p><br></p>
<p><strong>Warning</strong>: If a trait is never implemented by any class, and have
methods with default behavior, then it is never validated. Thus errors
can be present in this trait, but still pass the compilation. One can
see the trait as a kind of template, this problem being present in
template symbol as well (<em>cf.</em>
<a href="https://gnu-ymir.github.io/Documentations/en/templates/">Templates</a>).</p>
<a class="header" href="print.html#inherit-a-class-implementing-a-trait" id="inherit-a-class-implementing-a-trait"><h2>Inherit a Class implementing a Trait</h2></a>
<p>The methods of a trait can be overriden by heir classes. In order to
do this, heir classes must reimplement the trait, and override the
methods.</p>
<a class="header" href="print.html#simple-reimplementation" id="simple-reimplementation"><h3>Simple reimplementation</h3></a>
<p>In the following example, the class <strong><code>Shape</code></strong> implements
the trait <strong><code>Printable</code></strong>, this trait has a method <strong><code>print</code></strong> with a
default behavior. The class <strong><code>Circle</code></strong> does not reimplement the
trait, thus when calling the method print of a <strong><code>Circle</code></strong> value, the
value <strong><code>main::Shape</code></strong> is printed on the stdout. On the other hand,
the class <strong><code>Rectange</code></strong> reimplement the traits, thus the value
<strong><code>main::Rectangle</code></strong> is printed.</p>
<pre><code class="language-ymir">mod main;

trait Printable {
    pub def print (self) {
        import std::io;
        println (typeof (self)::typeid);
    }
}

class @abstract Shape {
    self () {}
    
    impl Printable;
}

class Circle over Shape {
    pub self () {}
}

class Rectangle over Shape {
    pub self () {}
    
    impl Printable; // reimplement the method print with typeof (self) being main::Rectangle
}

def main () {
    let c = Circle::new ();
    c.print ();
    
    let r = Rectangle::new ();
    r.print ();
}
</code></pre>
<p><br>
Results:</p>
<pre><code>main::Shape
main::Rectangle
</code></pre>
<a class="header" href="print.html#override-implemented-method" id="override-implemented-method"><h3>Override implemented method</h3></a>
<p>Implemented method cannot be overriden without reimplementing the
trait. In the following example, a class <strong><code>Shape</code></strong> implement the
trait <strong><code>Printable</code></strong>, and the class <strong><code>Circle</code></strong> inherits
<strong><code>Shape</code></strong>, and tries to override the method <strong><code>print</code></strong>.</p>
<pre><code class="language-ymir">mod main;
import std::io;

trait Printable {
    pub def print (self);
}

class @abstract Shape {
    self () {}
    
    impl Printable {
        pub over print (self) {
            println (&quot;main::Shape&quot;);
        }
    }
}

class Circle over Shape {
    pub self () {}
    
    pub over print (self) {}
}
</code></pre>
<p><br>
Errors:</p>
<pre><code class="language-error">Error : when validating main::Circle
 --&gt; main.yr:(18,7)
18  ┃ class Circle over Shape {
    ╋       ^^^^^^
    ┃ Error : cannot override the trait method (const self) =&gt; main::Shape::print ()-&gt; void outside the implementation of the trait
    ┃  --&gt; main.yr:(21,14)
    ┃ 21  ┃     pub over print (self) {}
    ┃     ╋              ^^^^^
    ┃     ┃ Note : 
    ┃     ┃  --&gt; main.yr:(12,18)
    ┃     ┃ 12  ┃         pub over print (self) {
    ┃     ┃     ╋                  ^^^^^
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>To prevent the previous error, the class <strong><code>Circle</code></strong> have to
reimplement the trait <strong><code>Printable</code></strong>. When reimplementing a trait in
a heir class, the parent overriding is not taken into account, and the
method of the trait is used. In the following example, the class
<strong><code>Shape</code></strong> implement the trait <strong><code>Printable</code></strong>, that have a method
<strong><code>print</code></strong> with no default behavior. The class <strong><code>Circle</code></strong> tries to
reimplement the trait, but without overriding the <strong><code>print</code></strong>
method. This source code is rejected by the compiler, the class
<strong><code>Circle</code></strong> is not abstract, but has a method with no body.</p>
<pre><code class="language-ymir">mod main;
import std::io;

trait Printable {
    pub def print (self);
}

class @abstract Shape {
    self () {}
    
    impl Printable {
        pub over print (self) {
            println (&quot;main::Shape&quot;);
        }
    }
}

class Circle over Shape {
    pub self () {}
    
    impl Printable;
}
</code></pre>
<p><br>
Errors:</p>
<pre><code class="language-error">Error : when validating main::Circle
 --&gt; main.yr:(18,7)
18  ┃ class Circle over Shape {
    ╋       ^^^^^^
    ┃ Error : the class main::Circle is not abstract, but does not override the empty parent method (const self) =&gt; main::Printable::print ()-&gt; void
    ┃  --&gt; main.yr:(18,7)
    ┃ 18  ┃ class Circle over Shape {
    ┃     ╋       ^^^^^^
    ┃     ┃ Note : 
    ┃     ┃  --&gt; main.yr:(5,10)
    ┃     ┃  5  ┃ 	pub def print (self);
    ┃     ┃     ╋ 	        ^^^^^
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>To resolve that problem, the class <strong><code>Circle</code></strong> must add a body to the
method <strong><code>print</code></strong>. It can happen that a trait defines multiple
methods, and that only some have to be reimplemented by the heir
class. In that case, there is no magical solution, <strong>maybe a
contribution can enhance that</strong>, but every methods must be
reimplemented. In order to mimic the behavior of the parent
implementation, the <strong><code>super</code></strong> keyword can be used.</p>
<pre><code class="language-ymir">class Circle over Shape {
    pub self () {}	

    impl Printable {
    
        pub over print (self)-&gt; void { 
            self::super.print (); // call the print method of the super class 		
        }
    }	
}
</code></pre>
<p><br></p>
<a class="header" href="print.html#trait-privacy" id="trait-privacy"><h2>Trait privacy</h2></a>
<p>Trait implementation is always public. For that reason, privacy
specifier (<strong><code>pub</code></strong>, <strong><code>prot</code></strong> and <strong><code>prv</code></strong>) have no meaning on
implementation.</p>
<p>On the other hand, the trait methods implementation follows the same
rule as the overriding of a parent method. That is to say, the privacy
defined inside the trait must be the same as the privacy defined
inside the implementation.</p>
<a class="header" href="print.html#trait-usage" id="trait-usage"><h2>Trait usage</h2></a>
<p>As said in the beginning of this chapter, traits do not define
types, thus they cannot be used to define the type of a variable. For
example, the following source code has no meaning, <strong><code>Printable</code></strong>
does not define a type.</p>
<pre><code class="language-ymir">mod main;
import std::io;

trait Printable {
    pub def print (self);
}

def foo  (a : Printable) {
    a.print ();
}
</code></pre>
<p><br></p>
<p>Errors:</p>
<pre><code class="language-error">Error : expression used as a type
 --&gt; main.yr:(8,15)
 8  ┃ def foo  (a : Printable) {
    ╋               ^^^^^^^^^


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>If the previous example, is not a valid <em>ymir</em> code, the behavior can
still be implemented in the language. Traits gain interest when
coupled with templates, and a template test can be used to check that
a class implement a trait. More complete information, and example
about templates, and traits specialization are presented in chapter
<a href="https://gnu-ymir.github.io/Documentations/en/templates/">Templates</a>,
but a brief example is presented in the following source code. In this
example, two classes <strong><code>U</code></strong> and <strong><code>V</code></strong> implement the trait
<strong><code>Printable</code></strong>. The function <strong><code>foo</code></strong> takes a parameter whose type
is not specified but must implement the trait <strong><code>Printable</code></strong>. Thus
the function is callable with both <strong><code>U</code></strong> or <strong><code>V</code></strong> as argument.</p>
<pre><code class="language-ymir">mod main;
import std::io;

trait Printable {
    pub def print (self) {
        println (typeof (self)::typeid);
    }
}

class U {
    pub self () {}
    impl Printable;
}

class V {
    pub self () {}
    impl Printable;
}

/**
 * Accept every type, that implements the trait Printable 
 */
def foo {I impl Printable} (a : I) {
    a.print ();
}

def main () {
    foo (U::new ());
    foo (V::new ());
}
</code></pre>
<p><br>
Results:</p>
<pre><code>main::U
main::V
</code></pre>
<a class="header" href="print.html#cast-and-dynamic-typing" id="cast-and-dynamic-typing"><h1>Cast, and dynamic typing</h1></a>
<p>An object instance of a heir class can be casted to an object instance
of an ancestor class. Unlike, casting of integer values,
(e.g. <strong><code>i32</code></strong> to <strong><code>i64</code></strong>), because an object is an aliasable type,
the memory size of the object is not modified. Casting must respect
mutability of the object value. Moreover, this cast can be made
implicitely, as it does not create any problem in memory. In the
following example, the class <strong><code>Bar</code></strong> inherits from the class
<strong><code>Foo</code></strong>. A variable <strong><code>x</code></strong> is created, and is of type
<strong><code>&amp;Bar</code></strong>. At line <strong><code>1</code></strong>, an implicit cast is made of a <strong><code>&amp;Bar</code></strong>
value to a <strong><code>&amp;Foo</code></strong> value, the same cast is made but explicitely at
line <strong><code>1</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

class Foo {
    pub self () {}
    
    pub def foo (self) {
        println (&quot;Foo&quot;);
    }
}

class Bar over Foo {
    pub self () {}
    
    pub over foo (self) {
        println (&quot;Bar&quot;);
    }
}

def baz (f : &amp;Foo) {
    f.foo ();
}

def main () {
    let x = Bar::new ();
    baz (x);
    
    let y = cast!{&amp;Foo} (x);
    y.foo ();
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Bar
Bar
</code></pre>
<a class="header" href="print.html#dynamic-typeinfo" id="dynamic-typeinfo"><h2>Dynamic typeinfo</h2></a>
<p>One can note from the above example, that when a variable contains a
value of type <strong><code>&amp;Foo</code></strong>, that does not necessarily mean that this is
a pure <strong><code>&amp;Foo</code></strong> value, but it can be a <strong><code>&amp;Bar</code></strong>. In object
oriented programming, this principle is denote polyphormism. In the
chapter <a href="https://gnu-ymir.github.io/Documentations/en/primitives/">Basic programming
concepts</a>,
we have seen that every object has specific attributes. Object is no
exception to the rule. The following table lists the default specific
attributes of the object types.</p>
<table><thead><tr><th> Name </th><th> Meaning </th></tr></thead><tbody>
<tr><td> <code>typeid</code> </td><td> The name of the type stored in a value of type [c32] </td></tr>
<tr><td> <code>typeinfo</code> </td><td> A structure of type TypeInfo, containing information about the type </td></tr>
</tbody></table>
<p>These attributes are compile time executed, and thus are static. For
example, in the following source code, the typeid of the class
<strong><code>Bar</code></strong> is printed to stdout, followed by a line that does exactly
the same thing (literraly).</p>
<pre><code class="language-ymir">def main () {
    println (Bar::typeid);
    println (&quot;main::Bar&quot;);
}
</code></pre>
<p><br></p>
<p>When it comes to dynamic typing, it can be interesting to get the
typeinfo of the type of the value that is actually stored inside the
variable (e.g. get the typeinfo of the <strong><code>Bar</code></strong> class, type of the
value contained inside a <strong><code>&amp;Foo</code></strong> variable). To do that, the
specific attribute <strong><code>typeinfo</code></strong> of object is also accessible from
the value directly, and this time dynamically.</p>
<pre><code class="language-ymir">def main () {
    let x = Bar::new ();
    let y : &amp;Foo = x;
    
    println (y::typeinfo);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>core::typeinfo::TypeInfo(13, 16, [core::typeinfo::TypeInfo(13, 16, [], main::Foo)], main::Bar)
</code></pre>
<p><br></p>
<p>The result presented above, gives the following information : 1)
we have a object, 2) its size is 16 bytes, 3) it has an ancestor
(object, size 16 bytes, no ancestor, named <strong><code>main::Foo</code></strong>), 4) its
name is <strong><code>main::Bar</code></strong>.</p>
<p>The <strong><code>TypeInfo</code></strong> returned by the <strong><code>typeinfo</code></strong> attributes (either
dynamically or statically), is a structure whose definition is the
following. The <strong><code>inner</code></strong> fields depend on the value of the
<strong><code>typeid</code></strong> field, for example, when dealing with an object it stores
the ancestor <strong><code>TypeInfo</code></strong>, and when dealing with slice, it stores
the <strong><code>TypeInfo</code></strong> of the type contained inside the slice.</p>
<pre><code class="language-ymir">pub struct
| typeid : TypeIDs
| size   : usize
| inner  : [TypeInfo]
| name   : [c32] 
 -&gt; TypeInfo;

pub enum : u32
| ARRAY        = 1u32
| BOOL         = 2u32
| CHAR         = 3u32
| CLOSURE      = 4u32
| FLOAT        = 5u32
| FUNC_PTR     = 6u32
| SIGNED_INT   = 7u32
| UNSIGNED_INT = 8u32
| POINTER      = 9u32
| SLICE        = 10u32
| STRUCT       = 11u32
| TUPLE        = 12u32
| OBJECT       = 13u32
| VOID         = 14u32
 -&gt; TypeIDs;
</code></pre>
<p><br></p>
<p>The typeinfo of a class is stored in the text and is accessible from
the vtable of the object. One can note that <strong><code>Bar</code></strong> and <strong><code>Foo</code></strong>
have a size of 16 bytes, despite the fact that they store no
fields. This is due to two pointers that are stored inside every
objects, the first pointer is refering to the monitor of the object
(<em>cf.</em> <a href="">Parallelism</a>), and the second one points the the vtable of
the object.</p>
<a class="header" href="print.html#object" id="object"><h2>Object</h2></a>
<p><em>Ymir</em> have a type named <strong><code>Object</code></strong>, that can used to cast any
object into that type. The reverse is impossible. We have seen that
the object are not inheriting from a global ancestor, and this is
really not the case. This cast unlike casting to parent class objects,
cannot be made implicitely. We can see the <strong><code>&amp;(Object)</code></strong> type as the
<strong><code>&amp;(void)</code></strong> type, that can store any pointer, but for
objects. Unlike <strong><code>&amp;(void)</code></strong> (in which by the way we can't cast
objects), <strong><code>&amp;Object</code></strong> stores one valuable information, it stores a
valid object value, with a vtable, a monitor, a typeinfo, and <strong>cannot
be <code>null</code></strong>.</p>
<p>In the following example, a pattern matching is used to check the type
of the object that is returned by the <strong><code>foo</code></strong> function. This is
discussed in chapter <a href="https://gnu-ymir.github.io/Documentations/en/pattern/">Pattern
Matching</a>.</p>
<pre><code class="language-ymir">def foo ()-&gt; &amp;Object {
    cast!{&amp;Object} (Foo::new ())
}

def main () {
    match foo () {
        Foo () =&gt; {
            println (&quot;I got a Foo !&quot;);
        }
    }
}
</code></pre>
<p><br>
Results:</p>
<pre><code>I got a Foo !
</code></pre>
<p><br></p>
<p>Some function of the standard library uses the <strong><code>Object</code></strong> type to
return values, when it is impossible statically to get more accurate
information about the type (e.g. [Packable]
(https://gnu-ymir.github.io/Documentations/en/traits/serialize.html).)</p>
<a class="header" href="print.html#functions-1" id="functions-1"><h1>Functions</h1></a>
<p>We have seen in the chapter <a href="https://gnu-ymir.github.io/Documentations/en/primitives/functions.html">Basic programming
concepts</a>
how functions are written. <em>Ymir</em> can be used as a functional
language, thus functions can also be considered as values. In this
chapter we will see more advanced function systems, named function
pointer and closure.</p>
<a class="header" href="print.html#function-pointer" id="function-pointer"><h2>Function pointer</h2></a>
<p>A function pointer is a value that contains a function. It can be used
for example, to pass a function, as an argument to other
functions. The type of a function pointer is written using the keyword
<strong><code>fn</code></strong>, and have nearly the same syntax as a function prototype, but
without a name, and without naming the parameters.</p>
<pre><code class="language-ymir">import std::io

def foo (f : fn (i32)-&gt; i32) -&gt; i32 {
    f (41)
}

def addOne (x : i32)-&gt; i32
    x + 1


def main () {
    let x = foo (&amp;addOne);
    println (x);
}
</code></pre>
<p><br></p>
<p>In the above example, we have specified that the function <strong><code>foo</code></strong>
takes a function pointer as first parameter. This function pointer, is
a function that takes an <strong><code>i32</code></strong> value and return another <strong><code>i32</code></strong> value.
In the main function, the ampersand (<strong><code>&amp;</code></strong>) unary operator is used
to transform the function symbol <strong><code>addOne</code></strong> into a function
pointer. This function pointer is then passed to the function
<strong><code>foo</code></strong>, which calls it and return its value.</p>
<p>Results:</p>
<pre><code>42
</code></pre>
<a class="header" href="print.html#function-pointer-using-reference" id="function-pointer-using-reference"><h3>Function pointer using reference</h3></a>
<p>We have seen that references is not a type, in the chapter <a href="https://gnu-ymir.github.io/Documentations/en/advanced/references.html">Alias and
References</a>. However,
function prototype sometimes takes reference value as parameter. This
must be replicated in the prototype of the function pointer. For that
reason, the <strong><code>ref</code></strong> keyword can be used in the prototype of a
function pointer type.</p>
<p>In the following example, the function <strong><code>mutAddOne</code></strong> change the
value of a reference variable <strong><code>x</code></strong>, and add one to it. The function
<strong><code>foo</code></strong> takes a function pointer as first parameter, and calls it on
a mutable local variable <strong><code>x</code></strong> by reference (it is important).</p>
<pre><code class="language-ymir">import std::io

def foo (f : fn (ref mut i32)-&gt; void) -&gt; i32 {
    let mut x = 41;
    f (ref x);
    x
}

def mutAddOne (ref mut x : i32) {
    x = x + 1;
}

def main () {
    let x = foo (&amp;mutAddOne);
    println (x);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>42
</code></pre>
<p><br></p>
<p>The prototype of the function pointer must be strictly respected, for
obvious reasons. And as for normal functions, alias and references
must be strictly respected as well. For example, in the follow
example, the function <strong><code>foo</code></strong> tries to call the function pointer
that takes a reference argument, using a simple value. And the
<strong><code>main</code></strong> function tries to call the <strong><code>foo</code></strong> function, with a
function pointer that does not take a reference parameter.</p>
<pre><code class="language-ymir">import std::io

def foo (f : fn (ref mut i32)-&gt; void) -&gt; i32 {
    let mut x = 41;
    f (x);
    x
}

def mutAddOne (x : i32) {
    println (x);
}

def main () {
    let x = foo (&amp;mutAddOne);
    println (x);
}
</code></pre>
<p><br></p>
<p>We have two errors, first the compiler does not allow an implicit
referencing of the variable <strong><code>x</code></strong> at line <strong><code>5</code></strong>, and second the
compiler does not allow an implicit cast of a value of type <strong><code>fn (i32)-&gt; void</code></strong> to <strong><code>fn (ref mut i32)-&gt; void</code></strong>.</p>
<pre><code class="language-error">Error : the call operator is not defined for &amp;fn(ref mut i32)-&gt; void and {mut i32}
 --&gt; main.yr:(5,7)
 5  ┃     f (x);
    ╋       ^ ^
    ┃ Error : implicit referencing of type mut i32 is not allowed
    ┃  --&gt; main.yr:(5,8)
    ┃  5  ┃     f (x);
    ┃     ╋        ^
    ┃ Note : for parameter i32 --&gt; main.yr:(3,26) of f
    ┗━━━━━━ 

Error : the call operator is not defined for main::foo and {&amp;fn(i32)-&gt; void}
 --&gt; main.yr:(14,17)
14  ┃     let x = foo (&amp;mutAddOne);
    ╋                 ^          ^
    ┃ Note : candidate foo --&gt; main.yr:(3,5) : main::foo (f : &amp;fn(ref mut i32)-&gt; void)-&gt; i32
    ┃     ┃ Error : incompatible types &amp;fn(ref mut i32)-&gt; void and &amp;fn(i32)-&gt; void
    ┃     ┃  --&gt; main.yr:(14,18)
    ┃     ┃ 14  ┃     let x = foo (&amp;mutAddOne);
    ┃     ┃     ╋                  ^
    ┃     ┃ Note : for parameter f --&gt; main.yr:(3,10) of main::foo (f : &amp;fn(ref mut i32)-&gt; void)-&gt; i32
    ┃     ┗━━━━━━ 
    ┗━━━━━┻━ 

Error : undefined symbol x
 --&gt; main.yr:(15,14)
15  ┃     println (x);
    ╋              ^


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="print.html#lambda-function" id="lambda-function"><h2>Lambda function</h2></a>
<p>Lambda functions are anonymous functions that have the same behavior
as normal function, but don't have a name. They are declared using the
token <code>|</code> surrounding the parameters instead of parentheses in order
to dinstinguish them from tuple. The following code block presents the
syntax of the lambda functions.</p>
<pre><code class="language-grammar">lambda_func := '|' (var_decl (',' var_decl)*)? '|' ('-&gt;' type)? ('=&gt;')? expression
var_decl := Identifier (':' type)?
</code></pre>
<p><br></p>
<p>The following example shows a simple usage of a lambda function. This
function declared at line <strong><code>4</code></strong>, and stored in the variable <strong><code>x</code></strong>,
takes two parameters <strong><code>x</code></strong> and <strong><code>y</code></strong> of type <strong><code>i32</code></strong>, and return
their sum.</p>
<pre><code class="language-ymir">import std::io

def main () {
    let x = |x : i32, y : i32|-&gt; i32 { 
        x + y
    };
    println (x (1, 2));
}
</code></pre>
<p><br></p>
<p>As one can note, there is no conflict between the variable <strong><code>x</code></strong>
declared in the function <strong><code>main</code></strong>, and the first parameter of the
lambda function also named <strong><code>x</code></strong>. This is due to the fact that the
lambda function does not enclose the context of the function that have
created it. In other words, lambda functions behave as normal local
function, accessible only inside the function that have declared them
(<em>cf.</em>  <a href="https://gnu-ymir.github.io/Documentations/en/primitives/functions.html#scope-declaration">Scope
declaration</a>).</p>
<p>In many cases the type of the parameters and return type can be
infered, and are therefore optional. The above example can then be
rewritten into the following example. In this next example, the lambda
function can be called with any values, as long as the binary addition
(<strong><code>+</code></strong>) operator is defined between the two values.</p>
<pre><code class="language-ymir">import std::io

def main () {
    let x = |x, y| x + y;	
    println (x (1, 2));
    
        
    // The types are not given, then you can also write 
    println (x (1.3, 2.9));	
}
</code></pre>
<p><br></p>
<p>The token <code>=&gt;</code> can be added after the prototype of the lambda, to make
it a bit more readable. It is just syntaxic and has no impact on the
behavior of the lambda.</p>
<pre><code class="language-ymir">import std::io

def main () {
    let x = |x, y| =&gt; x + y;	
    println (x (1, 2));
}
</code></pre>
<p><br></p>
<p>Lambda functions are directly function pointers, and then can be used
as such without needing the unary ampersand (<strong><code>&amp;</code></strong>) operator. In the
following example, the function <strong><code>foo</code></strong> takes a function pointer as
first parameter, and two <strong><code>i32</code></strong> values as second and third
parameters. This function calls the function pointer twice, and add
the result. A lambda function is used in the <strong><code>main</code></strong> function as
the first argument for the <strong><code>foo</code></strong> function.</p>
<pre><code class="language-ymir">import std::io

def foo (f : fn (i32, i32)-&gt; i32, x : i32, y : i32) -&gt; i32 {
    f (x, y) + f (y, x)
}

def main () {
    let x = (|x, y|=&gt; x * y).foo (3, 7);
    
    // uniform call syntax is used, but you can of course write it as follows : 
    // foo (|x, y| x*y, 3, 7);
    println (x);
}
</code></pre>
<p>Results:</p>
<pre><code>42
</code></pre>
<p><br></p>
<p>Lambda function that are not typed are special element, that does not
really have a value at runtime, and are closer to <em>compile time
values</em> (presented in a future chapter <a href="https://gnu-ymir.github.io/Documentations/en/templates/cte.html">Compile time
execution</a>).
When the whole type of a lambda cannot be infered by the compiler
(types of the parameters, and the type of the return type), then the
value cannot be passed to a mutable variable. <em>Ymir</em> allows to put an
untyped lambda inside an immutable var, to ease its usage, but the
lambda still does not have any value. For that reason, the second line
of the following example is possible, but not the third.</p>
<pre><code class="language-ymir">def main () {
    let x = |x| x + 1;
    let mut y = x;
}
</code></pre>
<p><br>
Errors:</p>
<pre><code class="language-error">Error : the type mut fn (any)-&gt; any is not complete
 --&gt; main.yr:(2,10)
 2  ┃ 	let x = |x| x + 1;
    ╋ 	        ^
    ┃ Note : 
    ┃  --&gt; main.yr:(3,10)
    ┃  3  ┃ 	let mut y = x;
    ┃     ╋ 	        ^
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>The same problem happens when an uncomplete lambda function is used as
the value of a function. To resolve the problem, and because the
return type of a function is always complete when the function is
validated (or there were other previous errors), the keyword
<strong><code>return</code></strong> can be used. Thanks to that statement, the compiler has
additional knowledge, and can infer the type of the lambda function
from the return type of the function.</p>
<pre><code class="language-ymir">import std::io

def foo () -&gt; fn (i32)-&gt; i32 {
    return |x| =&gt; x + 12 // the compiler tries to transform the lambda function into a function pointer fn (i32)-&gt; i32
}

def main () {
    let x = foo ();
    println (x (30));
}
</code></pre>
<p><br></p>
<p><strong>Contribution</strong>: Resolve that problem when it seems obvious, for
example in the previous example, maybe the type of the block can be
infered directly?</p>
<a class="header" href="print.html#closure" id="closure"><h2>Closure</h2></a>
<p>As said earlier, a lambda function behave like a local private
function, and thus has no access to the context of the function that
have declared it. In the following example, the lambda function
declared at line <strong><code>5</code></strong> tries to access the variable <strong><code>i</code></strong> declared
at line <strong><code>4</code></strong>. This is impossible, the variable <strong><code>i</code></strong> exists in a
different context that the lambda function.</p>
<pre><code class="language-ymir">import std::io

def main () {
    let i = 12;
    let x = | | {
        println (i);
    };
    x ();
}
</code></pre>
<p><br>
Errors:</p>
<pre><code>Error : undefined symbol i
 --&gt; main.yr:(6,12)
 6  ┃ 		println (i);
    ╋ 		         ^

Error : undefined symbol x
 --&gt; main.yr:(8,2)
 8  ┃ 	x ();
    ╋ 	^


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>Closure are a function pointer that capture the environment of the
function that has declared them. In <em>Ymir</em> there is only one kind of
accepted closure, that is called the move closure.</p>
<a class="header" href="print.html#copy-closure" id="copy-closure"><h3>Copy closure</h3></a>
<p>A copy closure is a special kind of lambda function, that is declared
by using the keyword <strong><code>move</code></strong> in front of a lambda literal. The
closure as an immutable access to all the variable declared inside the
scope of the parent function. This closure is called a <em>copy closure</em>
because the access of the variable is made by copy (a first level copy
<em>cf.</em> <a href="https://gnu-ymir.github.io/Documentations/en/advanced/copies.html">Copy and Deep
copy</a>).
Because closure captures a context in addition to a function pointer,
the simple function pointer type is no more sufficient, and a new type
is introduced. The syntax of the closure type is created with the
keyword <strong><code>dg</code></strong> instead of <strong><code>fn</code></strong> (<em>dg</em> stands for delegate). A
delegate is a function pointer with an environment, and is the general
case of a closure (we will see in next section, a case of delegate
that are not closure).</p>
<p>In the following example, the <em>copy closure</em> declared at line <strong><code>9</code></strong>
enclosed the scope of the function <strong><code>foo</code></strong>, and thus has access to
the variable <strong><code>i</code></strong>. However, the enclosed variable is immutable (and
is a copy).</p>
<pre><code class="language-ymir">import std::io

def bar (f : dg (i32)-&gt; i32) -&gt; i32 {
    f (12)
}

def foo () {
    let i = 30;
    let x = bar (move |x|=&gt; x + i);
    println (x);
}

def main () {
    foo ();
}
</code></pre>
<p><br></p>
<p>The above source code in the context of the <strong><code>foo</code></strong> function, can be
illustrated by the following figure.</p>
<p><br></p>
<p>&lt;img src=&quot;https://gnu-ymir.github.io/Documentations/en/functions/closure.png&quot; alt=&quot;drawing&quot; height=&quot;500&quot;, style=&quot;display: block; margin-left: auto;  margin-right: auto;&quot;&gt;</p>
<p><br></p>
<p>As one can note, the variable <strong><code>i</code></strong> enclosed in the closure is not
the same as the variable <strong><code>i</code></strong> of the <strong><code>main</code></strong> function. This has
two impact:</p>
<ul>
<li>a) <em>copy closure</em> can be returned safely from functions,
indeed even when the variable <strong><code>i</code></strong> does not exist anymore as the
function <strong><code>foo</code></strong> is exited, a copy of it is still accessible in the
heap (note that this is the same for aliasable types, that are in the
heap in any case). For example:</li>
</ul>
<pre><code class="language-ymir">import std::io;

def foo ()-&gt; dg ()-&gt; i32 {
    let i = 30;
    return (move || =&gt; i + 12);
}

def main () {
    let x = foo ();
    println (x ()); // enclosed i does not exists, but thats not a problem
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>42
</code></pre>
<p><br></p>
<ul>
<li>b) the value of the enclosed <strong><code>i</code></strong> is independant
from the value of the variable <strong><code>i</code></strong> in the <strong><code>foo</code></strong> function,
meaning that there is no way for the <strong><code>foo</code></strong> function to change the
value of the variable <strong><code>i</code></strong> inside the closure after its creation. For example :</li>
</ul>
<pre><code class="language-ymir">import std::io;

def main () {
    let mut i = 30;
    let x = move || =&gt; i + 12;
    i = 11; // no impact on the closure of x
    println (x ());    
    
    let y = move || =&gt; i + 12;
    println (y ());
}
</code></pre>
<p><br>
Results:</p>
<pre><code>42
23
</code></pre>
<p><br></p>
<p>By using aliasable types, this limitation can be bypassed, for example
a slice can be used to enclosed the value of i, and access it from the
closure, without removing the guarantees of the <em>copy closure</em>, this
is illustrated in the following example. <strong>Warning</strong>: if you might be
tempted to use a pointer on the <strong><code>i</code></strong> variable, its highly not
recommended. Indeed, pointing to a local variable remove the guarantee
we introduced earlier in the point (a) - (in general using pointer -
not function pointer - to value is a bad idea, and should be
prohibited outside the std).</p>
<pre><code class="language-ymir">import std::io;

def main ()
    throws &amp;OutOfArray
{
    let dmut i = [12];
    let x = move || =&gt; {
        i[0] + 12
    } catch {
        _ =&gt; {
            0
        }
    };
        
    i [0] = 30;
    println (x ());
}
</code></pre>
<p><br></p>
<p>In the above example, the <em>copy closure</em> access to the first index of
the slice <strong><code>i</code></strong>. This is a unsafe operation, the slice can be empty,
this is why a catch is made. Information about catch is not presented
here, and will be discussed in a future chapter <a href="https://gnu-ymir.github.io/Documentations/en/errors/main.html">Error
handling</a>. Here
because the slice is not empty when the closure is called, the access
works.</p>
<p>Results:</p>
<pre><code>42
</code></pre>
<a class="header" href="print.html#method-delegate" id="method-delegate"><h3>Method delegate</h3></a>
<p>A method is a function pointer associated with a object instance, then
they can be seen as delegate. The name closure is not used here,
because nothing is really enclosed as in <em>copy closure</em> over function
context, so the name <em>delegate</em> being a more global term is used. A
delegate is a function operating on an object, for which we don't know
the exact type.</p>
<p>A method can be transformed into a delegate using the unary ampersand
(<strong><code>&amp;</code></strong>) operator, on a method associated to an object instance.</p>
<pre><code class="language-ymir">import std::io;

class Foo {
    pub let mut i = 0;
    
    pub self () {}
    
    pub def foo (self) -&gt; void {
        println (self.i);
    }
}

def main () {
    let dmut a = Foo::new (), dmut b = Foo::new ();
    let x : (dg ()-&gt; void) = &amp;a.foo;
    let y = &amp;b.foo;
    
    a.i = 89;
    b.i = 42;
    
    x ();
    y ();	
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>89
42
</code></pre>
<p><br></p>
<p>Unlike <em>copy closure</em> a method can have a mutable access to the object
associated to it. In that case, an explicit alias must be made on the
object instance, when creating the delegate, otherwise the compiler
throws an error.</p>
<pre><code class="language-ymir">import std::io;

class Foo {
    let mut _i = 0;
    
    pub self () {}
    
    pub def foo (mut self) {
        self._i = 42;
    }

    impl Streamable;
}

def main () {
    let dmut a = Foo::new ();

    let x = &amp;(a.foo);

    x ();

    println (a);

}
</code></pre>
<p><br>
Errors:</p>
<pre><code class="language-error">Error : undefined operator &amp; for type (a).foo
 --&gt; main.yr:(18,13)
18  ┃     let x = &amp;(a.foo);
    ╋             ^
    ┃ Note : candidate foo --&gt; main.yr:(8,13) : (mut self) =&gt; main::Foo::foo ()-&gt; void
    ┃     ┃ Error : discard the constant qualifier is prohibited, left operand mutability level is 2 but must be at most 1
    ┃     ┃  --&gt; main.yr:(18,13)
    ┃     ┃ 18  ┃     let x = &amp;(a.foo);
    ┃     ┃     ╋             ^
    ┃     ┃     ┃ Note : implicit alias of type mut &amp;(mut main::Foo) is not allowed, it will implicitly discard constant qualifier
    ┃     ┃     ┃  --&gt; main.yr:(18,15)
    ┃     ┃     ┃ 18  ┃     let x = &amp;(a.foo);
    ┃     ┃     ┃     ╋               ^
    ┃     ┃     ┗━━━━━┻━ 
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 

Error : undefined symbol x
 --&gt; main.yr:(20,5)
20  ┃     x ();
    ╋     ^


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>This can be easily resolved by aliasing the variable <strong><code>a</code></strong> when
creating the delegate. Either by using the keyword <strong><code>alias</code></strong>, or by
using the <strong><code>:.</code></strong> binary operator.</p>
<pre><code class="language-ymir">import std::io;

class Foo {
    let mut _i = 0;
    
    pub self () {}
    
    pub def foo (mut self) {
        self._i = 42;
    }

    impl Streamable; // to make the type printable
}

def main () {
    let dmut a = Foo::new ();
    let x = &amp;(a:.foo); // or &amp;((alias a).foo);

    x ();

    println (a);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>main::Foo(42)
</code></pre>
<p><br></p>
<a class="header" href="print.html#polymorphic-delegate" id="polymorphic-delegate"><h3>Polymorphic delegate</h3></a>
<p>Method delegates respect the polyphormism introduced by class inheritance.</p>
<pre><code class="language-ymir">import std::io;

class Foo {
    pub self () {}
    
    pub def foo (self) {
        println (&quot;Bar&quot;);
    }
}

class Bar over Foo {
    pub self () {}

    pub over foo (self) {
        println (&quot;Bar&quot;);
    }
}


def main ()
{
    let x : &amp;Foo = Bar::new ();
    let d = &amp;(x.foo);
    d ();
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>Bar
</code></pre>
<a class="header" href="print.html#pattern-matching" id="pattern-matching"><h1>Pattern matching</h1></a>
<p>The pattern matching is an important part of the <em>Ymir</em> language. It
allows to make test over values and moreover on types, especially when
it comes to objects. The pattern matching syntax always start with the
keyword <code>match</code> followed by an expression, and then a list of patterns
enclosed between <code>{}</code>.</p>
<p>The syntax of the pattern matching is described in the following code block.</p>
<pre><code class="language-grammar">match := 'match' expression '{' pattern* '}'
pattern := pattern_expression '=&gt;' expression (';')?

pattern_expression :=   pattern_tuple 
                      | pattern_option 
                      | pattern_range 
                      | pattern_var 
                      | pattern_call
                      | expression
                      
pattern_tuple := '(' (pattern_expression (',' pattern_expression)*)? ')'
pattern_option := pattern_expression ('|' pattern_expression)*
pattern_range := pattern_expression ('..' | '...') pattern_expression 
pattern_var := (Identifier | '_') ':' (type | '_') ('=' pattern_expression)?
pattern_call := (type | '_') '(' (pattern_argument (',' pattern_argument)*)? ')'
pattern_arguments := (Identifier '-&gt;')? pattern_expression
</code></pre>
<p><br></p>
<p>Match is a kind of control flow, relatively close to <em>if</em>
expressions. As <em>if</em> expressions, a <em>match</em> expression can have a
value. In that case, every branch of the <em>match</em> must share the same
type, and there must be a guarantee that at least one test of the
<em>match</em> succeed, and thus that a branch is entered. For example, in
the following example, all the branch of the <em>match</em> share the same
type <strong><code>i32</code></strong>, however it is possible (and even inevitable in that
specific case), that no branch of the <em>match</em> were entered. So the
compiler throws an error, as the variable <strong><code>x</code></strong> might be unset,
which is prohibited by the language. In the following example, simple
tests are made on the value, so the first pattern is equal to an <em>if</em>
expression, where the test is <strong><code>12 == 1</code></strong>.</p>
<pre><code class="language-ymir">def main () {
    let x = match (12) {
        1 =&gt; 8
        2 =&gt; 7
        3 =&gt; 6
    };
}
</code></pre>
<p><br>
Errors :</p>
<pre><code class="language-error">Error : match of type i32 has no default match case
 --&gt; main.yr:(2,10)
 2  ┃ 	let x = match (12) {
    ╋ 	        ^^^^^


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="print.html#matching-on-everything" id="matching-on-everything"><h2>Matching on everything</h2></a>
<p>The token <strong><code>_</code></strong> declares a pattern test that is always valid. It can
be placed at different level of the pattern test, as we will see in
the rest of this chapter.</p>
<pre><code class="language-ymir">import std::io;

def main () {
    match 42 {
        _ =&gt; { println (&quot;Always true&quot;); }
    }
}
</code></pre>
<p><br></p>
<a class="header" href="print.html#matching-over-a-range-of-values" id="matching-over-a-range-of-values"><h2>Matching over a range of values</h2></a>
<p>Pattern matching aims to be more expressive than <em>if</em> expressions, and
therefore to allow faster writting of complex test. For example, to
check wether a value is included in an interval of values, writing the
interval in the test of the pattern is sufficient. In the following
example, the first pattern can be rewritten as the following <em>if</em>
expression : <strong><code>1 &lt;= 42 &amp;&amp; 10 &gt; 42</code></strong>, the second into : <strong><code>10 &lt;= 42 &amp;&amp; 40 &gt;= 42</code></strong>, and the third one into : <strong><code>42 == 41 || 42 == 42 || 42 == 43</code></strong>.</p>
<pre><code class="language-ymir">import std::io

def main () {
    match 42 {
        1 .. 10 =&gt; {
            println (&quot;The answer is between 1 and 10 not included&quot;);
        }
        10 ... 40 {
            println (&quot;The answer is between 10 and 40 included&quot;);
        }
        41 | 42 | 43 =&gt; {
            println (&quot;The answer is either 41, 42 or 43&quot;);
        }
    }
}
</code></pre>
<p><br></p>
<p>The pattern are tested in the order they are written in the source
code, thus if two pattern are valid, only the first one is
entered. For example, in the following source code, only the pattern
at line <strong><code>5</code></strong> is entered, and the pattern at line <strong><code>6</code></strong>, even if
it is valid, is simply ignored.</p>
<pre><code class="language-ymir">import std::io;

def main () {
    match 42 {
        1 .. 100 =&gt; { println (&quot;Between 1 and 100&quot;); }
        10 .. 100 =&gt; { println (&quot;Between 10 and 100&quot;); }
    }
}
</code></pre>
<a class="header" href="print.html#variable-pattern" id="variable-pattern"><h2>Variable pattern</h2></a>
<p>A variable declaration can be used to store a value during the pattern
matching. The variable is declared like a standard variable
declaration but with keyword <strong><code>let</code></strong> ommitted. The variable pattern
can also be used to match over the type of the expression that is
tested, when the type of the variable can be dynamic (e.g. on class
inheritance). In all other cases the test is done during the
compilation, and the type of the newly declared variable must in any
case be fully compatible with the type of the value that is tested. In
the following example, the type of the variable patterns is always
<strong><code>i32</code></strong>, because it is the only compatible type with the type of the
value.</p>
<pre><code class="language-ymir">import std::io

def main () {
    match 13 {
        _ : i32 =&gt; {
            println (&quot;It is a i32, but I don't care about the value&quot;);
        }
        _ : i32 = 13 =&gt; {
            println (&quot;It is a i32, whose value is 13&quot;);
        }
        _ : _ = 13 =&gt; {
            println (&quot;It is a i32, whose value is 13, but I didn't checked the type&quot;);
        }		
        x : i32 =&gt; {
            println (&quot;It is a i32, and the value is : &quot;, x);
        }
    }
}
</code></pre>
<p><br></p>
<p>In the above example, every pattern tests are valid, but only the first pattern
is evaluated, leading to the following result.</p>
<pre><code>It is a i32, but I don't care about the value
</code></pre>
<p><br></p>
<p>One can note that the token <strong><code>:</code></strong> is important in that case, even if
the type is not mandatory and can be omitted (by replacing it with the
token <strong><code>_</code></strong>). This is to distinguish a variable declaration to a
simple variable referencing. For example, in the following source
code, a variable <strong><code>x</code></strong> is declared before the pattern matching, and
its value is compared with the value that is tested in the <em>match</em>. A
second pattern declares a variable <strong><code>y</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

def main () {
    let x = 42;
    match 42 {
        x =&gt; { println (&quot;x == 42&quot;); } // simple test on the variable declare 2 lines above
        y : _ =&gt; { println (y); } // declaration of a new variable y that stores the matched value 
    }
    
}
</code></pre>
<p><br>
Results:</p>
<pre><code>x == 42
</code></pre>
<p><br></p>
<a class="header" href="print.html#matching-over-type" id="matching-over-type"><h3>Matching over type</h3></a>
<p>When the type of the value that is tested can be dynamic (i.e. class
inheritance, which is the only possibility), then the type of the
variable in the test can be used to test the type of the value. In the
following example, the class <strong><code>Bar</code></strong> and <strong><code>Baz</code></strong> inherit from the
abstract class <strong><code>Foo</code></strong>. The variable <strong><code>x</code></strong> declared in the
<strong><code>main</code></strong> function, is of type <strong><code>Foo</code></strong> meaning that it can contains
either a <strong><code>Bar</code></strong> or a <strong><code>Baz</code></strong> value. The <em>match</em> expression then
make a test over the type of the variable <strong><code>x</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

class @abstract Foo {
    self () {}
}

class Bar over Foo {
    pub self () {}
}

class Baz over Foo {
    pub self () {}
}

def foo ()-&gt; &amp;Foo {
    Bar::new ()
}

def main () {
    let x = foo ();
    match x {
        _ : &amp;Bar =&gt; println (&quot;Contains a Bar&quot;);
        _ : &amp;Baz =&gt; println (&quot;Contains a Baz&quot;);		
    }
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>Contains a Bar
</code></pre>
<p><br></p>
<p>There is another pattern that can be used to test a dynamic type, that
is presented in a following sub section (<em>cf</em>. Destructuring class),
but pattern matching is the only way to cast a value whose type is an
ancestor class to an heir class, and this way is <strong>safe</strong>. In many
language like Java, D or C++, it is possible to use the casting
system, that has a undefined behavior in C++, makes the program crash
in Java, and returns the value <code>null</code> in D. These three behaviors are
not acceptable since they are not safe. By using the pattern matching,
the failing case is let to the discretion of the user. And as we have
seen in the introduction of this chapter, because a match can't have a
value if there is a possibility that none of the branch were entered,
then the user has to write a default case when the cast failed if they
want to retreive a value from the matching. This default case can of
course be used to throw an exception (<em>cf</em> <a href="https://gnu-ymir.github.io/Documentations/en/errors/main.html">Error
handling</a>).</p>
<a class="header" href="print.html#reference-variable" id="reference-variable"><h3>Reference variable</h3></a>
<p>A mutable value can be updated inside a pattern, by using a reference
variable. This works exactly like variable referencing (as presented
in chapter
<a href="https://gnu-ymir.github.io/Documentations/en/advanced/references.html">References</a>).</p>
<pre><code class="language-ymir">import std::io

def main () {
    let mut z = 1;
    match ref z {
        // ^^^
        // ref is important here, otherwise the compiler throw an error
        ref mut x : _ =&gt; {
            x = 42;
        }
    }
    
    println (z);
}
</code></pre>
<a class="header" href="print.html#destructuring-patterns" id="destructuring-patterns"><h2>Destructuring patterns</h2></a>
<p>Destructuring patterns are patterns that divide the values contained
in a value is type is a compound type. Compound types are 1) tuple, 2)
structures and 3) classes.</p>
<a class="header" href="print.html#destructuring-a-tuple" id="destructuring-a-tuple"><h3>Destructuring a tuple</h3></a>
<p>To destructure a tuple, parentheses surrounding other patterns are
used. The arity of the destructuring pattern must be the same as the
arity of the tuple that is destructured. In the following example, a
tuple of arity <strong><code>3</code></strong>, and type <strong><code>(i32, c32, f64)</code></strong> is
destructured, using two different patterns. The first pattern only
check the first value of the tuple (the other are always true, using
the token <strong><code>_</code></strong>), by verifying that the value is equals to <strong><code>1</code></strong>
and putting it in the variable <strong><code>i</code></strong>. The second pattern does not do
any tests but associate the values of the tuple to the variable
<strong><code>x</code></strong>, <strong><code>y</code></strong> and <strong><code>z</code></strong>. As one can note from that test, any
pattern can be used to test inner values of the tuple, (another
destructuring pattern if the inner value is a compound type, a range
pattern, etc.)</p>
<pre><code class="language-ymir">import std::io

def main () {
    let tuple = (1, 'x', 3.14)
    
    match tuple {
        (i : i32 = 1, _, _) =&gt; {
            println (&quot;This tuple has an arity of three and its first element is an i32, whose value &quot;, i, &quot; == 1&quot;);
        } 
        (x : _, y : _, z : _) =&gt; {
            println (&quot;This tuple has an arity of three, and its values are : (&quot;, x, &quot;, &quot;, y, &quot;, &quot;, z, &quot;)&quot;);
        }		
    }
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>This tuple has an arity of three and its first element is an i32, whose value 1 == 1
</code></pre>
<a class="header" href="print.html#destructuring-structure" id="destructuring-structure"><h3>Destructuring structure</h3></a>
<p>Destructuring structure is made by using a <em>call</em> expression. The
argument of the call expressions are patterns. Unlike tuple
destructuring, there is no need to test all the values of the
structure, but only those which are relevant. The order of the fields
is respected in the destructuring (i.e. the pattern, at line 15 of the
following example, tests the value of the field <strong><code>x</code></strong>). <em>Named
expressions</em> can be used to test specific fields of the structure.</p>
<pre><code class="language-ymir">import std::io

struct
| x : i32
| y : i32
 -&gt; Point;
    
def main () {
    let p = Point (1, 2);
    
    match p {
        Point (y-&gt; 1) =&gt; {
            println (&quot;Point where y is equal to 1&quot;);
        }
        Point (1) =&gt; {
            println (&quot;Point where x is equal to 1&quot;);
        }
        Point () =&gt; {
            println (&quot;Any point&quot;);
        }
    }
}
</code></pre>
<p><br></p>
<p>Of course, any kind of pattern can be used inside a structure
destructuring, for example a variable pattern, that refers to the
values later in the content of the pattern. In the following example,
a variable <strong><code>p</code></strong> is declared to refer to the value contained in the
variable <strong><code>point</code></strong>, and a variable <strong><code>y</code></strong> is declared to refer to
the value contained in the field <strong><code>point.y</code></strong>.</p>
<pre><code class="language-ymir">import std::io

struct
| x : i32
| y : i32
 -&gt; Point;
    
def main () {
    let point = Point (1, 2);
    
    match point {
        p : _ = Point (y-&gt; y : i32) =&gt; {
            println (p, &quot; is a point, whose y field is equal to &quot;, y);
        }
    }
}
</code></pre>
<a class="header" href="print.html#destructuring-class" id="destructuring-class"><h3>Destructuring class</h3></a>
<p>The syntax for destructuring object is the same as the syntax for
destructuring structure. However, only <em>named expressions</em> are
admitted, and this expressions refer to object fields that must be
public in the context of the pattern matching. For example, in the
source code below, the field <strong><code>x</code></strong> of the class <strong><code>Point</code></strong> is
public from the context of the <strong><code>main</code></strong> function, for that reason it
is accessible inside the class destructuring pattern. On the other
hand the field <strong><code>_y</code></strong> is private for the <strong><code>main</code></strong> function, thus
cannot be used.</p>
<pre><code class="language-ymir">import std::io

class Point {
    pub let x : i32 = 1;
    let _y : i32 = 2;
    
    pub self () {}
}

def main () {
    let p = Point::new ();
    
    match p {
        Point (x-&gt; 1, _y-&gt; 2) =&gt; {
            println (p.x, &quot; is a equal to 1&quot;);
        }
    }
}
</code></pre>
<p><br></p>
<p>Errors:</p>
<pre><code class="language-error">Error : undefined field _y for element &amp;(main::Point)
 --&gt; main.yr:(14,17)
14  ┃ 		Point (x-&gt; 1, _y-&gt; 2) =&gt; {
    ╋ 		              ^
    ┃ Note : i32 --&gt; main.yr:(5,11) : _y is private within this context
    ┗━━━━━━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>We have seen in a previous section (<em>cf</em>. Matching over type), that
because class types are dynamic when there is inheritance, pattern
matching can be used to test the type of the values. Class
destructuring is an alternative way to check the type of a value,
whose type is a class that have heirs. The following example,
demonstrate the use of the pattern matching to retreive the center of
a <strong><code>Shape</code></strong> when it is a <strong><code>Circle</code></strong>. In this example, the
<strong><code>foo</code></strong> function lied, and returned a <strong><code>Rectangle</code></strong> instead of a
<strong><code>Circle</code></strong>, in order to be compilable the source code must manage
that case, otherwise the variable <strong><code>center</code></strong> declared at line
<strong><code>28</code></strong> could be unset, and that is prohibited by the language.</p>
<pre><code class="language-ymir">import std::io

class @abstract Shape {
    self () {}
}

class Rectangle over Shape {
    pub self () {}
}

class Circle over Shape {
    pub let center : i32 ;

    pub self (center : i32) with center = center {}
}

/**
 * Don't worry I will return you a circle
*/
def foo () -&gt; &amp;Shape {
    Rectangle::new ()
}

def main () {
    let circle = foo ();
    let center = match circle {
        Circle (center-&gt; c : _) =&gt; c
    };
    println (&quot;The center of the circle is : &quot;, center);
}
</code></pre>
<p><br></p>
<p>Errors:</p>
<pre><code class="language-error">Error : match of type i32 has no default match case
 --&gt; main.yr:(28,15)
28  ┃ 	let center = match circle {
    ╋ 	             ^^^^^

Error : undefined symbol center
 --&gt; main.yr:(31,45)
31  ┃ 	println (&quot;The center of the circle is : &quot;, center);
    ╋ 	                                           ^^^^^^


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>This can be corrected by adding a default case to the <em>match</em>
expression. The following source codes are two possibilities.</p>
<ul>
<li>
<ol>
<li>Setting a default value :</li>
</ol>
</li>
</ul>
<pre><code class="language-ymir">def main () {
    let circle = foo ();
    let center = match circle {
        Circle (center-&gt; c : _) =&gt; c
        _ =&gt; {
            println (&quot;Foo lied ....&quot;);
            0 // center is equal to 0, if foo returned something other than a Circle
        }
    };
    println (&quot;The center of the circle is : &quot;, center);
}
</code></pre>
<ul>
<li>
<ol start="2">
<li>Throwing an error (<em>cf</em>. <a href="https://gnu-ymir.github.io/Documentations/en/errors/main.html">Error
handling</a>)</li>
</ol>
</li>
</ul>
<pre><code class="language-ymir">def main ()
    throws &amp;AssertError
{
    let circle = foo ();
    let center = match circle {
        Circle (center-&gt; c : _) =&gt; c
        _ =&gt; {
            throw AssertError::new (&quot;Foo lied...&quot;);
        }
    };
    println (&quot;The center of the circle is : &quot;, center);
}
</code></pre>
<p><br></p>
<p>A pattern using an ancestor class, will succeed if the object instance
that is used is a heir class. That is to say, if the pattern tries to
get a <strong><code>Shape</code></strong> value, when giving a <strong><code>Circle</code></strong> value to the
pattern, the pattern test succeeds. So the order has to be carefully
set (putting heir class tests first). The phenomenon is the same with
variable patterns. <strong>Contribution</strong> Add verification when a pattern
test cannot be entered because previous test is always valid.</p>
<pre><code class="language-ymir">def main () {
    let circle : &amp;Shape = Circle::new (); // Important to have a &amp;Shape, and not a &amp;Circle
    match circle {
        Shape () =&gt; {
            println (&quot;Shape&quot;);
        }
        Circle () =&gt; {
            println (&quot;Circle&quot;);
        }
    }
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>Shape
</code></pre>
<a class="header" href="print.html#error-handling" id="error-handling"><h1>Error handling</h1></a>
<p>This section will introduce error handling in the <em>Ymir</em> language. As
with many languages, error are managed by throwing
exceptions. Exception can be recovered thanks to scope guards that
manage the errors in different manners. The keyword <code>throw</code> is used to
throw an exception when an error occurs in the program. An exception
is a class that inherits the core class <code>core::exception::Exception</code>.
Exceptions are always recoverable, and must be managed by the user,
who cannot simply ignore them. <em>Ymir</em> does not allow the possibility
to ignore that an exception is thrown in a function, and may cause the
function to exit prematurely. To avoid this possibility, excpetion
must be written in the definition of the function, or managed
directly.</p>
<pre><code class="language-ymir">// Exception is defined in a core module, so does not need import 
class MyError over Exception {
    pub self () {}
}

def main () 
    throws &amp;MyError
{
    throw MyError::new ();
}
</code></pre>
<a class="header" href="print.html#assert" id="assert"><h2>Assert</h2></a>
<p>We have seen in previous section the <em>assert</em> expression. This simple
expression throws an <strong><code>&amp;AssertError</code></strong> value when the condition is
not valid. <strong><code>AssertError</code></strong> is a common exception defined in a core
file (that does not need to be imported).</p>
<pre><code class="language-ymir">def main () 
    throws &amp;AssertError
{
    let i = 11;
    assert (i &lt; 10, &quot;i must be lower than 10&quot;)
}
</code></pre>
<a class="header" href="print.html#rethrowing" id="rethrowing"><h2>Rethrowing</h2></a>
<p>The error rethrowing is a way of defining that a function could throw
an exception, and that this exception must be taking into account by
the caller functions. It is a system relatively close to error
rethrowing of the Java language, apart that the specific name of the
exception must be written in the possible rethrowed exceptions. That
is to say, it is impossible to write that a function throws a parent
class of the actually thrown exception (e.g. <strong><code>&amp;Exception</code></strong>, when
the function actually throws <strong><code>&amp;AssertError</code></strong>). Thanks to that, the
compiler is always able to check the type of the exceptions, and can
force the user to handle them.</p>
<p>In the following example, the function <strong><code>foo</code></strong> is an unsafe function
that can throw the exception <strong><code>&amp;AssertError</code></strong>. This exception is
thrown by the function <strong><code>assert</code></strong> at line <strong><code>6</code></strong>, and is not
managed by the function <strong><code>foo</code></strong>. Because the <strong><code>main</code></strong> function
calls the <strong><code>foo</code></strong> function, it is also unsafe, and also throws the
exception <strong><code>&amp;AssertError</code></strong>. In this example, the program stops,
because of an unhandled exception.</p>
<pre><code class="language-ymir">import std::io

def foo (i : i32) 
    throws &amp;AssertError
{
    assert (i &lt; 10, &quot;i is not lower than ten&quot;);
    println (i);
}

def main () 
    throws &amp;AssertError
{
    foo (10);
}
</code></pre>
<p><br></p>
<p>Results (in debug mode, <em>-g</em> option):</p>
<pre><code>Unhandled exception
Exception in file &quot;/home/emile/ymir/Runtime/midgard/core/exception.yr&quot;, at line 84, in function &quot;core::exception::abort&quot;, of type core::exception::AssertError.
╭  Stack trace :
╞═ bt ╕ #1
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #2
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #3 in function core::exception::abort (...)
│     ╘═&gt; /home/emile/ymir/Runtime/midgard/core/exception.yr:84
╞═ bt ╕ #4 in function main::foo (...)
│     ╘═&gt; /home/emile/Documents/test/ymir/main.yr:7
╞═ bt ╕ #5 in function main (...)
│     ╘═&gt; /home/emile/Documents/test/ymir/main.yr:10
╞═ bt ╕ #6
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #7 in function main
│     ╘═&gt; /home/emile/Documents/test/ymir/main.yr:10
╞═ bt ╕ #8
│     ╘═&gt; /lib/x86_64-linux-gnu/libc.so.6:??
╞═ bt ═ #9 in function _start
╰
Aborted (core dumped)
</code></pre>
<p><br></p>
<p>The compiler does not allow to forget the possibility of a error
throwing, and requires the user to write it down. In the following
example, the function <strong><code>foo</code></strong> call the function <strong><code>assert</code></strong> that
could throw an <strong><code>&amp;AssertError</code></strong> if the test fails. In that case the
function <strong><code>foo</code></strong> can also throw an error, and that must be written
in the prototype of the function. Otherwise the compiler gives an
error.</p>
<pre><code class="language-ymir">import std::io

def foo (i : i32) 
{
    assert (i &lt; 10, &quot;i is not lower than ten&quot;);
    println (i);
}
</code></pre>
<p><br></p>
<p>Errors:</p>
<pre><code class="language-error">Error : the function main::foo might throw an exception of type &amp;(core::exception::AssertError), but that is not declared in its prototype
 --&gt; main.yr:(3,5)
 3  ┃ def foo (i : i32) 
    ╋     ^^^
    ┃ Note : 
    ┃  --&gt; main.yr:(5,2)
    ┃  5  ┃ 	assert (i &lt; 10, &quot;i is not lower than ten&quot;);
    ┃     ╋ 	^
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>As previously stated, the name of the exceptions specified in the
prototype function must be the actual name of the exception, not the
name of an ancestor. In the following example, the class
<strong><code>ParentException</code></strong> and <strong><code>ChildException</code></strong> are two throwable
class. The function <strong><code>foo</code></strong> throws an object of type
<strong><code>ChildException</code></strong>, but the prototype declares that the function
throws a <strong><code>ParentException</code></strong> object. To avoid losing accuracy, the
<em>Ymir</em> language does not allow that. This is however still possible to
perform this kind of behavior (necessary when the function throw
multiple kind of errors, all deriving from <strong><code>ParentException</code></strong> for
example), by using a <strong><code>cast</code></strong>, that we have seen in chapter <a href="https://gnu-ymir.github.io/Documentations/en/cast/">Cast
and Dynamic
typing</a>. That way,
there is a loss of accuracy, but properly defined and intended by the
user.</p>
<pre><code class="language-ymir">
class ParentException over Exception {
    pub self () {}
}

class ChildException over Exception {
    pub self () {}
}

def foo () 
    throws &amp;ParentException
{
    throw ChildException::new ()
}
</code></pre>
<p><br></p>
<p>Errors:</p>
<pre><code class="language-error">Error : the function main::foo might throw an exception of type &amp;(main::ChildException), but that is not declared in its prototype
 --&gt; main.yr:(9,5)
 9  ┃ def foo () 
    ╋     ^^^
    ┃ Note : 
    ┃  --&gt; main.yr:(12,5)
    ┃ 12  ┃     throw ChildException::new ()
    ┃     ╋     ^^^^^
    ┗━━━━━┻━ 

Error : the function main::foo prototype informs about a possible throw of an exception of type &amp;(main::ParentException), but this is not true
 --&gt; main.yr:(9,5)
 9  ┃ def foo () 
    ╋     ^^^
    ┃ Note : 
    ┃  --&gt; main.yr:(10,12)
    ┃ 10  ┃     throws &amp;ParentException
    ┃     ╋            ^
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="print.html#scope-guards" id="scope-guards"><h1>Scope guards</h1></a>
<p>Scope guards are expressions attached to a scope (block of code), that
are executed on specific cases in the scope that is guarded. There are
four different scope guards, <strong><code>exit</code></strong>, <strong><code>failure</code></strong>, <strong><code>success</code></strong>
and <strong><code>catch</code></strong>. This chapter does not discuss the <em>catch</em> scope
guard, that will be discussed in the next chapter.</p>
<p>The syntax of <em>exit</em>, <em>success</em> and <em>failure</em> scope guards is the following:</p>
<pre><code class="language-grammar">guarded_scope := '{' expression ((';')? expression)* (';')? '}' guards
guards := (Guard expression)* ('catch' catching_expression)? (Guard expression)*
Guard := 'exit' | 'success' | 'failure'
</code></pre>
<a class="header" href="print.html#success-guard" id="success-guard"><h2>Success guard</h2></a>
<p>Scope guards are associate with expressions, that are executed when a
specific events occurs in the scope that is guarded. In the case of
<em>success</em> scope guard, the event that triggers the guard expression,
is when no error occured (nothing was thrown in the scope).</p>
<pre><code class="language-ymir">import std::io;

def foo (i : i32)
    throws &amp;AssertError
{
    println (&quot;I : &quot;, i);
    assert (i &lt; 10, &quot;i must be lower than 10&quot;);
} success {
    println (&quot;Nothing was thrown !!&quot;);
}

def main () 
    throws &amp;AssertError
{
    foo (1);
    foo (20);
}
</code></pre>
<p><br>
Results:</p>
<pre><code>I : 1
Nothing was thrown !!
I : 20
Unhandled exception
Exception in file &quot;/home/emile/ymir/Runtime/midgard/core/exception.yr&quot;, at line 84, in function &quot;core::exception::abort&quot;, of type core::exception::AssertError.
╭  Stack trace :
╞═ bt ╕ #1
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #2
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #3 in function core::exception::abort (...)
│     ╘═&gt; /home/emile/ymir/Runtime/midgard/core/exception.yr:84
╞═ bt ╕ #4 in function main::foo (...)
│     ╘═&gt; /home/emile/Documents/test/ymir/main.yr:8
╞═ bt ╕ #5 in function main (...)
│     ╘═&gt; /home/emile/Documents/test/ymir/main.yr:12
╞═ bt ╕ #6
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #7 in function main
│     ╘═&gt; /home/emile/Documents/test/ymir/main.yr:12
╞═ bt ╕ #8
│     ╘═&gt; /lib/x86_64-linux-gnu/libc.so.6:??
╞═ bt ═ #9 in function _start
╰
Aborted (core dumped)
</code></pre>
<p><br></p>
<p>This scope guard can be used on scope that never throw exceptions, in
that case it is always executed. This goal of this scope guard is to
execute operation at the end of a scope, only when the operation
succeded (e.g. writting logs, sending acknolegement, etc.). It can be
coupled with other scope guards, to perform different operation when
the scope didn't succeded.</p>
<a class="header" href="print.html#failure-guard" id="failure-guard"><h2>Failure guard</h2></a>
<p>The <em>failure</em> scope guard does the opposite of the <em>success</em> scope
guard, meaning that the associated expression is only executed when an
exception was thrown in the scope that is guarded. This scope guard is
really useful to perform operation without recovering from the
error. Indeed, the <em>failure</em> guard is not a <em>catch</em> guard, and the
execption that is thrown in the guarded scope continue its journey,
but the expression in the scope guard are guaranteed to be executed
(e.g. logging the error, closing a socket, unlocking a mutex, etc.).</p>
<pre><code class="language-ymir">import std::io;

def foo (i : i32)
    throws &amp;AssertError
{
    println (&quot;I : &quot;, i);
    assert (i &lt; 10, &quot;i must be lower than 10&quot;);
} failure {
    println (&quot;Well there was an error...&quot;);
}

def main () 
    throws &amp;AssertError
{
    foo (1);
    foo (20);
}
</code></pre>
<p><br>
Results:</p>
<pre><code>I : 1
I : 20
Well there was an error...
Unhandled exception
Exception in file &quot;/home/emile/ymir/Runtime/midgard/core/exception.yr&quot;, at line 84, in function &quot;core::exception::abort&quot;, of type core::exception::AssertError.
╭  Stack trace :
╞═ bt ╕ #1
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #2
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #3
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #4 in function main::foo (...)
│     ╘═&gt; /home/emile/Documents/test/ymir/main.yr:8
╞═ bt ╕ #5 in function main (...)
│     ╘═&gt; /home/emile/Documents/test/ymir/main.yr:12
╞═ bt ╕ #6
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #7 in function main
│     ╘═&gt; /home/emile/Documents/test/ymir/main.yr:12
╞═ bt ╕ #8
│     ╘═&gt; /lib/x86_64-linux-gnu/libc.so.6:??
╞═ bt ═ #9 in function _start
╰
Aborted (core dumped)
</code></pre>
<a class="header" href="print.html#exit-guard" id="exit-guard"><h2>Exit guard</h2></a>
<p>The <em>exit</em> scope guard is the combination of the <em>success</em> and
<em>failure</em> guards. The operation contained in the guards are always
executed, no matter what happened in the scope that is guarded. It can
be seen as a shortcut for the <em>success</em> and <em>failure</em> guards doing the
same operations, but avoiding code repetition.</p>
<pre><code class="language-ymir">import std::io;

def foo (i : i32)
    throws &amp;AssertError
{
    println (&quot;I : &quot;, i);
    assert (i &lt; 10, &quot;i must be lower than 10&quot;);
} exit {
    println (&quot;The scope is exited, with an error or not, who knows&quot;);
}

def main () 
    throws &amp;AssertError
{
    foo (1);
    foo (20);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>I : 1
The scope is exited, with an error or not, who knows
I : 20
The scope is exited, with an error or not, who knows
Unhandled exception
Exception in file &quot;/home/emile/ymir/Runtime/midgard/core/exception.yr&quot;, at line 84, in function &quot;core::exception::abort&quot;, of type core::exception::AssertError.
╭  Stack trace :
╞═ bt ╕ #1
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #2
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #3
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #4 in function main::foo (...)
│     ╘═&gt; /home/emile/Documents/test/ymir/main.yr:8
╞═ bt ╕ #5 in function main (...)
│     ╘═&gt; /home/emile/Documents/test/ymir/main.yr:12
╞═ bt ╕ #6
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #7 in function main
│     ╘═&gt; /home/emile/Documents/test/ymir/main.yr:12
╞═ bt ╕ #8
│     ╘═&gt; /lib/x86_64-linux-gnu/libc.so.6:??
╞═ bt ═ #9 in function _start
╰
Aborted (core dumped)
</code></pre>
<a class="header" href="print.html#scope-guard-priority" id="scope-guard-priority"><h2>Scope guard priority</h2></a>
<p>It is possible to use multiple scope guards for the same scope. In
that case, the order of execution of the scopes is the following :</p>
<ul>
<li>
<ol>
<li>for the scope guards of same nature (e.g. two <em>failure</em> guards),
the execution is done is the order they are written.</li>
</ol>
</li>
</ul>
<pre><code class="language-ymir">import std::io;

def main () 
{
    {
        println (&quot;Scope operation&quot;);
    } exit {
        println (&quot;Exit 1&quot;); 
    } exit {
        println (&quot;Exit 2&quot;);
    }
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Scope operation
Exit 1
Exit 2
</code></pre>
<p><br></p>
<ul>
<li>
<ol start="2">
<li>If there is an <em>exit</em> guard and a <em>success</em> or a <em>failure</em> guard,
then the <em>success</em> and <em>failure</em> guards are executed first.</li>
</ol>
</li>
</ul>
<pre><code class="language-ymir">import std::io;

def main () 
{
    {
        println (&quot;Scope operation&quot;);
    } success {
        println (&quot;Success&quot;);
    } exit {
        println (&quot;Exit 1&quot;); 
    } exit {
        println (&quot;Exit 2&quot;);
    } success {
        println (&quot;Success 2&quot;);
    } 
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Scope operation
Success
Success 2
Exit 1
Exit 2
</code></pre>
<p><br></p>
<ul>
<li>
<ol start="3">
<li>The priority between <em>failure</em> and <em>success</em> is not defined, they
simply cannot happen at the same time.</li>
</ol>
</li>
</ul>
<a class="header" href="print.html#catching-exceptions" id="catching-exceptions"><h1>Catching exceptions</h1></a>
<p>The main idea of exception is the possibility to recover from a
failing program state. In order to do that, another scope guard exits
in <em>Ymir</em>, this scope guard is named <em>catch</em>. The syntax of this scope
guard is relatively close to the other scope guard, and to the pattern
matching. Indeed, this scope guard does not execute an expression but
match over an exception that has been caught. The following code block
present the grammar of the <em>catch</em> scope guard. The
<em>pattern_expression</em> used in this code block are those defined in the
chapter <a href="https://gnu-ymir.github.io/Documentations/en/pattern/">Pattern
matching</a>.</p>
<pre><code class="language-grammar">guarded_scope := '{' expression ((';')? expression)* (';')? '}' guards
guards := (Guard expression)* ('catch' catching_expression)? (Guard expression)*
Guard := 'exit' | 'success' | 'failure'

catching_expression := pattern_var | pattern_call | '_'

pattern_var := (Identifier | '_') ':' (type | '_') ('=' pattern_expression)?
pattern_call := (type | '_') '(' (pattern_argument (',' pattern_argument)*)? ')'
pattern_arguments := (Identifier '-&gt;')? pattern_expression
</code></pre>
<a class="header" href="print.html#catch-everything" id="catch-everything"><h2>Catch everything</h2></a>
<p><em>Catch</em> scope guard can be used to catch any exception and continue
the execution of the program. In the following example, the <strong><code>main</code></strong>
function calls the <strong><code>foo</code></strong> function, that throws an
<strong><code>&amp;AssertError</code></strong>. The call is guarded by a catch expression, that
catch every kind of <strong><code>Exception</code></strong> (using the <strong><code>_</code></strong> token). Because
the exception of the <strong><code>foo</code></strong> function is caught the <strong><code>main</code></strong>
function is considered safe, and thus cannot throw an exception, this
is why nothing is declared in its prototype. In this example, the
program ends normaly, after exiting the <strong><code>main</code></strong> function.</p>
<pre><code class="language-ymir">import std::io;

def foo (i : i32) 
    throws &amp;AssertError
{
    assert (i &lt; 10, &quot;i must be lower than 10&quot;);
    println (i);
}

def main () {
    println (&quot;Before foo&quot;);
    { 
        foo (10); 
    } catch {
        _ =&gt; {
            println (&quot;Foo failed&quot;);
        }
    }
    println (&quot;After foo&quot;);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>Before foo
Foo failed
After foo
</code></pre>
<p><br></p>
<p>A variable pattern can also be used to get the value of the
exception. There is no much change in the following example, in
comparison to the previous one, except that the <strong><code>main</code></strong> function
prints the exception that has been throw by the <strong><code>foo</code></strong> function. In
<em>debug</em> mode (<em>-g</em> option of the compiler), when throwing an
exception, the stack trace is accessible and printed, when printing an
exception. This stack trace (for efficiency reasons) is not created in
<em>release</em> mode.</p>
<pre><code class="language-ymir">import std::io;

def foo (i : i32) 
    throws &amp;AssertError
{
    assert (i &lt; 10, &quot;i must be lower than 10&quot;);
    println (i);
}

def main () {
    println (&quot;Before foo&quot;);
    { 
        foo (10); 
    } catch {
        err : _ =&gt; {
            println (&quot;Foo failed : &quot;, err);
        }
    }
    println (&quot;After foo&quot;);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>Before foo
Foo failed : core::exception::AssertError (i must be lower than 10):
╭  Stack trace :
╞═ bt ╕ #1 in function core::exception::AssertError::self (...)
│     ╘═&gt; /home/emile/ymir/Runtime/midgard/core/exception.yr:49
╞═ bt ╕ #2 in function core::exception::abort (...)
│     ╘═&gt; /home/emile/ymir/Runtime/midgard/core/exception.yr:84
╞═ bt ╕ #3 in function main::foo (...)
│     ╘═&gt; /home/emile/Documents/test/ymir/main.yr:7
╞═ bt ╕ #4 in function main (...)
│     ╘═&gt; /home/emile/Documents/test/ymir/main.yr:14
╞═ bt ╕ #5
│     ╘═&gt; /lib/libgyruntime.so:??
╞═ bt ╕ #6 in function main
│     ╘═&gt; /home/emile/Documents/test/ymir/main.yr:10
╞═ bt ╕ #7
│     ╘═&gt; /lib/x86_64-linux-gnu/libc.so.6:??
╞═ bt ═ #8 in function _start
╰
After foo
</code></pre>
<a class="header" href="print.html#catch-a-specific-exception" id="catch-a-specific-exception"><h2>Catch a specific exception</h2></a>
<p>The content of a <em>catch</em> scope guard is a list of patterns, that can
be used to get a different behavior for different kind of
exception. In the following example, the <strong><code>foo</code></strong> function, can throw
two different kind of exception, <strong><code>&amp;AssertError</code></strong> and
<strong><code>&amp;OutOfArray</code></strong>. The <em>catch</em> of the <strong><code>main</code></strong> function has a
different behavior if the exception that is thrown is a
<strong><code>&amp;AssertError</code></strong> or a <strong><code>&amp;OutOfArray</code></strong>, (by using a variable pattern
for <strong><code>&amp;AssertError</code></strong>, and a call pattern for <strong><code>&amp;OutOfArray</code></strong>).</p>
<pre><code class="language-ymir">import std::io;

def foo (i : [i32]) 
    throws &amp;AssertError, &amp;OutOfArray
{
    assert (i [0] &lt; 10, &quot;i[0] must be lower than 10&quot;);
    println (i);
}

def main () {
    println (&quot;Before foo&quot;);
    { 
        foo ([]); 
    } catch {
        err : &amp;AssertError =&gt; {
            println (&quot;Foo failed : &quot;, err);
        }
        OutOfArray () =&gt; {
            println (&quot;Foo failed, the slice was empty&quot;);
        }
    }
    println (&quot;After foo&quot;);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>Before foo
Foo failed, the slice was empty
After foo
</code></pre>
<p><br></p>
<a class="header" href="print.html#rethrowing-exceptions" id="rethrowing-exceptions"><h2>Rethrowing exceptions</h2></a>
<p><em>Catch</em> scope guard must catch every exceptions that are thrown by the
scope that is guarded. For example, if the <strong><code>main</code></strong> function of the
previous example, was defined as presented in the next code block, the
compiler would have returned an error. Indeed, in this example, the
<strong><code>&amp;OutOfArray</code></strong> exception is not managed by the <em>catch</em> guard.</p>
<pre><code class="language-ymir">def main () {
    println (&quot;Before foo&quot;);
    { 
        foo ([]); 
    } catch {
        err : &amp;AssertError =&gt; {
            println (&quot;Foo failed : &quot;, err);
        }
    }
    println (&quot;After foo&quot;);
}
</code></pre>
<p><br></p>
<p>Errors:</p>
<pre><code class="language-error">Error : the exception &amp;(core::array::OutOfArray) might be thrown but is not caught
 --&gt; main.yr:(13,7)
13  ┃ 		foo ([]); 
    ╋ 		    ^
    ┃ Note : 
    ┃  --&gt; main.yr:(14,4)
    ┃ 14  ┃ 	} catch {
    ┃     ╋ 	  ^^^^^
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>The <strong><code>OutOfArray</code></strong> exception can be rethrown inside the <em>catch</em>
scope guard to remove this error. In that case the stack trace is
still correct, as it is created by the constructor of the
<strong><code>Exception</code></strong> class.</p>
<pre><code class="language-ymir">def main () 
    throws &amp;OutOfArray
{
    println (&quot;Before foo&quot;);
    { 
        foo ([]); 
    } catch {
        err : &amp;AssertError =&gt; {
            println (&quot;Foo failed : &quot;, err);
        }
        x : &amp;OutOfArray =&gt; throw x;
    }
    println (&quot;After foo&quot;);
}
</code></pre>
<a class="header" href="print.html#catch-as-a-value" id="catch-as-a-value"><h2>Catch as a value</h2></a>
<p>In some cases (many cases), a scope is used to compute a value. In
that circumstance, if an error occurs inside the scope, the value of
the scope is not set, and cannot be used. For example, in the
following source code, the <strong><code>main</code></strong> function tries to initialize a
variable from the value of the <strong><code>foo</code></strong> function. This function is
not safe, and might return no value at all. In order to guarantee,
that the variable <strong><code>x</code></strong> is initialized, and usable no matter what
happened in the <strong><code>foo</code></strong> function, the <em>catch</em> scope guard can be
used as the default value. This is presented as well at line <strong><code>21</code></strong>
to initialize the variable <strong><code>y</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

def foo (i : i32) 
    throws &amp;AssertError
{
    assert (i &lt; 10, &quot;i[0] must be lower than 10&quot;);
    i + 12
}

def main ()
{
    {
        let x = foo (10); 
        println (x);
    } catch {
        _ =&gt; {
            println (&quot;Foo failed&quot;);
        }
    }

    let y = {
        foo (10)
    } catch {
        _ =&gt; {
            42
        }
    }

    println (y);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>Foo failed
42
</code></pre>
<p><br></p>
<p>Because, the <em>catch</em> scope guard is a pattern matching, multiple
branch can be entered. In that case, every branch of the <em>catch</em> guard
must share the same type. In the following example, the value <strong><code>y</code></strong>
is set conditionaly, depending on the type of exception that is thrown
by the <strong><code>foo</code></strong> function, or if the function <strong><code>foo</code></strong> succeeds. In
this example, the <strong><code>foo</code></strong> function throws a <strong><code>&amp;OutOfArray</code></strong>
exception, thus the variable <strong><code>y</code></strong> is set to <strong><code>42</code></strong> (value
computed at line <strong><code>19</code></strong>).</p>
<pre><code class="language-ymir">import std::io;

def foo (i : [i32]) -&gt; i32
    throws &amp;AssertError, &amp;OutOfArray
{
    assert (i[0] &lt; 10, &quot;i[0] must be lower than 10&quot;);
    i[0] + 12
}

def main ()
{
    let y = {
        foo ([])
    } catch {
        AssertError () =&gt; {
            11
        }
        OutOfArray () =&gt; {
            42
        }
    }

    println (y);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>42
</code></pre>
<a class="header" href="print.html#catch-along-other-scope-guards" id="catch-along-other-scope-guards"><h2>Catch along other scope guards</h2></a>
<p><em>Catch</em> scope guards can be used along other scope guards, (<em>success</em>,
<em>failure</em> and <em>exit</em>), but there can be only one <em>catch</em> scope guard
per scope . In that case the priority is the following: 1) <em>failure</em>,</p>
<ol start="2">
<li><em>catch</em>, 3) <em>exit</em>. If there is a <em>success</em> scope guard that is
executed, then the <em>catch</em> scope guard cannot be executed, so the
priority over these two guards is not defined.</li>
</ol>
<pre><code class="language-ymir">import std::io;

def foo (i : [i32]) 
    throws &amp;AssertError, &amp;OutOfArray
{
    assert (i [0] &lt; 10, &quot;i[0] must be lower than 10&quot;);
    println (i);
}

def main ()
{
    println (&quot;Before foo&quot;);
    { 
        foo ([]); 
    } catch {
        err : &amp;AssertError =&gt; {
            println (&quot;Foo failed : &quot;, err);
        }
        _ : &amp;OutOfArray =&gt; {
            println (&quot;Out&quot;);
        }
    } success {
        println (&quot;Succ&quot;);
    } failure {
        println (&quot;Fails&quot;);
    } exit {
        println (&quot;Exit&quot;);
    }
    println (&quot;After foo&quot;);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>Before foo
Fails
Out
Exit
After foo
</code></pre>
<p><br></p>
<p>The behavior is exactly the same when <em>catch</em> scope guard has a value.</p>
<pre><code class="language-ymir">import std::io;

def foo (i : [i32]) -&gt; i32
    throws &amp;AssertError, &amp;OutOfArray
{
    assert (i[0] &lt; 10, &quot;i[0] must be lower than 10&quot;);
    i[0] + 12
}

def main ()
{
    let y = {
        foo ([])
    } catch {
        AssertError () =&gt; {
            println (&quot;Assert&quot;);
            11
        }
        OutOfArray () =&gt; {
            println (&quot;Out&quot;);
            42
        }
    } failure {
        println (&quot;Fails&quot;);
    } exit {
        println (&quot;Exit&quot;);
    }

    println (y);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>Fails
Out
Exit
42
</code></pre>
<a class="header" href="print.html#relation-between-exception-and-option-type" id="relation-between-exception-and-option-type"><h1>Relation between exception and option type</h1></a>
<p>We have seen in the chapter <a href="https://gnu-ymir.github.io/Documentations/en/primitives/">Basic programming
concept</a>,
that the <em>Ymir</em> language have a primitive option type. This type has a
really close relation with exceptions. Indeed, any value can be store
inside an option type, and any failing scope can be used to create an
empty option value. The token <strong><code>?</code></strong> is used to transform a value
into an option type.</p>
<p>In the following example, the <strong><code>foo</code></strong> function can throw an
exception. The <strong><code>main</code></strong> function calls it, but use enclose the
result inside an option type, to handle the errors. The type of the
variable <strong><code>x</code></strong> is then <strong><code>(i32)?</code></strong>, meaning option of <strong><code>i32</code></strong>.  A
pattern matching, is then used to check wether the <strong><code>x</code></strong> contains a
value or not. In this example, a new pattern of the pattern matching
is presented. This pattern is specific to the case of option type, and
adds two keywords <strong><code>Ok</code></strong>, and error <strong><code>Err</code></strong>. They can be used with
or without internal pattern (never named), to get the content of the
option (in case of <strong><code>Ok</code></strong>), or the exception (in case of <strong><code>Err</code></strong>).</p>
<pre><code class="language-ymir">import std::io;

def foo (i : i32)-&gt; i32 
    throws &amp;AssertError
{
    assert (i &lt; 10, &quot;i must be lower than 10&quot;);
    i + 12
}

def main () {
    let x = foo (10) ?
    match x {
        Ok (y : _) =&gt; { 
            println (&quot;x contains the value : &quot;, y);
        }
        Err (err : _) =&gt; {
            println (&quot;x has no value, because : &quot;, err);
        }
    }
}
</code></pre>
<p><br></p>
<p>Results (in release mode) :</p>
<pre><code>x has no value, because : core::exception::AssertError (i must be lower than 10)
</code></pre>
<p><br></p>
<p>One can note from the previous example, that the <strong><code>main</code></strong> function
is safe. The option enclosing catches every exceptions. The exception
can then be retreived by using a pattern matching, as presented above.
<strong>Warning</strong> Unfortunately, the accuracy of the exception type that is
thrown is lost at compile time, (i.e. the type contained inside an
option type is <strong><code>Exception</code></strong>). Even, if the type can be specifically
retreived at execution time. To remove this limitation, the different
type of exception would have to be written in the definition of the
option type. This would be extremely verbose. <em>Contribution</em> Maybe
adding the possibility to write it, but optionaly, in order to store
it if possible. I don't know if it is a good idea.</p>
<a class="header" href="print.html#empty-option-without-exception" id="empty-option-without-exception"><h2>Empty option without exception</h2></a>
<p>It is possible to initialize an empty option value without throwing an
exception. This can be done using the type specific attribute
<strong><code>err</code></strong>. In that case, the option does not have a value, even if it
is an <strong><code>Err</code></strong> value.</p>
<pre><code class="language-ymir">import std::io;

def foo ()-&gt; i32? {
    (i32?)::__err__
}

def main () {
    match foo () {
        Err (err : _) =&gt; {
            println (&quot;Empty but with exception : &quot;, err);
        }
        Err () =&gt; {
            println (&quot;Totally empty, init with __err__&quot;);
        }
    }
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>Totally empty, init with __err__
</code></pre>
<a class="header" href="print.html#void-option-type" id="void-option-type"><h2>Void option type</h2></a>
<p>Option type can store values of type <strong><code>void</code></strong>, in that case the
<strong><code>Ok</code></strong> pattern has no value to get. This can be usefull to execute a
function, and verify afterwards if it succeeded or not.</p>
<pre><code class="language-ymir">import std::io;

def foo (i : i32)-&gt; void 
    throws &amp;AssertError
{
    assert (i &lt; 10, &quot;i must be lower than 10&quot;);
    println (i);
}

def main () {
    let x : void? = foo (10) ?
    match x {
        Ok () =&gt; { 
            println (&quot;Foo succeeded&quot;);
        }
        Err (err : _) =&gt; {
            println (&quot;Foo failed, because : &quot;, err);
        }
    }
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Foo failed, because : core::exception::AssertError (i must be lower than 10)
</code></pre>
<a class="header" href="print.html#function-pointer-and-closure" id="function-pointer-and-closure"><h1>Function pointer and closure</h1></a>
<p>It is impossible to create a function pointer or closure from a
function that can throw exceptions. Indeed, because funtion pointers
type definition does not include the possibility to throw exception
(and will not for verbosity, and annoyance reason), the <em>Ymir</em>
language does not allow them to throw exception, in order to keep the
guarantee of safety introduced by exception rethrowing. For that
reason, the following example is not accepted by the compiler.</p>
<pre><code class="language-ymir">import std::io;


def main () {
    let x = |i : i32| =&gt; {
        assert (i &lt; 10, &quot;i must be lower than 10&quot;);
        println (i);
    };
        
     x (10);
}
</code></pre>
<p><br>
Errors:</p>
<pre><code class="language-error">Error : a lambda function must be safe, but there are exceptions that are not caught
 --&gt; main.yr:(5,13)
 5  ┃     let x = |i : i32| =&gt; {
    ╋             ^
    ┃ Note : &amp;(core::exception::AssertError)
    ┃  --&gt; main.yr:(6,9)
    ┃  6  ┃         assert (i &lt; 10, &quot;i must be lower than 10&quot;);
    ┃     ╋         ^
    ┗━━━━━┻━ 

Error : undefined symbol x
 --&gt; main.yr:(10,6)
10  ┃      x (10);
    ╋      ^


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>To avoid that problem, every exception must be caught inside the lambda function.</p>
<a class="header" href="print.html#create-function-pointer-from-unsafe-function" id="create-function-pointer-from-unsafe-function"><h2>Create function pointer from unsafe function</h2></a>
<p>Sometimes it can be usefull to create function pointer from functions
that are not safe (for example the function <strong><code>foo</code></strong> in the following
example). To do that, the core modules, define a template function
(<em>cf</em>. <a href="https://gnu-ymir.github.io/Documentations/en/templates/">Templates</a>,
named <strong><code>toOption</code></strong> that transform a function symbol, into another
function symbol that returns an option value. This other function
symbol can be used to create a function pointer, using the ampersand
(<strong><code>&amp;</code></strong>) unary operator.</p>
<pre><code class="language-ymir">import std::io;

def foo (i : i32)-&gt; void
    throws &amp;AssertError
{
    assert (i &lt; 10, &quot;i must be lower than 10&quot;);
    println (i);
}


def main () {
    let x = &amp; (toOption!foo);
    println (x (10));
    println (x (3));
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>Err(core::exception::AssertError (i must be lower than 10))
3
Ok()
</code></pre>
<p><br></p>
<p><em>Contribution</em> This is not possible for method delegate.</p>
<a class="header" href="print.html#templates" id="templates"><h1>Templates</h1></a>
<p>The templates system provide the possibility to reuse source code,
that is valid for multiple types. The template system of <em>Ymir</em> is
powerful, and allows the generation of code, that will be used many
times for many purpose, by writting minimal source code, and
conditional compilation. Templates is a main part of the <em>Ymir</em>
language, and almost everything in the standard library is written
using templates. It is important to understand the template system, to
use the language.</p>
<a class="header" href="print.html#template-definition-syntax" id="template-definition-syntax"><h2>Template definition syntax</h2></a>
<p>Multiple symbols in <em>Ymir</em> can be templates. Every template symbol has
a name, and the template parameters are following that name enclosed
between curly brackets (this time they are always mandatory). For
example, a function can be a template, as it can be seen in the
following example. In this example, the function <strong><code>foo</code></strong> takes a
type as template parameter, and this type is named <strong><code>T</code></strong> in the
function symbol, and is used as the type of the first parameter of the
function (i.e. the type of the parameter <strong><code>a</code></strong>). By convention, the
identifiers of the template parameters are in upper case, however that
is not mandatory.</p>
<pre><code class="language-ymir">def foo {T} (a : T) {
    println (a);
}
</code></pre>
<p><br></p>
<p>Other symbols can also be templates. These symbols are :</p>
<ul>
<li>Classes</li>
<li>Structures</li>
<li>Enumerations</li>
<li>Local modules</li>
<li>Traits</li>
<li>Aka</li>
</ul>
<p>The templates arguments always follows the name of the symbol. In the
following example, templates are defined for various symbols.</p>
<pre><code class="language-ymir">class A {T} {
    let value : T;
    
    pub self (v : T) with value = v {}
}

struct 
| x : T
-&gt; S {T};

enum 
| X = cast!T (12)
-&gt; F {T};

mod Inner {T} {
    pub def foo (a : T) {
        println (a);
    }
}

trait Z {T} {
    pub def foo (self, a : T)-&gt; T;
}

aka X {T} = cast!T (12);
</code></pre>
<p><br></p>
<a class="header" href="print.html#template-argument-syntax" id="template-argument-syntax"><h2>Template argument syntax</h2></a>
<p>The <em>template call</em> syntax is declared using the token <code>!</code>, followed
by one are multiple arguments, enclosed inside curly
brackets. Template arguments are elements that must be known by the
compiler at compile time, in order to produce a valid template
specialization and create a symbol that can be used and is fully
validated (i.e. where every types are correctly defined). The
following code block present the syntax of the <em>template
call</em>. <em>Template call</em> is a high priority expression, that has a even
higher level of priority than the <strong><code>::</code></strong> operator, and unary
operators. Operator priority is presented in the chapter <a href="https://gnu-ymir.github.io/Documentations/en/primitives/operator.html">Operator
priority</a>.</p>
<pre><code class="language-grammar">template_call := expression (single_arg | multiple_args) 
single_arg := '!' expression 
multiple_args := '!' '{' (expression | template_call) (',' (expression | template_call))*)? '}'
</code></pre>
<p><br></p>
<p>And the following code block presents example of <em>template call</em> on a
function named <strong><code>foo</code></strong>.</p>
<pre><code class="language-ymir">foo!i32 (12); // One template argument (i32)
foo!(i32, f32) (12); // One template tuple (i32, f32)
foo!{i32, f64} (12); // Two template arguments, types i32 and f64
</code></pre>
<p><br></p>
<p>When the arguments, are also template, the curly brackets are
mandatory even if there is only one parameter, to avoid ambiguity.</p>
<pre><code class="language-ymir">foo!{foo!i32} (); // Ok
foo!foo!i32 (); // No
</code></pre>
<p><br></p>
<a class="header" href="print.html#template-instanciation" id="template-instanciation"><h3>Template instanciation</h3></a>
<p>When a template symbol is defined, the <em>template call</em> is used to
reference it, and make a specialization. The arguments used in the
<em>template call</em> are associated to the template parameters of the
template symbol, in the order they are defined. In the following
example, a function <strong><code>foo</code></strong> has a template argument, that must be a
type, and is named <strong><code>T</code></strong>. The <strong><code>main</code></strong> function use the <em>template
call</em> syntax to use that symbol, and associate to <strong><code>T</code></strong> the type
<strong><code>i32</code></strong>. The symbol with a <strong><code>i32</code></strong> is then created by the
compiler, and the <strong><code>main</code></strong> function calls it using the standard call
syntax using the parentheses operator.</p>
<pre><code class="language-ymir">import std::io;

def foo {T} (a : T) {
    println (a);
}
    
def main () {
    foo!i32 (42);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>42
</code></pre>
<p><br></p>
<p>When the template symbol is a function, it can happened that the
template parameters can be infered from the parameters of the
function. For example in the above example, there is no need to
specify a <em>template call</em>, and the <em>standard call</em> expression is
sufficient.</p>
<pre><code class="language-ymir">import std::io;

def foo {T} (a : T) {
    println (a);
}
    
def main () {
    foo (42); // T, is infered as i32
    foo (&quot;Hi !!&quot;); // T, is infered as a [c32]
}
</code></pre>
<p><br>
Results:</p>
<pre><code>42
Hi !!
</code></pre>
<p><br></p>
<p>This cannot be done for structure or module. However, this is possible
to do on classes, and this will be presented a little later, in the
following section of the chapter.</p>
<p>We have seen in the chapter about
function (<em>cf</em>.
<a href="https://gnu-ymir.github.io/Documentations/en/primitives/functions.html">Functions</a>),
the <em>uniform call syntax</em>. This syntax is also applicable on template
functions. In the following example, a function that takes two types
as template parameters is called in the <strong><code>main</code></strong> function.</p>
<pre><code class="language-ymir">import std::io;

def foo {T} (a : T) {
    println (a);
}

def main () {
    (42).foo (); 
}
</code></pre>
<a class="header" href="print.html#multiple-template-parameters" id="multiple-template-parameters"><h3>Multiple template parameters</h3></a>
<p>As said earlier the parameters are specialized using the arguments of
the <em>template call</em> syntax in the order they are presented. For
example, in the following example, the <em>template call</em> syntax at line
<strong><code>1</code></strong> creates a symbol where <strong><code>T=i32</code></strong>, and <strong><code>U=f64</code></strong>.</p>
<pre><code class="language-ymir">def foo {T, U} () {}

def main () {
    foo!{i32, f64} ();
}
</code></pre>
<p><br></p>
<p>It is not necessary to put all the argument in the other template
parameters can be infered from the previous template arguments, or by
the parameters of the function. We will see in a next chapter some way
to determine the kind of type that can be used in a template symbol,
but briefly in the following example, the <strong><code>foo</code></strong> function only
accepts types that are slices of <strong><code>U</code></strong>, where <strong><code>U</code></strong> can
be any type. In that case, because <strong><code>T</code></strong> can be used to infer the
type of <strong><code>U</code></strong>, there is no need to specify the type of <strong><code>U</code></strong>
explicitly.</p>
<pre><code class="language-ymir">import std::io;

def foo {T of [U], U} () {
    println (&quot;T=&quot;, T::typeid, &quot; U=&quot;, U::typeid);
}

def main () {
    foo![i32] ();
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>T=[i32] U=i32
</code></pre>
<p><br></p>
<p>The same behavior can be observed when the type can be infered from a
standard parameter of the function. In the following example, the type
<strong><code>T</code></strong> is defined by the <em>template call</em> syntax, but the type <strong><code>U</code></strong>
is defined by the first argument of the <em>standard call</em>. Thus, type
<strong><code>T</code></strong> is <strong><code>i32</code></strong>, and type <strong><code>U</code></strong> is <strong><code>f64</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

def foo {T, U} (a : U) {
    println (&quot;T=&quot;, T::typeid, &quot; U=&quot;, U::typeid, &quot; a=&quot;, a, &quot;&quot;);
}

def main () {
    foo!i32 (3.14);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>T=i32 U=f64 a=3.140000
</code></pre>
<p><br></p>
<p>One can note that the type <strong><code>T</code></strong> cannot be infered from anything
aside the <em>template call</em>. Thus it has to be the first template
parameter, otherwise the <em>template call</em> would have defined the type
<strong><code>U</code></strong>. In the following example, the parameter <strong><code>T</code></strong> and <strong><code>U</code></strong>
have been reversed, but the call is the same. In that case, the
compiler fails to create a valid symbol and throws an error.</p>
<pre><code class="language-ymir">import std::io;

def foo {U, T} (a : U) {
    println (&quot;T=&quot;, T::typeid, &quot; U=&quot;, U::typeid, &quot; a=&quot;, a, &quot;&quot;);
}

def main () {
    foo!i32 (3.14); // set U to i32, and T cannot be infered
}
</code></pre>
<p><br>
Errors (in this error, we can see that <strong><code>U</code></strong> is set to <strong><code>i32</code></strong> at line <strong><code>10</code></strong>, and that the compiler failed to set <strong><code>T</code></strong>) :</p>
<pre><code class="language-error">Error : the call operator is not defined for foo {T}(a : U)-&gt; void and {f64}
 --&gt; main.yr:(8,10)
 8  ┃ 	foo!i32 (3.14);
    ╋ 	        ^    ^
    ┃ Note : candidate foo --&gt; main.yr:(3,5) : foo {T}(a : U)-&gt; void
    ┃     ┃ Error : unresolved template
    ┃     ┃  --&gt; main.yr:(3,13)
    ┃     ┃  3  ┃ def foo {U, T} (a : U) {
    ┃     ┃     ╋             ^
    ┃     ┃ Note : for : foo --&gt; main.yr:(3,5) with (U = i32)
    ┃     ┗━━━━━━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>Using the <em>template call</em> syntax to set only a part of the template
symbols is named a <em>two time template validation</em>. We will see in the
next chapter, that template specialization can be very powerful and
can be used to choose between multiple template symbols. Refering to a
template symbol without using the <em>template call</em> syntax can be seen
as a special case of <em>two time validation</em>, where the <em>template call</em>
is made but with no arguments.</p>
<a class="header" href="print.html#template-class-instanciation" id="template-class-instanciation"><h3>Template class instanciation</h3></a>
<p>When a class template is declared, the compiler is sometimes able to
infer the type of the templates from the argument passed to the
constructors. The rule is the same as for function instanciation. In
the following example, the class <strong><code>X</code></strong> is a template class that
takes two types as template parameters. The <strong><code>main</code></strong> function
instanciate a <strong><code>X</code></strong> class at line <strong><code>10</code></strong> without using the
<em>template call</em> syntax. This is possible, because the constructor of
the class at line <strong><code>6</code></strong> is sufficient to infer the types <strong><code>T</code></strong> and
<strong><code>U</code></strong> exactly as it would be done if it was a function
template. Because <strong><code>T</code></strong> and <strong><code>U</code></strong> has no restriction any type can
be used.</p>
<pre><code class="language-ymir">import std::io;

class X {T, U} {
    let x : T, y : U;

    pub self (x : T, y : U) with x = x, y = y {}	
}

def main () {
    let a = X::new (1, 'r');
    let b = X::new ([1, 2], &quot;foo&quot;);
    
    println (a::typeinfo.name);
    println (b::typeinfo.name);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>main::X(i32,c32)::X
main::X([i32],[c32])::X
</code></pre>
<p><br></p>
<p>A <em>two time validation</em> can also be used to set the types of a part of
the template parameters, and let the other be infered by the
constructor call. In the following example, the type <strong><code>T</code></strong> is set by
the <em>template call</em> syntax, and the type <strong><code>U</code></strong> is infered from the
type of the parameter <strong><code>y</code></strong> of the constructor (here <strong><code>c32</code></strong>).</p>
<pre><code class="language-ymir">import std::io;

class X {T, U} {
    let y : U;

    pub self (y : U) with y = y {}	
}

def main () {
    let x = X!(i32)::new ('r');
    println (x::typeinfo.name);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>main::X(i32,c32)::X
</code></pre>
<p><strong>Contribution</strong> other template symbols cannot be called without
<em>template call</em>. This is normal for modules, traits, and enumeration,
as nothing can be used to infer the types. But structures are called
using arguments, that are used to set the values of the fields, this
is thus possible to infer the templates types in that case. Has to be
done, though.</p>
<a class="header" href="print.html#template-specialization" id="template-specialization"><h1>Template specialization</h1></a>
<p>We have seen in the last chapter, the declaration of template symbol,
that can be instanciated using any types. Sometimes, it can be usefull
to restrict the set of types that can be used in a given template
symbol (e.g. only slices but of any type, only classes, only
structures, etc.). In order to make this possible, the <em>Ymir</em> language
offers some elements to filter the different types that can be used.</p>
<p>The following code block present the complete syntax of a template
parameter.</p>
<pre><code class="language-grammar">template_parameter := Identifier | of_filter | class_filter | struct_filter | impl_filter | variadic_filter

of_filter := Identifier 'of' type
class_filter := 'class' Identifier
struct_filter := 'struct' Identifier
impl_filter := Identifier impl type
variadic_filter := Identifier '...'
</code></pre>
<p><br></p>
<p>One can note that every template parameters have an Identifier. This
identifier are the root of the specialization tree. For example, in
the following template parameters <strong><code>{T of [U], U}</code></strong> there are two
roots, <strong><code>T</code></strong> and <strong><code>U</code></strong>. The root <strong><code>U</code></strong> is important, these
template parameters are different to <strong><code>{T of [U]}</code></strong>. In the first
case, the identifier <strong><code>U</code></strong> refers to a template type (as it is a
root of the parameters), and in the second case it refers directly to
a type that is named <strong><code>U</code></strong>, and that has to be declared somewhere.</p>
<a class="header" href="print.html#of-filter" id="of-filter"><h2>Of filter</h2></a>
<p>The <em>of filter</em> is declared using the keyword <strong><code>of</code></strong>. This filter is
used to specify the form of the type that can be used to instanciate
the template. The form can be any form of type, it can be for example
a slice, an array, a template symbol, etc. In the following example,
the first function <strong><code>foo</code></strong> declared at line <strong><code>6</code></strong>, is a template
function that can be instanciated using only <strong><code>T=i32</code></strong>. The second
function <strong><code>foo</code></strong> at line <strong><code>14</code></strong> use the <strong><code>of</code></strong> filter to inform
that the type <strong><code>T</code></strong> must have the same form as the type <strong><code>Z</code></strong>, but
does not filter the type <strong><code>Z</code></strong>. The third function <strong><code>foo</code></strong> at line
<strong><code>21</code></strong>, accepts for the type <strong><code>T</code></strong> any slice that have as internal
type a template type declared as <strong><code>Z</code></strong>, there is no filter on
<strong><code>Z</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

/**
 * This function will only be callable, with a i32 as T
 */
def foo {T of i32} (_ : T) {
    println (&quot;First ??&quot;);
}

/**
 * This function will only be callable, with a type that fit the Z pattern
 * That is to say every type
 */
def foo {T of Z, Z} (_ : T) {
    println (&quot;Second ?&quot;);
}

/**
 * This function will be only callable, with a slice of Z, where Z can be anything
 */
def foo {T of [Z], Z} (_ : T) {
    println (&quot;Third !&quot;);
}

def main () {
    foo ([1, 2]);
}
</code></pre>
<p><br></p>
<p>In the above example, one can note that, two functions can be called
by the expression <code>foo ([1, 2])</code>. The second and third ones. The
template definition that match the best the types, will be used. Here,
this is the third one, the filter is more specific and thus has a
better score.</p>
<p>Results:</p>
<pre><code>Third !
</code></pre>
<p><br></p>
<p>The <em>of filter</em> is a kind of destructuring pattern. They can be
chained, and composed with other filters. Here some other example,
where this time the <em>of filter</em> is used to get the template types
parameters of a given class type, and apply some filter on them.</p>
<pre><code class="language-ymir">import std::io;

/** A template class, that takes any type as template parameters */
class X {T} {
    let _x : T;
    
    pub self (x : T) with _x = x {}
}

/**
 * This function accepts any X object, as long as its template parameter is a slice
 */
def foo {T of &amp;(X!{U}), U of [Z], Z} (x : T) {
    println (&quot;Slice X : &quot;, x::typeinfo.name);
}

/**
 * Accept all the X objects, that have not been accepted by the first function
 * Indeed, the template is less specific, and is used only if the first one fails
 */
def foo {T of &amp;(X!{U}), U} (x : T) {
    println (&quot;Not a slice X : &quot;, x::typeinfo.name);
}


def main () {
    let a = X::new ([1, 2, 3]);
    let b = X::new (&quot;Test&quot;);
    let c = X::new (23.0f);
    
    foo (a);
    foo (b);
    foo (c);
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Slice X : main::X([i32])::X
Slice X : main::X([c32])::X
Not a slice X : main::X(f32)::X
</code></pre>
<p><br></p>
<p>As presented in the introduction of this chapter, there is a
difference between identifier that can be found in the roots of the
template parameters and those which are not. In the following example,
the <strong><code>foo</code></strong> function accept a slice of <strong><code>U</code></strong> where <strong><code>U</code></strong> is not
defined, resulting in an error by the compiler. Indeed, the type
<strong><code>U</code></strong> could have been defined somewhere, and there must be a
distinction between this type and a template parameter.</p>
<pre><code class="language-ymir">import std::io;

def foo {T of [U]} (a : T) {}

def main () {
    foo ([1, 2]);
}
</code></pre>
<p><br>
Errors:</p>
<pre><code class="language-error">Error : the call operator is not defined for foo {T of [U]}(a : T)-&gt; void and {mut [mut i32]}
 --&gt; main.yr:(6,6)
 6  ┃ 	foo ([1, 2]);
    ╋ 	    ^      ^
    ┃ Note : candidate foo --&gt; main.yr:(3,5) : foo {T of [U]}(a : T)-&gt; void
    ┃     ┃ Error : undefined type U
    ┃     ┃  --&gt; main.yr:(3,16)
    ┃     ┃  3  ┃ def foo {T of [U]} (a : T) {}
    ┃     ┃     ╋                ^
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="print.html#struct-and-class-filters" id="struct-and-class-filters"><h2>Struct and Class filters</h2></a>
<p>The keywords <code>struct</code> and <code>class</code> defines respecitvely the <em>struct</em>
and <em>class filters</em>. They filter the accepted types of a template
symbol. Unlike <em>of filter</em> they cannot be chained, and accept only an
identifier. In the following example, the first <strong><code>foo</code></strong> function at
line <strong><code>11</code></strong> is instanciable using a class type, and the second at
line <strong><code>15</code></strong> only accept struct types. <strong>Warning</strong> <em>class filter</em>
accepts a reference class type, and not directly the class type
(<strong><code>&amp;A</code></strong> not <strong><code>A</code></strong>).</p>
<pre><code class="language-ymir">import std::io

struct 
| x : i32
-&gt; X;

class A {
    self () {}
}

def foo {class T} () {
    println (&quot;Class !&quot;);
}

def foo {struct T} () {
    println (&quot;Struct !&quot;);
}

def main () {
    foo!(&amp;A) ();
    foo!(X) ();
} 
</code></pre>
<p><br>
Results:</p>
<pre><code>Class !
Struct !
</code></pre>
<p><br></p>
<p>Even if this filters cannot be chained, they can be used as the leaf
of a <em>of filter</em>. In the following example, the function <strong><code>foo</code></strong>
accepts a slice of class objects.</p>
<pre><code class="language-ymir">import std::io;

class A {
    pub self () {}
    impl Streamable;
}

class B {
    pub self () {}
    impl Streamable;
}

def foo {T of [U], class U} (a : T) {
    println (T::typeid, &quot; = &quot;, a, &quot;&quot;);
}

def main () {
    foo ([A::new (), A::new ()]);
    foo ([B::new ()]);
}
</code></pre>
<p><br>
Results:</p>
<pre><code>[&amp;(main::A)] = [main::A(), main::A()]
[&amp;(main::B)] = [main::B()]
</code></pre>
<a class="header" href="print.html#implement-filter" id="implement-filter"><h2>Implement filter</h2></a>
<p>We have seen in the chapter about traits
(<em>cf</em>. <a href="https://gnu-ymir.github.io/Documentations/en/objects/traits.html">Traits</a>),
that class type can implement a given trait. Implementing a trait
gives specific method to a class type, that can be called. However
traits lose most of their interest if it is impossible to accept a
type that implements the trait without knowning the type itself. This
cannot be done by inheritance, as traits are not types, however
templates have a specific filter to perform this operation. In the
following example, the <em>impl filter</em> is used by the <strong><code>foo</code></strong>
function, that thus accepts any kind of object as long as they impl
the trait <strong><code>Getter</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

trait Getter {
    pub def get (self)-&gt; i32;
}

class A {

    pub self () {}
    
    impl Getter {
        pub over get (self)-&gt; i32 {
            12
        }
    }

}

def foo {T impl Getter} (a : T) -&gt; i32 {
    a.get ()
}

def main () {
    let a = A::new ();
    println (foo (a));
}
</code></pre>
<p><br></p>
<p>A trait can be a template symbol. In that case it has some template
parameters, that can be destructured by a template filter. For
example, in the following source code, the trait <strong><code>Getter</code></strong> is a
template, that is implemented using the type <strong><code>i32</code></strong> by the class
<strong><code>A</code></strong>. The first <strong><code>foo</code></strong> function at line <strong><code>1</code></strong> accepts any kind
of object as long as they impl the trait <strong><code>Getter</code></strong>, and filter the
template parameter of this trait to get it under the identifier
<strong><code>X</code></strong>. The second <strong><code>foo</code></strong> function only accepts types that
implements the trait but using a slice. Because the second <strong><code>foo</code></strong>
function is more specific when using <strong><code>&amp;B</code></strong> object, it is called at
line <strong><code>44</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

trait Getter {T} {
    pub def get (self)-&gt; T;
}

class A {

    pub self () {}
    
    impl Getter!{i32} {
        pub over get (self)-&gt; i32 {
            12
        }
    }
}

class B {

    pub self () {}
    
    impl Getter!{[i32]} {
        pub over get (self)-&gt; [i32] {
            [12, 24]
        }
    }
}

def foo {T impl Getter!{X}, X} (a : T) -&gt; X {
    print (&quot;First : &quot;);
    a.get ()
}

def foo {T impl Getter!{X}, X of [U], U} (a : T)-&gt; X {
    print (&quot;Second : &quot;);
    a.get ()
}

def main () {
    let a = A::new ();
    let b = B::new ();
    
    println (foo (a));
    println (foo (b));
}
</code></pre>
<p><br>
Results:</p>
<pre><code>First : 12
Second : [12, 24]
</code></pre>
<p><br></p>
<a class="header" href="print.html#variadic-templates" id="variadic-templates"><h2>Variadic templates</h2></a>
<p>Variadic templates are special templates, that takes an arbitrary
number of type as arguments. They are defined using an identifier
followed by the token <code>...</code>. When the specialization is done, the
identifier of the variadic template, can be used to define a tuple
type. In the following example, the type of the parameter <strong><code>a</code></strong> of
the <strong><code>foo</code></strong> function is <strong><code>(i32, i32, i32, i32, i32)</code></strong>. <strong>Warning</strong>
If only one type is given to the variadic template, then it is not a
tuple, but directly the type that has been given. As you may have
guessed by now, the <code>println</code> function is a variadic template
function.</p>
<pre><code class="language-ymir">import std::io

def foo {T ...} (a : T) {
    println (a.0, expand a);
}

def main () {
    foo (1, 2, 3, 4, 5);
}
</code></pre>
<p><br>
Results:</p>
<pre><code>112345
</code></pre>
<p><br></p>
<p>The identifier can also be used to complete another type. For example,
a function pointer type. In the following source code, the structure
<strong><code>X</code></strong> accepts an arbitrary number of type as template parameters,
and use them to form the type of the field <strong><code>foo</code></strong>. When
instanciated by the <strong><code>main</code></strong> function at line <strong><code>12</code></strong>, the field
<strong><code>foo</code></strong> takes the type <strong><code>fn (i32, f32)-&gt; void</code></strong>.</p>
<pre><code class="language-ymir">import std::io

struct 
| foo : fn (T)-&gt; void
 -&gt; X {T...};
 
def foo (x : i32, y : f32)-&gt; void {
    println (&quot;(&quot;, x, &quot;, &quot;, y, &quot;)&quot;);
}
 
def main () {
    let x = X!{i32, f32} (&amp;foo);
    x.foo (12, 3.14f);
}
</code></pre>
<p><br>
Results:</p>
<pre><code>(12, 3.140000)
</code></pre>
<p><br></p>
<p>To force the type to be a tuple inside another type, the standard
syntax of tuple can be used. For example, the field <strong><code>foo</code></strong> could
have been defined as follows <strong><code>fn ((T,))-&gt; void</code></strong>, in that case it
would have been equal to <strong><code>fn ((i32, f32))-&gt; void</code></strong>, meaning a
function pointer that takes a parameter of type <strong><code>(i32, f32)</code></strong>, and
returns nothing.</p>
<a class="header" href="print.html#recursive-variadic-template" id="recursive-variadic-template"><h3>Recursive variadic template</h3></a>
<p>Variadic template must contain at least one type. To perfom recursive
variadic function, end case functions must be written, this end case
generally contains a standard template parameter. For example, the
following example presents a <strong><code>foo</code></strong> function that takes variadic
parameters, and prints them. The end case is described at line
<strong><code>3</code></strong>, where the function takes only one standard template
parameter. The function <strong><code>foo</code></strong> at line <strong><code>8</code></strong> takes two template
parameter, a standard one that will be used for the first parameter of
the function, and a variadic one for the rest of the parameters. One
can note from the line <strong><code>5</code></strong> that even if the type of <strong><code>b</code></strong> is
<strong><code>c8</code></strong> and thus not a tuple, the keyword <strong><code>expand</code></strong> is usable, and
does nothing particular.</p>
<pre><code class="language-ymir">import std::io;

def foo {F, R...} (a : F, b : R) {
    println (&quot;FST : &quot;, F::typeid, &quot;(&quot;, a, &quot;)&quot;);
    foo (expand b);
}

def foo {F} (a : F) {
    println (&quot;SCD : &quot;, F::typeid, &quot;(&quot;, a, &quot;)&quot;);
}

def main () {
    foo (1, 3.f, &quot;Test&quot;, 'r'c8);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>FST : i32(1)
FST : f32(3.000000)
FST : [c32](Test)
SCD : c8(r)
</code></pre>
<a class="header" href="print.html#template-values" id="template-values"><h1>Template values</h1></a>
<p>In <em>Ymir</em>, templates are seen as compilation time execution
parameters. These parameters can be either types or values. When
dealing with values, as with any values, decisions and program
branching can be made, but because these values are known at
compilation time, the decisions can also be made at compilation
time. This system is called <em>compilation time execution</em> or <em>cte</em> for
short. The keyword <strong><code>cte</code></strong> is used to ensure that a part of the code
is executed at compilation time, and generates a value (that can be
<strong><code>void</code></strong>) at compilation as well, to save time at execution time and
have a better optimized executable.</p>
<a class="header" href="print.html#compilation-time-values" id="compilation-time-values"><h2>Compilation time values</h2></a>
<p>Basically, every values can be known at compilation time as long as
they do not implies variable, or dynamic branching. For example, the
value of the <strong><code>foo</code></strong> function in the following source code can be
knwon at compilation time. Indeed, it implies only constants, that can
be computed by the compiler directly. The <strong><code>main</code></strong> function uses the
keyword <strong><code>cte</code></strong> to force the compiler to call the function <strong><code>foo</code></strong>
during the compilation. If the keyword is omitted then the function
<strong><code>foo</code></strong> is called at execution time.</p>
<pre><code class="language-ymir">import std::io;

def foo () -&gt; i32 {
    bar () + baz ()
}
    
def bar () -&gt; i32 
    12
    
def baz () -&gt; i32
    30
    
def main () {
    let z = cte foo ();
    println (z);
}
</code></pre>
<p><br> To verify that the <em>compilation time execution</em> effectively
happened, the option <strong><code>-fdump-tree-gimple</code></strong> can be used. This option
creates alternative files, that give information about the
compilation, and can be used to see what the frontend of the <em>Ymir</em>
compiler gave to the <strong>gcc</strong> compiler (source code close the <em>C
language</em>). The following block of code presents a part of the content
of this file. One can note that the <strong><code>main</code></strong> function does not call
the <strong><code>foo</code></strong> function, but only the <strong><code>println</code></strong> function with the
value <strong><code>42</code></strong>.</p>
<pre><code>main ()
{
  {
    signed int z;

    z = 42;
    _Y3std2io11printlnNi327printlnFi32Zv (z);
  }
}
</code></pre>
<a class="header" href="print.html#values-as-template-parameter" id="values-as-template-parameter"><h2>Values as template parameter</h2></a>
<p>We have seen in the previous chapter that templates parameters are
used to accept types. They also can be used to accept values, in that
case the syntax - described in the following code block - is a bit
different. The syntax for template values is close to variable
declaration, using the token <strong><code>:</code></strong>, or by using directly the literal
that is accepted.</p>
<pre><code class="language-grammar">template_value := literal | Identifier ':' (Identifier | type) ('=' literal)?
</code></pre>
<a class="header" href="print.html#template-literal" id="template-literal"><h3>Template literal</h3></a>
<p>A literal that can be known at compilation time can be used to make a
template specialization. The types that can be knwon at compilation
time are the following :</p>
<ul>
<li>string ([c8] or [c32])</li>
<li>char (c8 or c32)</li>
<li>integer (signed or unsigned)</li>
<li>float</li>
</ul>
<p><strong>Contribution</strong>: tuple, and struct are not compilation time knowable,
but this seems possible if they only contains <em>cte</em> values, same for
slice that are not strings.</p>
<p>In the following example, there are three different definition of the
function <strong><code>foo</code></strong>. The first one at line <strong><code>3</code></strong> can be called using
a the <em>cte</em> value <strong><code>3</code></strong>, the second one at line <strong><code>8</code></strong> using the
value <strong><code>2</code></strong>, and so on. The <strong><code>main</code></strong> function calls the function
<strong><code>foo</code></strong> using the value <strong><code>5 - 2</code></strong>, so the first definition at line
<strong><code>3</code></strong> is used.</p>
<pre><code class="language-ymir">import std::io;

def foo {3} () {
    println (&quot;3&quot;);
    foo!2 ();
}

def foo {2} () {
    println (&quot;2&quot;);
    foo!1 ();
}

def foo {1} () {
    println (&quot;1&quot;);
    foo!0 ();
}

def foo {0} () {
    println (&quot;Go !&quot;);
}

def main () {
    foo!{5 - 2} ();
} 
</code></pre>
<p><br>
Results:</p>
<pre><code>3
2
1
Go !
</code></pre>
<p><br></p>
<p>Literal string can also be used as template parameter. We will see in
a forthcoming chapter that those are used for operator overloading
(<em>cf</em>. <a href="https://gnu-ymir.github.io/Documentations/en/templates/operators.html">Operator
overloading</a>). A
simple example is presented in the following source code, where the
<strong><code>foo</code></strong> function accepts the literal <strong><code>Hi I'm foo !</code></strong>, and is called
by the <strong><code>main</code></strong> function using different ways.</p>
<pre><code class="language-ymir">import std::io;

def foo {&quot;Hi I'm foo !&quot;} () {
    println (&quot;Yes that's true !&quot;);
}

def bar () -&gt; [c32] {
    &quot;I'm foo !&quot;
}

def main () {
    foo!&quot;Hi I'm foo !&quot; ();
    foo!{&quot;Hi &quot; ~ bar ()} (); 
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Yes that's true !
Yes that's true !
</code></pre>
<a class="header" href="print.html#template-variable" id="template-variable"><h3>Template variable</h3></a>
<p>Because it would be utterly exhausting to write every definitions of
the template function with every possible literals (and even
impossible when dealing with infinite types such as slice), we
introduced the possibilty of writing template variables. Unlike real
variables those are evaluated at compilation time, and can be defined
only inside template parameters. The definition syntax of template
variable is close to the definition of a standard parameter, with the
difference that the type can be a template type (containing root
identifiers, foundable inside the template parameters). The following
example presents the definition of a function that make a countdown to
<strong><code>0</code></strong> (the generalization of the function <strong><code>foo</code></strong> presented in the
first example of the previous section). For the recursivity to stop,
the definition of a final case is mandatory, here it is achieved by
the function <strong><code>foo</code></strong> at line <strong><code>8</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

def foo {n : i32} () {
    println (n);
    foo!{n - 1} ();
}

def foo {0} () {
    println (&quot;Go !&quot;);
}

def main () {
    foo!12 ();
}
</code></pre>
<p><br>
Results:</p>
<pre><code>12
11
10
9
8
7
6
5
4
3
2
1
Go !
</code></pre>
<p><br></p>
<p><strong>Limitation</strong>: to avoid infinite loops, the compiler uses a very
simple verification. It is impossible to make more that <strong><code>300</code></strong>
recursive call. For that reason, make the following call <strong><code>foo!300 ()</code></strong> is impossible and generate a compilation error :</p>
<pre><code class="language-error">Error : undefined template operator for foo and {300}
 --&gt; main.yr:(13,5)
13  ┃ 	foo!300 ();
    ╋ 	   ^
    ┃ Error : undefined template operator for foo and {300}
    ┃  --&gt; main.yr:(13,5)
    ┃ 13  ┃ 	foo!300 ();
    ┃     ╋ 	   ^
    ┃     ┃ Note : in template specialization
    ┃     ┃  --&gt; main.yr:(13,5)
    ┃     ┃ 13  ┃ 	foo!300 ();
    ┃     ┃     ╋ 	   ^
    ┃     ┃ Note : foo --&gt; main.yr:(3,5) -&gt; foo
    ┃     ┃ Error : undefined template operator for foo and {299}
    ┃     ┃  --&gt; main.yr:(5,5)
    ┃     ┃  5  ┃ 	foo!{n - 1} ();
    ┃     ┃     ╋ 	   ^
    ┃     ┃     ┃ Error : undefined template operator for foo and {299}
    ┃     ┃     ┃  --&gt; main.yr:(5,5)
    ┃     ┃     ┃  5  ┃ 	foo!{n - 1} ();
    ┃     ┃     ┃     ╋ 	   ^
    ┃     ┃     ┃     ┃      : ...
    ┃     ┃     ┃     ┃ Note : there are other errors, use option -v to show them
    ┃     ┃     ┃     ┃ Error : undefined template operator for foo and {2}
    ┃     ┃     ┃     ┃  --&gt; main.yr:(5,5)
    ┃     ┃     ┃     ┃  5  ┃ 	foo!{n - 1} ();
    ┃     ┃     ┃     ┃     ╋ 	   ^
    ┃     ┃     ┃     ┃     ┃ Note : in template specialization
    ┃     ┃     ┃     ┃     ┃  --&gt; main.yr:(5,5)
    ┃     ┃     ┃     ┃     ┃  5  ┃ 	foo!{n - 1} ();
    ┃     ┃     ┃     ┃     ┃     ╋ 	   ^
    ┃     ┃     ┃     ┃     ┃ Note : foo --&gt; main.yr:(3,5) -&gt; foo
    ┃     ┃     ┃     ┃     ┃ Error : undefined template operator for foo and {1}
    ┃     ┃     ┃     ┃     ┃  --&gt; main.yr:(5,5)
    ┃     ┃     ┃     ┃     ┃  5  ┃ 	foo!{n - 1} ();
    ┃     ┃     ┃     ┃     ┃     ╋ 	   ^
    ┃     ┃     ┃     ┃     ┃     ┃ Error : undefined template operator for foo and {1}
    ┃     ┃     ┃     ┃     ┃     ┃  --&gt; main.yr:(5,5)
    ┃     ┃     ┃     ┃     ┃     ┃  5  ┃ 	foo!{n - 1} ();
    ┃     ┃     ┃     ┃     ┃     ┃     ╋ 	   ^
    ┃     ┃     ┃     ┃     ┃     ┃     ┃ Note : in template specialization
    ┃     ┃     ┃     ┃     ┃     ┃     ┃  --&gt; main.yr:(5,5)
    ┃     ┃     ┃     ┃     ┃     ┃     ┃  5  ┃ 	foo!{n - 1} ();
    ┃     ┃     ┃     ┃     ┃     ┃     ┃     ╋ 	   ^
    ┃     ┃     ┃     ┃     ┃     ┃     ┃ Note : foo --&gt; main.yr:(3,5) -&gt; foo
    ┃     ┃     ┃     ┃     ┃     ┃     ┃ Error : limit of template recursion reached 300
    ┃     ┃     ┃     ┃     ┃     ┃     ┃  --&gt; main.yr:(3,5)
    ┃     ┃     ┃     ┃     ┃     ┃     ┃  3  ┃ def foo {n : i32} () {
    ┃     ┃     ┃     ┃     ┃     ┃     ┃     ╋     ^^^
    ┃     ┃     ┃     ┃     ┃     ┃     ┗━━━━━┻━ 
    ┃     ┃     ┃     ┃     ┃     ┗━━━━━┻━ 
    ┃     ┃     ┃     ┃     ┗━━━━━┻━ 
    ┃     ┃     ┃     ┗━━━━━┻━ 
    ┃     ┃     ┗━━━━━┻━ 
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br> <strong>Contribution</strong>: add an option to the compiler to change this
value of <strong><code>300</code></strong>.</p>
<a class="header" href="print.html#template-type-for-template-variable" id="template-type-for-template-variable"><h3>Template type for template variable</h3></a>
<p>The type of a <em>cte</em> variable can be a template. In that case the used
template identifiers must be roots of the template parameters (exactly
the same behavior as the <em>of filter</em>). In the following example, the
function <strong><code>foo</code></strong> takes a value as template parameter, the type of
this value can be anything as long as it can be known at compile time.</p>
<pre><code class="language-ymir">import std::io;

def foo {N : T, T} () {
    println (T::typeid, &quot;(&quot;, N, &quot;)&quot;);
}

def main () {
    foo!42 ();
    foo!&quot;Hi !&quot; ();
}
</code></pre>
<p><br>
Results:</p>
<pre><code>i32(42)
[c32](Hi !)
</code></pre>
<p><br> Compilation time values, can also be used to get the size of a
static array at compilation time, and make a template function that
accepts arrays of any size. This evidently works only on static
arrays, and not on slice, because the size of the array has to be
knwon at compilation time. However, this would not be necessary when
using slice, because function accepting slice as parameter already
accepts slices of any size.</p>
<pre><code class="language-ymir">import std::io

def foo {ARRAY of [T; N], T, N : usize} (a : ARRAY) {
    println (&quot;Got an array of &quot;, T::typeid, &quot; of size : &quot;, N);
    println (a);
}

def main () {
    let array = [0; 10u64];
    foo (array);
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Got an array of i32 of size : 10
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
<a class="header" href="print.html#function-pointers" id="function-pointers"><h2>Function pointers</h2></a>
<p>Lambda functions and function pointers can be compile time knwon
values. This is not the case for closure, and method delegates. Unlike
function pointers, template function are statically written in the
generated executable, thus more efficient (even if we are talking of
marginal gain). To accept a function pointer, a template variable must
be defined in the template parameters. In the following example, the
function <strong><code>foo</code></strong> accepts a function pointer, that takes two
parameters, and return a value of the same type of the
parameters. This type seems to be unknown and is not inferable from
the lambda function that is passed to the function at line <strong><code>13</code></strong>,
but is infered from the execution time parameters passed to the
function. At line <strong><code>14</code></strong>, one can note that a standard function can
be used as a template variable.</p>
<pre><code class="language-ymir">import std::io;


def foo {F : fn (X, X)-&gt; X, X} (a : X, b : X) {
    println (&quot;Foo : &quot;, F (a, b));
}

def bar (a : i32, b : i32) -&gt; i32 {
    a * b
}

def main () {
    foo!{|x, y| =&gt; x + y} (11, 31);
    foo!bar (6, 7);
}
</code></pre>
<p><br>
Results</p>
<pre><code>Foo : 42
Foo : 42
</code></pre>
<p><br> In the following example, the function pointer this time return a
different type from the type of the parameters it takes. This function
<strong><code>foo</code></strong> applies this function pointer to all element of the slice it
takes as parameters.</p>
<pre><code class="language-ymir">import std::io;

def foo {F : fn (X)-&gt; Y, X, Y} (a : [X]) {
    for i in a {
        println (&quot;Foo : &quot;, F (i));
    }
}

def main () {
    foo!{|x| =&gt; cast!i64 (x) + 12i64} ([1, 2, 3]);
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Foo : 13
Foo : 14
Foo : 15
</code></pre>
<a class="header" href="print.html#template-values-1" id="template-values-1"><h1>Template values</h1></a>
<p>In the previous chapter, we saw that some values can be known at the
time of compilation. These values can be used for the compiler to
decide which part of the code should be compiled and which part should
not, using branching operations.</p>
<a class="header" href="print.html#compile-time-condition" id="compile-time-condition"><h2>Compile time condition</h2></a>
<p>The keyword <strong><code>cte</code></strong> is used to inform the compiler that a value can
be known at compile time, and must be evaluated during the
compilation. It is not the default behavior of the compiler, as the
compilation would be extremely long, if every values had to be
checked. This keyword can be used on <em>if expression</em> to execute the
condition at compile time, and evaluate compile only a part of the
source code. In the following example, an <em>if expression</em> is used to
check if the template value that is passed to the <strong><code>foo</code></strong> function
was lower than <strong><code>10</code></strong>. Because it is the case only the scope of the
<em>if expression</em> is compiled (not the scope of the <em>else</em>), that is why
even if the scope of the <em>else</em> part has no sense in term of types,
the compiler does not return any error.</p>
<pre><code class="language-ymir">import std::io;

def foo {X : i32} () {
    cte if X &lt; 10 {
        println (&quot;X is &lt; 10 : &quot;, X);
    } else {
        println (X + &quot;foo&quot;);
    }
}

def main () {
    foo!{2} ();
}
</code></pre>
<p><br>
Results:</p>
<pre><code>X is &lt; 10 : 2
</code></pre>
<p><br> As normal <em>if expression</em>, <em>cte if expression</em> can be chained,
however the keyword <em>cte</em> must be repeated before each <em>if expression</em>
otherwise the compiler consideres that they are execution time <em>if
expression</em>.</p>
<pre><code class="language-ymir">import std::io;

def foo {X : i32} () {
    cte if X &lt; 10 {
        println (&quot;X is &lt; 10 : &quot;, X);
    } else cte if X &lt; 25 {
        println (&quot;X is &lt; 25 : &quot;, X);
    } else {
        println (&quot;X is &gt; 25 : &quot;, X);
    }
}

def main () {
    foo!{2} ();
    foo!{14} ();
    foo!{38} ();
}
</code></pre>
<p><br></p>
<pre><code>X is &lt; 10 : 2
X is &lt; 25 : 14
X is &gt; 25 : 38
</code></pre>
<a class="header" href="print.html#is-expression" id="is-expression"><h2>Is expression</h2></a>
<p>The <em>is expression</em> (that must not be confused with the <em>is operator</em>
applicable only on pointers) is used to check template specialization,
and gives a <em>cte bool value</em>. The syntax of the <em>is expression</em> is
similar to the syntax of a template call, following by template
parameters, as presented in the following code block. The template
parameters are used to create a specialization from the template
arguments.</p>
<pre><code class="language-grammar">is_expression := 'is' '!' (single_arg | multiple_args) '{' (template_parameter (',' template_parameter)*)? '}'
</code></pre>
<p><br></p>
<p>In the following example, the <strong><code>foo</code></strong> function accepts any kind of
type as template parameter, and a <em>cte if expression</em> is used to apply
a different behavior depending on the type of <strong><code>X</code></strong>. The first test
at line <strong><code>1</code></strong> works if the <strong><code>X</code></strong> is a <strong><code>i32</code></strong>, the second at
line <strong><code>2</code></strong> works if <strong><code>X</code></strong> is a slice of anything.</p>
<pre><code class="language-ymir">import std::io;

def foo {X} () {
    cte if is!{X} {T of i32} {
        println (&quot;Is a i32&quot;);
    } else cte if is!{X} {T of [U], U} {
        println (&quot;Is a slice&quot;);
    } else cte if is!{X} {T of [U; N], U, N : usize} {
        println (&quot;Is a static array&quot;);
    } else {
        println (&quot;I don't know ...&quot;);
    }
}

def main () {
    foo!i32 ();
    foo![i32] ();
    foo![i32 ; 4us] ();
    foo!f32 ();
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Is a i32
Is a slice
Is a static array
I don't know ...
</code></pre>
<p><br></p>
<p><strong>Warning</strong> An is expression is not a complete template
specialization, it is not attached to any code block. Thus the
variable declared inside the expression are not accessible from
anywhere. It is a volontary limitation, if the variable are to be used
a declaration such as a function, must be made.</p>
<a class="header" href="print.html#cte-assert" id="cte-assert"><h2>Cte assert</h2></a>
<p>The keyword <strong><code>cte</code></strong> can be used on an <strong><code>assert</code></strong> expression. In
that case the condition of the assertion must be known at compilation
time. If the value of the condition is false, then an error is thrown
by the compiler, with the associated message. In the following
example, the assert test wether the template class <strong><code>T</code></strong> implements
the traits <strong><code>Hashable</code></strong>, and throws an explicit error message.</p>
<pre><code class="language-ymir">trait Useless {}

class X {class T} {
    cte assert (is!T {U impl Useless}, T::typeid ~ &quot; does not implement Useless&quot;);
    
    pub self () {}	
}

class B {}

def main () {
    let _ = X!{&amp;B}::new ();
}
</code></pre>
<p><br>
Errors:</p>
<pre><code class="language-error">Note : 
 --&gt; main.yr:(12,14)
12  ┃     let _ = X!{&amp;B}::new ();
    ╋              ^
    ┃ Error : undefined template operator for X and {&amp;(main::B)}
    ┃  --&gt; main.yr:(12,14)
    ┃ 12  ┃     let _ = X!{&amp;B}::new ();
    ┃     ╋              ^
    ┃     ┃ Note : in template specialization
    ┃     ┃  --&gt; main.yr:(12,14)
    ┃     ┃ 12  ┃     let _ = X!{&amp;B}::new ();
    ┃     ┃     ╋              ^
    ┃     ┃ Note : X --&gt; main.yr:(3,7) -&gt; X
    ┃     ┃ Error : assertion failed : main::B does not implement Useless
    ┃     ┃  --&gt; main.yr:(4,9)
    ┃     ┃  4  ┃     cte assert (is!T {U impl Useless}, T::typeid ~ &quot; does not implement Useless&quot;);
    ┃     ┃     ╋         ^^^^^^
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="print.html#condition-on-template-definition" id="condition-on-template-definition"><h2>Condition on template definition</h2></a>
<p>Every template symbol can have a complex condition that is executed at
compilation time. This condition is executed when all the template
parameter have been infered, and can be used to add further test on
the template parameters that cannot be done by the syntax provided by
<em>Ymir</em> (for example accept either a <strong><code>i32</code></strong> or a <strong><code>i64</code></strong>). The
test is defined using the <strong><code>if</code></strong> keyword followed by an expression,
the value of the expression must be known at compilation time. In this
expression the template parameters can be used. The <strong><code>if</code></strong> keyword
always followes the keyword that is used to declare the symbol
(<strong><code>def</code></strong> for function, <strong><code>class</code></strong> for classes, etc.), unlike the
template parameters that always follow the identifier of the symbol.</p>
<pre><code class="language-ymir">class if (is!T {U of i32}) A {T} {
    let value : T;

    pub self if (is!U {J of T}) {U} (v : U) with value = v {}
}

struct if (is!T {U of f64})
| x : T
-&gt; S {T};
 
enum if (is!T {U of f64})
| X = cast!T (12)
-&gt; F {T};

mod if (is!T {U of f64}) Inner {T} {
    pub def foo (a : T) {
        println (a);
    }
}

trait if (is!T {U of f64}) Z {T} {
    pub def foo (self, a : T)-&gt; T;
}

aka if (is!T {U of f64}) X {T} = cast!T (12);
</code></pre>
<p><br></p>
<p>In the following example, the function <strong><code>foo</code></strong> have a simple
template specialization, but only accepts <strong><code>i32</code></strong> or <strong><code>i64</code></strong>
types, thanks to the condition test. Because <strong><code>u64</code></strong> is not
accepted, the compiler throws an error due to line <strong><code>10</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

def if (is!{X}{T of i32} || is!{X}{T of i64}) foo {X} (x : X) {
    println (x);
}

def main () {
    foo (12);
    foo (12i64);
    foo (34u64);
}
</code></pre>
<p><br>
Errors:</p>
<pre><code class="language-error">Error : the call operator is not defined for foo {X}(x : X)-&gt; void and {u64}
 --&gt; main.yr:(10,6)
10  ┃ 	foo (34u64);
    ╋ 	    ^     ^
    ┃ Note : candidate foo --&gt; main.yr:(3,47) : foo {X}(x : X)-&gt; void
    ┃     ┃ Error : the test of the template failed with {X -&gt; u64} specialization
    ┃     ┃  --&gt; main.yr:(3,26)
    ┃     ┃  3  ┃ def if (is!{X}{T of i32} || is!{X}{T of i64}) foo {X} (x : X) {
    ┃     ┃     ╋                          ^^
    ┃     ┗━━━━━┻━ 
    ┗━━━━━┻━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<p><br></p>
<p>Template symbol with condition have a the same score than template
with the same template specialization but without a condition. For
that reason, in the following example, the call of <strong><code>foo</code></strong> at line
<strong><code>12</code></strong> create an error by the compiler. To avoid this error, the
reverse test must be added to the function <strong><code>foo</code></strong> defined at line
<strong><code>7</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

def if (is!{X}{T of i32} || is!{X}{T of i64}) foo {X} (x : X) {
    println (&quot;First : &quot;, x);
}

def foo {X} (x : X) {
    println (&quot;Second : &quot;, x);
}

def main () {
    foo (12);
}
</code></pre>
<p><br>
Errors:</p>
<pre><code class="language-error">Error : {foo {X}(x : X)-&gt; void, foo {X}(x : X)-&gt; void} x 2 called with {i32} work with both
 --&gt; main.yr:(12,6)
12  ┃ 	foo (12);
    ╋ 	    ^
    ┃ Note : candidate foo --&gt; main.yr:(3,47) : main::foo(i32)::foo (x : i32)-&gt; void
    ┃ Note : candidate foo --&gt; main.yr:(7,5) : main::foo(i32)::foo (x : i32)-&gt; void
    ┗━━━━━━ 


ymir1: fatal error: 
compilation terminated.
</code></pre>
<a class="header" href="print.html#common-tests" id="common-tests"><h2>Common tests</h2></a>
<p>The module <strong><code>std::traits</code></strong> of the standard library defines some
<em>cte</em> function that can be used to add more complex test of the type
in template condition.</p>
<table><thead><tr><th> Function </th><th> Result </th></tr></thead><tbody>
<tr><td> <strong><code>isFloating</code></strong> </td><td> true for <strong><code>f32</code></strong> and <strong><code>f64</code></strong> </td></tr>
<tr><td> <strong><code>isIntegral</code></strong> </td><td> true for any integral types (signed and unsigned) </td></tr>
<tr><td> <strong><code>isSigned</code></strong> </td><td> true for any integral types that are signed </td></tr>
<tr><td> <strong><code>isUnsigned</code></strong> </td><td> true for any integral types that are unsigned </td></tr>
<tr><td> <strong><code>isChar</code></strong> </td><td> true for <strong><code>c8</code></strong> and <strong><code>c32</code></strong> </td></tr>
<tr><td> <strong><code>isTuple</code></strong> </td><td> true for any tuple type </td></tr>
</tbody></table>
<pre><code class="language-ymir">import std::io, std::traits;

def if (isIntegral!{T} ()) foo {T} () {
    println (&quot;Accept any integral type&quot;);
}

def if (isFloating!{T} ()) foo {T} () {
    println (&quot;Accept any floating type&quot;);
}

def main () {
    foo!i32 ();
    foo!u64 ();
    foo!f32 ();
}
</code></pre>
<p><br>
Results:</p>
<pre><code>Accept any integral type
Accept any integral type
Accept any floating type
</code></pre>
<a class="header" href="print.html#common-traits" id="common-traits"><h1>Common traits</h1></a>
<p><em>Ymir</em> defines some common traits, that are either in the core files
(automatically imported modules), or in the std. This chapters
presents some of the traits that are important.</p>
<a class="header" href="print.html#streamable" id="streamable"><h1>Streamable</h1></a>
<p>Streamable objects are objects that can be put inside a
<strong><code>StringStream</code></strong>. These objects are also printable, using the
standard <strong><code>print</code></strong> or <strong><code>println</code></strong> functions. <em>Streamable</em> trait
has a default behavior, that consist in writting the typeid of the
class, followed by every fields (private and protected included) of
the class inside the stream.</p>
<a class="header" href="print.html#print-objects-to-stdout" id="print-objects-to-stdout"><h2>Print objects to stdout</h2></a>
<p>In the following example, two classes implements the traits
<strong><code>Streamable</code></strong>, and are printed to stdout. The first class <strong><code>Foo</code></strong>
does not redefine the behavior of the trait, on the other hand
<strong><code>Bar</code></strong> does.</p>
<pre><code class="language-ymir">import std::io; // the trait is accessible from std::io, or std::stream

class Foo {
    
    let _i = 12;
    let _j = &quot;Foo&quot;;

    pub self () {}
    
    impl Streamable;
}

class Bar {
    pub self () {}
    
    impl Streamable {
        pub over toStream (self, dmut stream : &amp;StringStream)-&gt; void {
            stream:.write (&quot;{I am a Bar}&quot;s8);
        }
    }	
}

def main () {
    let a = Foo::new ();
    let b = Bar::new ();
    
    println (a);
    println (b);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>main::Foo(12, Foo)
{I am a Bar}
</code></pre>
<a class="header" href="print.html#write-objects-to-stringstream" id="write-objects-to-stringstream"><h2>Write objects to StringStream</h2></a>
<p>The <strong><code>Streamable</code></strong> trait is originaly used to transform an object
into a <strong><code>[c8]</code></strong>, inside a <strong><code>&amp;StringStream</code></strong>. <strong><code>StringStream</code></strong> is
a class provided by the module <strong><code>std::stream</code></strong> that transform types
into a growing string, in a efficient manner, to avoid unefficient
string concatenation.  In the following example, instead of using the
<strong><code>print</code></strong> function, provided by <strong><code>std::io</code></strong>, the objects are added
to a <strong><code>StringStream</code></strong>, that is then printed to stdout.</p>
<pre><code class="language-ymir">import std::io; // io publically import std::stream
                

class Foo {
    
    let _i = 12;
    let _j = &quot;Foo&quot;;

    pub self () {}
    
    impl Streamable;
}

class Bar {
    pub self () {}
    
    impl Streamable {
        pub over toStream (self, dmut stream : &amp;StringStream)-&gt; void {
            stream:.write (&quot;{I am a Bar}&quot;s8);
        }
    }	
}

def main () {
    let a = Foo::new ();
    let b = Bar::new ();

    let dmut stream = StringStream::new ();

    a.toStream (alias stream); 
    stream:.write (&quot;\n&quot;s8)	 // write returns the stream
          :.writeln (b) // the method write of a stringstream call the method toStream
          :.write (&quot;Hello : &quot;, 42); // everything can be added inside a stringstream
    
    println (stream []); // the operator [], gets the slice [c8] contained inside the stream (without copying it).
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>main::Foo(12, Foo)
{I am a Bar}
Hello : 42
</code></pre>
<a class="header" href="print.html#copiable" id="copiable"><h2>Copiable</h2></a>
<p><em>Copiable</em> trait is a core trait, (defined in a core file, thus does
not need to be imported). This trait is used to override the
<strong><code>dcopy</code></strong> operator on a class. <strong>Contribution</strong>: for the moment
there is no default behavior for the Copiable trait, even if it is
completely possible. <em>Copiable</em> trait defines a method <strong><code>deepCopy</code></strong>
that takes a immutable object instance, and return a deeply mutable
one.</p>
<pre><code class="language-ymir">import std::io;

class Foo {
    let mut _type : [c8];
    
    pub self () with _type = &quot;I am an original&quot;s8 {}
    
    pub def change (mut self) {
        self._type = &quot;I am modified&quot;s8;
    }
    
    impl Copiable;	
    impl Streamable; // convinient for debugging
}


def main () {
    let dmut a = Foo::new ();
    let dmut b = dcopy a; // same as alias (a.deepCopy ())
    
    b:.change ();
    
    println (a);
    println (b);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>main::Foo(I am an original)
main::Foo(I am modified)
</code></pre>
<a class="header" href="print.html#disposable" id="disposable"><h1>Disposable</h1></a>
<p><em>Disposable</em> trait is a trait used to perform an operation at the end
of the life of an object instance. Unlike class destructor, the
dispose operation must be called by hand. There is no default behavior
for the <em>Disposable</em> trait. This trait can be coupled with the
<strong><code>with</code></strong> scope guard. Briefly in a word, this scope guards define a
variable (or a list of variable), like the <strong><code>let</code></strong> statement, but
ensure that it is disposed when the scope is exited, no matter what
happend in the scope. The <em>Disposable</em> trait is commonly used for
unmanaged memory (File, TcpStream, Mutex, ...).</p>
<pre><code class="language-ymir">import std::io;

class Foo {
    pub self () {}
    
    impl Disposable {
        
        pub over dispose (mut self) {
            println (&quot;I am disposed&quot;);
        }			
    }	
    
    impl Streamable;
}

def main () {
    with dmut a = Foo::new () {
        println (a);
    }
    println (&quot;After a&quot;);
}
</code></pre>
<p><br>
Results :</p>
<pre><code>main::Foo()
I am disposed
After a
</code></pre>
<p><br></p>
<p>A good practice is to call the <strong><code>dispose</code></strong> method inside the
destructor of the class. This way, even if the class was not disposed
by hand, it is disposed when the garbage collector destroy the
instance. (<strong>Warning</strong> to avoid multiple disposing the method
<strong><code>dispose</code></strong> shoud verify that the object is not already disposed,
e.g. the method can be called twice by hand, or first by hand, and
then by the destructor).</p>
<a class="header" href="print.html#hashable" id="hashable"><h1>Hashable</h1></a>
<p><em>Hashable</em> trait (importable from <strong><code>std::hash</code></strong>) is used to
transform an object instance into a <strong><code>u64</code></strong>. The interest is to
easily compare objects, for example in
<strong><code>std::collection::map::HashMap</code></strong>, or
<strong><code>std::collection::set::HashSet</code></strong>. <em>Hashable</em> classes can be used in
these collections as key. A default behavior is defined in this trait,
but the method <strong><code>hash</code></strong> can be redefined, it takes a immutable
object instance as parameter, and return a <strong><code>u64</code></strong> value.</p>
<pre><code class="language-ymir">import std::io;
import std::collection::map;
import std::hash;

class Foo {
    let _v : [c8];

    pub self (v : [c8]) with _v = v {}
    
    impl Hashable, Streamable;
}


def main () {
    let dmut coll = HashMap!{&amp;Foo, i32}::new ();
    coll:.insert (Foo::new (&quot;X&quot;s8), 12);
    coll:.insert (Foo::new (&quot;Y&quot;s8), 34);
    
    println (coll);	
    println (Foo::new (&quot;X&quot;s8) in coll);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>{main::Foo(X)=&gt;12, main::Foo(Y)=&gt;34}
true
</code></pre>
<a class="header" href="print.html#packable" id="packable"><h1>Packable</h1></a>
<p><em>Packable</em> trait (importable from <strong><code>std::net::packet</code></strong>) defines two
methods <strong><code>pack</code></strong> and <strong><code>unpack</code></strong>. There is a default behavior for
those two methods, and it is recommended to not override them, unless
you know exactly what you are doing. The <strong><code>pack</code></strong> method takes a
immutable object instance as parameter and creates a packet of
<strong><code>[u8]</code></strong>, encoding the object. This packet can then be sent throw
network, and unpack from another processes.</p>
<pre><code class="language-ymir">import std::io;
import std::net::packet;

class Foo {
    let _v : [c8];
    
    pub self (v : [c8]) with _v = v {}
    
    impl Packable;
}


def main () {
    let a = Foo::new (&quot;Test&quot;s8);

    let packet = a.pack ();
    println (packet);
}
</code></pre>
<p><br>
Results :</p>
<pre><code>[9, 0, 0, 0, 0, 0, 0, 0, 34, 6d, 61, 69, 6e, 33, 46, 6f, 6f, 4, 0, 0, 0, 0, 0, 0, 0, 54, 65, 73, 74]
</code></pre>
<p><br></p>
<p>The packet can then be unpacked with the function <strong><code>unpack</code></strong>. This
function returns an <strong><code>Object</code></strong>, that can be transformed in the
appropriate type using pattern matching.</p>
<pre><code class="language-ymir">    {
        match unpack (packet) {
            x : &amp;Foo  =&gt; println (x);
            _ =&gt; {
                println (&quot;Unkown packet&quot;);
            }
        }
    } catch {
        UnpackError () =&gt; {
            println (&quot;The packet contains unknwon information&quot;);
        }
    }
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>main::Foo(Test)
</code></pre>
<p><br></p>
<p><strong>Warning</strong> to work properly, the unpacker must have access to the
type information of the object that is packed. Otherwise, an
<em>UnpackError</em> is thrown. To make the symbol available in the unpacking
program, the class must be compiled and linked in it. For example, if
a module <strong><code>foo</code></strong> contains a class <strong><code>Foo</code></strong>, and the unpacking is
made inside the **<code>main</code> module. The command line of the compilation
must be :</p>
<pre><code class="language-bash">gyc main.yr foo.yr
</code></pre>
<p><br></p>
<p>It is possible to verify that the symbol are present in the
executable, by running the following command (example for the class
<strong><code>Foo</code></strong> of the previous example).</p>
<pre><code class="language-bash">$ objdump -t a.out | grep Foo
0000000000410585 g     F .text	00000000000004a0              _Y3std3net6packet8Packable27__stdnetwork__unpackContentFxP9x3foo3FooSu8Zusize
0000000000447300  w    O .data	0000000000000030              _Y3foo3FooTI
0000000000410a25 g     F .text	000000000000006e              _Y3std3net6packet8Packable25__stdnetwork__packContentFP83foo3FooxP32x3std10collection3vec6VecNu83VecZv
000000000040eb82 g     F .text	0000000000000054              _Y3foo3Foo4selfFxP9x3foo3FooSc8ZxP9x3foo3Foo
00000000004472f0  w    O .data	0000000000000010              _Y133foo3Foo_nameCSTxSc32
0000000000447340  w    O .data	0000000000000030              _Y3foo3FooVT
000000000040f468 g     F .text	0000000000000093              _Y3std3net6packet8Packable4packFP83foo3FooxP32x3std10collection3vec6VecNu83VecZv
000000000040f381 g     F .text	00000000000000e7              _Y3std3net6packet8Packable4packFP83foo3FooZSu8
00000000004472c0  w    O .data	0000000000000024              _Y183foo3Foo_nameInnerCSTxA9c32
</code></pre>
<p><br></p>
<p>In the result of this command, the symbol <strong><code>_Y3foo3FooTI</code></strong> is
present, this is the symbol containing the type info of the
<strong><code>foo::Foo</code></strong> class, <strong><code>_Y3foo3FooVT</code></strong> contains the vtable, and
<strong><code>_Y3std3net6packet8Packable27__stdnetwork__unpackContentFxP9x3foo3FooSu8Zusize</code></strong>
the function called to unpack the object. These are the three
mandatory symbols to successfully unpack a object (the other symbols
are necessarily there if the vtable is present).</p>
<p>I think this is not a strong problem, as it can be easily resolved;
but must be taken into account when compiling the program.</p>
<p><strong>Contribution</strong>: Almost every types are packable. I think the only
two types that are not are function pointer and closure. I see how
function pointer packing can be done, and it is not difficult and will
be done in future version of the std. On the other hand, because the
type info of the closure is not accessible, i don't see any way of
packing this type. In any case, closure behavior can be easily
simulated by using a object instance, or a structure and a function
pointer. And trying to pack a not packable type creates compile time
errors, so there is no bad surprise at runtime.</p>
<a class="header" href="print.html#serializable" id="serializable"><h2>Serializable</h2></a>
<p>Like <em>Packable</em> trait, <em>Serializable</em> is a trait that transform an
object instance into something that can be stored, or sent. However,
unlike <em>Packable</em>, the result is humanely readable, and can be used to
create configuration files for example (current std implements
<strong>toml</strong> and <strong>json</strong> serialization). <em>Serializable</em> objects
implements the method <strong><code>serialize</code></strong>. It has no default behavior
(<strong>Contribution</strong> it is however probably possible to create a default
behavior based on the name of the fields). This method takes an
immutable object instance, and return a <strong><code>&amp;Config</code></strong> value.</p>
<pre><code class="language-ymir">import std::io;
import std::config::conv;
import std::config, std::config::toml;


struct
| A : &amp;Foo
| B : &amp;Foo
 -&gt; Bar;

class Foo {
    let _v : [c32];
    let _u : i32;
    
    pub self (v : [c32], u : i32) with _v = v, _u = u{
    }

    impl Serializable {
        pub over serialize (self)-&gt;  &amp;Config {
            let dmut d = Dict::new ();
            d:.insert (&quot;v&quot;, self._v.to!(&amp;Config) ());
            d:.insert (&quot;u&quot;, self._u.to!(&amp;Config) ());

            d
        }
    }
}


def main () {
    let x = Bar (Foo::new (&quot;Test&quot;, 12), Foo::new (&quot;Test2&quot;, 34));	
    println (toml::dump (x.to!(&amp;Config) ()));
}
</code></pre>
<p><br>
Results :</p>
<pre><code>
[A]
u = 12
v = &quot;Test&quot;

[B]
u = 34
v = &quot;Test2&quot;

</code></pre>
<a class="header" href="print.html#operator-overloading" id="operator-overloading"><h1>Operator overloading</h1></a>
<p>Ymir proposes the possibility of overloading the operators. The
operator overload is done by rewriting the operations applied on
objects operands. No new syntax is used to define operator
overloading, as compilation time values (<em>cf</em>. <a href=""></a>) are used.</p>
<p>There are multiple types of operators that can be overloaded, the
<em>unary operators</em>, <em>binary operators</em>, <em>comparison operators</em>, <em>access
operator</em>, <em>contain operator</em>, and the <em>for loop</em>. The presentation is
divided in two parts, the first one presents the operator that are
generally applicable to any type, and the second part presents the
operator overloading of set objects.</p>
<a class="header" href="print.html#simple-operator-overloading" id="simple-operator-overloading"><h1>Simple operator overloading</h1></a>
<p>This chapter presents the standard operator overloading : <em>unary</em>, <em>binary</em> and <em>comparison</em>.</p>
<a class="header" href="print.html#unary-operator" id="unary-operator"><h2>Unary operator</h2></a>
<p>Unary operators are operators that are applied to only one
operand. The overloading of the operator is made by defining a
template method inside the class definition. The name of the template
method must be <strong><code>opUnary</code></strong>, and must take a template value as first
argument. The table bellow lists the rewrite operations that are done
by the compiler to call the correct template method for operator
overloading.</p>
<table><thead><tr><th> expression </th><th> rewrite </th></tr></thead><tbody>
<tr><td> -e </td><td> e.opUnary!(&quot;-&quot;) </td></tr>
<tr><td> *e </td><td> e.opUnary!(&quot;*&quot;) </td></tr>
<tr><td> !e </td><td> e.opUnary!(&quot;!&quot;) </td></tr>
</tbody></table>
<p>In the following example, the class <strong><code>A</code></strong> has two <strong><code>opUnary</code></strong>
methods. The first one at line <strong>8</strong>, is applicable with the operator
<strong><code>-</code></strong>, and the second one at line <strong>12</strong> is applicable with any
other operators.</p>
<pre><code class="language-ymir">import std::io;

class A  {
    let _a : f32;
    
    pub self (a : f32) with _a = a {} 
    
    pub def opUnary {&quot;-&quot;} (self) -&gt; &amp;A {
        A::new (-self._a)
    }
    
    pub def opUnary {op : [c32]} (self) -&gt; &amp;A {
        cte if (op == &quot;!&quot;) // op is compile time known
            A::new (1.f / self._a)
        else // operator '+'
            self
    }

    impl Streamable;
}

def main () {
    let a = A::new (10.0f);
    println (!a); 
}
</code></pre>
<p><br></p>
<p>This example, call the method defined at line <strong>12</strong> by using the
operator <strong><code>!</code></strong>. In this method the value of <strong><code>op</code></strong> is known at
compile time, and thus can be compared (also at compile time). The
<strong><code>!</code></strong> unary operator is defined for the class <strong>A</strong> as giving the
inverse of the value stored in the object, thus the result is the
following :</p>
<pre><code>main::A(0.10000)
</code></pre>
<a class="header" href="print.html#binary-operator" id="binary-operator"><h2>Binary operator</h2></a>
<p>Binary operators are also overloadable. As for unary operators, the
overloading of binary operators is made by code rewritting at compile
time. In the case of binary operators, the operation involves two
different operands, one of them must be an object instance.</p>
<p>The following operators are overloadable. The use indicated in the
left column is only an indication and corresponds to the common use of
these operators, but they can of course be used for other purposes.</p>
<table>
<tbody>
<tr>
<td align="left"><bold>Math</bold></td>
<td align="center"><code>+</code></td>
<td align="center"><code>-</code></td>
<td align="center"><code>*</code></td>
<td align="center"><code>/</code></td>
<td align="center"><code>%</code></td>
<td align="center"><code>^^</code></td>
</tr>
<tr>
<td align="left"><bold>Bitwise</bold></td>
<td align="center"><code>|</code></td>
<td align="center"><code>&</code></td>
<td align="center"><code>^</code></td>
<td align="center"><code> << </code></td>
<td align="center"><code> >> </code></td>
</tr>
<tr>
<td align="left"><bold>Array</bold></td>
<td align="center"><code>~</code></td>
</tr>
</tbody>
</table>
<!-- |     |     |      |      |     |      | -->
<!-- | --- | --- | ---- | --- | --- | ---- | -->
<!-- | `+` |	`-`	| `*`  | `/` |	`%` | `^^` | -->
<!-- | `\|` | `^` | `<<` | `>>` |	`~` | `&`  | -->
<p>The following example presents a class <strong><code>A</code></strong> that overload the
operator <strong><code>+</code></strong> and <strong><code>-</code></strong> using a <strong><code>i32</code></strong> as a second operand.</p>
<pre><code class="language-ymir">import std::io;

class A {
    let _a : i32;

    pub self (a : i32) with _a = a {}

    pub def opBinary {&quot;+&quot;} (self, a : i32) -&gt; &amp;A {
        A::new (self._a + a)
    }

    pub def opBinary {&quot;-&quot;} (self, a : i32) -&gt; &amp;A {
        A::new (self._a - a)
    }
    
    impl Streamable;
}

def main () {
    let a = A::new (12);
    println (a - 30);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>main::A(-18)
</code></pre>
<p><br></p>
<p>Because there are two operands (sometimes of different types), binary
operation can sometimes be not commutative (for example the math
binary operator <strong><code>-</code></strong>). To resolve that problem the rewritting is
made in two different steps, the first step tries to rewritte the
operation using the method <strong><code>opBinary</code></strong>, if this first rewritte
failed a second rewritte is made, but this time using the right
operand and by calling the method <strong><code>opBinaryRight</code></strong>. If the right
operator is not defined, the compiler <strong>does not</strong> try to make the
operation commutative, the two methods must be defined.</p>
<pre><code class="language-ymir">import std::io;

class A {
    let _a : i32;

    pub self (a : i32) with _a = a {}

    pub def opBinaryRight {&quot;-&quot;} (self, a : i32) -&gt; &amp;A {
        A::new (a - self._a)
    }
    
    impl Streamable;
}

def main () {
    let a = A::new (12);
    println (54 - a);
}
</code></pre>
<p><br>
Results:</p>
<pre><code>main::A(42)
</code></pre>
<a class="header" href="print.html#limitations" id="limitations"><h2>Limitations</h2></a>
<p>For the moment, templates method cannot be overriden by children
classes. For that reason, it is impossible to override the behavior of
the binary operator of an ancestor class. The limitation is the same
for unary operators. However, to allow such behavior, the overloading
method can call a standard method (without template), that is
overridable by a children class. An example is presented in the
following source code.</p>
<pre><code class="language-ymir">import std::io

class A {

    let _i : i32;
    pub self (i : i32) with _i = i {}
    
    pub def opBinary {&quot;+&quot;} (self, i : i32) -&gt; &amp;A {
        self.add (i)
    }

    pub def add (self, i : i32)-&gt; &amp;A {
        A::new (i + self._i)
    }

    impl Streamable;
}

class B over A {
    pub self (i : i32) with super (i) {}

    pub over add (self, i : i32)-&gt; &amp;A {
        B::new (i * self._i)
    }

    impl Streamable;
}

def main () {
    let mi = B::new (8);
    println (mi + 8);
}
</code></pre>
<p><strong>Contribution</strong> How to override template method is currently under
discussion ! But it seems impossible for many reasons that are not
discussed here, you can contact us for more information.</p>
<a class="header" href="print.html#comparison-operators" id="comparison-operators"><h2>Comparison operators</h2></a>
<p>The equality and comparison are treated via two different methods
<code>opEquals</code> and <code>opCmp</code>. Because while almost all types can be compared
for equality, only some have meaningful order comparison.</p>
<p>The <code>opCmp</code> method is used for the operators <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code>
only. And the method <code>opEquals</code> is used for the operator <code>==</code> and
<code>!=</code>. When the method <code>opEquals</code> is not defined for the type, the
compiler will try to use the method <code>opCmp</code> instead. When both the
methods are defined, <strong>it is up to the user to ensure that these two
functions are consistent</strong>.</p>
<p>Indeed, it is impossible to verify that in a general case. For example
the operator <strong><code>&lt;</code></strong> can be used on a set object, where the operator
<code>x &lt; y</code> stand for <code>x</code> is a strict subset of <code>y</code>. Therefore, even if
neither <code>x &lt; y</code> and <code>y &lt; x</code> are true, the equality <code>x == y</code> is not
implied.</p>
<a class="header" href="print.html#overloading--and-" id="overloading--and-"><h3>Overloading == and !=</h3></a>
<p>The method <strong><code>opEquals</code></strong> is a simple method, that does not take
template arguments. Expressions of the form <code>a != b</code>, are rewritten
into <code>!(a == b)</code>, therefore there is only one method to define.</p>
<pre><code class="language-ymir">import std::io

class Point {

    let x : i32, y : i32;
    
    pub self (x : i32, y : i32) with x = x, y = y {}
    
    pub def opEquals (self, other : &amp;Point) -&gt; bool {
        self.x == other.x &amp;&amp; self.y == other.y
    }
    
}

def main () 
    throws &amp;AssertError 
{
    let a = Point::new (1, 2);
    let b = Point::new (2, 3);
    let c = Point::new (1, 2);
    assert (a == c);
    assert (a != b);
}
</code></pre>
<p><br></p>
<p>The operator <code>opEquals</code> is assumed <strong>commutative</strong>, thus when the
operator is only defined for the type on the right operand, the
operation will simply be rewritten reversely. The following example
presents such a case, where the operator <strong><code>opEquals</code></strong> is only
defined by the class <strong><code>A</code></strong>. The line <strong>19</strong> is simple rewritten into
<strong><code>mi.opEquals (8)</code></strong>.</p>
<pre><code class="language-ymir">import std::io

class MyInt {

    let i : i32;
    
    pub self (i : i32) with i = i {}
    
    pub def opEquals (self, i : i32) -&gt; bool {
    self.i == i
    }
    
}

def main ()
    throws &amp;AssertError
{
    let mi = MyInt::new (8);
    assert (8 == mi);
}
</code></pre>
<a class="header" href="print.html#overloading----and--" id="overloading----and--"><h3>Overloading &lt;, &gt;, &lt;= and  &gt;=</h3></a>
<p>The method <strong><code>opCmp</code></strong> is used to compare an object to another
value. The comparison unlike equality evaluation, gives a comparison
order between two values. The method <strong><code>opCmp</code></strong> does not take any
template parameter, but returns an integer value. A negative value
meaning that the left operand is lower than the right operand, an
positive value, that the left operand is higher than the right one,
and a nul value that both operands are equals.</p>
<p>The following table lists the possible rewritting of the comparison
operators. As we can see in this table, the operator is assumed to be
not commutative, thus if the first rewritting fails to compile (for
type reason), then the second rewritting is used.</p>
<table><thead><tr><th> comparison </th><th> rewrite 1 </th><th> rewrite 2 </th></tr></thead><tbody>
<tr><td> a &lt; b </td><td> a.opCmp (b) &lt; 0 </td><td> b.opCmp (a) &gt; 0 </td></tr>
<tr><td> a &gt; b </td><td> a.opCmp (b) &gt; 0 </td><td> b.opCmp (a) &lt; 0 </td></tr>
<tr><td> a &lt;= b </td><td> a.opCmp (b) &lt;= 0 </td><td> b.opCmp (a) &gt;= 0 </td></tr>
<tr><td> a &gt;= b </td><td> a.opCmp (b) &gt;= 0 </td><td> b.opCmp (a) &gt;= 0 </td></tr>
</tbody></table>
<p>In the following example, a comparison operator is used at line
<strong><code>19</code></strong>, the rewritting <strong><code>(7).opCmp (mi) &lt; 0</code></strong> does not compile,
because <strong><code>7</code></strong> is not an object value, and thus does not have any
method. The second rewritting is thus used, <strong><code>mi.opCmp (7) &gt; 0</code></strong>.</p>
<pre><code class="language-ymir">import std::io

class MyInt {

    let i : i32;
    
    pub self (i : i32) with i = i {}
    
    pub def opCmp (self, i : i32) -&gt; i32 {
        self.i - i
    }
    
}

def main ()
    throws &amp;AssertError
{
    let mi = MyInt::new (8);
    assert (7 &lt; mi);
}
</code></pre>
<a class="header" href="print.html#assignment" id="assignment"><h2>Assignment</h2></a>
<p>The assignment operator is not overloadable, it will always perform
the same operation. However, the shortcut operators <strong><code>+=</code>, <code>-=</code>,
<code>*=</code></strong> etc, are usable on object when oveloading the binary
operator. This operation is simply rewritten at compilation time, for
example the expression <strong><code>a += 12</code></strong> is rewritten into <strong><code>a = a.opBinary!{&quot;+&quot;}(12)</code></strong>. The following example presents an utilisation
example of the <strong><code>+=</code></strong> shortcut.</p>
<pre><code class="language-ymir">import std::io

class MyInt {

    let _i : i32;
    
    pub self (i : i32) with _i = i {}

    pub def opBinary {&quot;+&quot;} (self, a : i32)-&gt; &amp;MyInt {
        MyInt::new (self._i + a)
    }
    
    impl Streamable;
}

def main () {
    let mut mi = MyInt::new (8);
    mi += 9;
    println (mi);
}
</code></pre>
<p><br></p>
<p>Results:</p>
<pre><code>main::MyInt(17)
</code></pre>
<p><br></p>
<p>One can note that the instance of the object stored in the variable
<strong><code>mi</code></strong> is changed after the affectation. This is the standard
behavior of the <strong><code>=</code></strong> operator.</p>
<a class="header" href="print.html#set-operators" id="set-operators"><h1>Set operators</h1></a>
<p>In this chapter are presented the operators related to set object. The
operators are : <em>access</em>, <em>contains</em> and <em>iteration</em> operators.</p>
<a class="header" href="print.html#access-operator" id="access-operator"><h2>Access operator</h2></a>
<p>The operator of index <code>[]</code> is overloadable by the method
<code>opIndex</code>. This method is called with the parameters passed inside of
the brackets of the index operator. For example, the following
operation <code>a [b, c, d]</code> is rewritten into <code>a.opIndex (b, c, d)</code>.</p>
<pre><code class="language-ymir">import std::io

class A {
    let dmut i : [i32];
    
    pub self (a : [i32]) with i = copy a {}
    
    pub def opIndex (self, x : i32) -&gt; i32 
        throws &amp;OutOfArray
    {
        self.i [x]
    }

    impl Streamable;
    
}

def main () 
    throws &amp;OutOfArray, &amp;AssertError
{
    let i = A::new ([1, 2, 3]);
    assert (i [2] == 3);
}
</code></pre>
<p><br></p>
<p>One can note from the above example, that the object stored in <strong><code>i</code></strong>
is immutable, and that the <strong><code>opIndex</code></strong> is always a right operand. It
is possible to modify the values inside the <strong><code>i</code></strong> object (if it is
mutable) using the <strong><code>opIndexAssign</code></strong> method. This method rewritte
the assignement operation where the left operand is an access
operation. The following example presents an example of usage of this
method.</p>
<pre><code class="language-ymir">import std::io

class A {
    let dmut i : [i32];
    
    pub self (a : [i32]) with i = copy a {}
    
    pub def opIndex (self, x : i32) -&gt; i32 
        throws &amp;OutOfArray
    {
        self.i [x]
    }

    pub def opIndexAssign (mut self, x : i32, z : i32)
        throws &amp;OutOfArray
    {
        self.i [x] = z;
    }

    impl Streamable;
    
}

def main () 
    throws &amp;OutOfArray, &amp;AssertError
{
    let dmut i = A::new ([1, 2, 3]);

    (alias i) [2] = 9; // alias is important, otherwise the method is not callable
    println (i);
    
    assert (i [2] == 9);
}
</code></pre>
<p><br>
Results:</p>
<pre><code>main::A([1, 2, 9])
</code></pre>
<a class="header" href="print.html#contains-operator" id="contains-operator"><h2>Contains operator</h2></a>
<p>The contain operator is a binary operator used to check if an element
is inside another one. This operator is defined using the keyword
<code>in</code>. Unlike other operator, the rewritte for the overloading is made
only once on the right operand, and call the method <code>opContains</code>, for
example the expression <strong><code>a in b</code></strong> is rewritten into <strong><code>b.opContains (a)</code></strong>. The expression <code>a !in b</code> will be rewritten into <code>!(a in b)</code>.</p>
<pre><code class="language-ymir">class A {
    
    let _a : [i32];
    
    pub self (a : [i32]) with _a = a {}
    
    pub def opContains (self, i : i32)-&gt; bool {
    for j in self._a {
        if (i == j) return true;
    }
    false
    }	
}

def main () 
    throws &amp;AssertError
{
    let i = A::new ([1, 2, 3]);
    assert (2 in i);
    assert (9 !in i);
}
</code></pre>
<a class="header" href="print.html#iteration-operator" id="iteration-operator"><h2>Iteration operator</h2></a>
<p>Object can be iterated using a <em>for loop</em>. As for any operators, the
<em>for loop</em> used on object is rewritten at compilation time. There are
multiple methods to write when writting an iterable class. The
following source code present an example of a <em>for loop</em>, and the
source code underneath it present its rewritten equivalent.</p>
<pre><code class="language-ymir">let a = A::new ();
for i, j in a {
    println (i, &quot; &quot;, j);
}
</code></pre>
<p><br></p>
<pre><code class="language-ymir">let a = A::new ();
{
    let dmut iter = a.begin ();
    while !iter.opEquals (a.end ()) {
        let i = iter.get!{0} ();
        let j = iter.get!{1} ();
        {
            println (i, &quot; &quot;, j);
        }
        iter:.next ();
    }
}
</code></pre>
<p><br></p>
<p>In this example, two elements can be highlighted: 1) the <strong><code>iter</code></strong>
variable, that stores an iterator object, 2) the <strong><code>begin</code></strong> and
<strong><code>end</code></strong> method of the class <strong><code>A</code></strong>. Indeed, an iterable object is
an object that contains two methods <strong><code>begin</code></strong> and <strong><code>end</code></strong>, that
returns an mutable iterator pointing respectivelly to the beginning
and to the end of the iterable set.</p>
<p>The iterator type is a type defined by the user, and that contains the
<strong><code>opEquals</code></strong> method, a method <strong><code>next</code></strong> on a mutable instance, and
the method <strong><code>get</code></strong>, template method thats returns value pointed by
the current iteration.</p>
<p>The following example presents the implementation of a <strong><code>Range</code></strong>
that has the same behavior as a <strong><code>r!i32</code></strong> with a step <strong><code>1</code></strong> and a
not including the end value.</p>
<pre><code class="language-ymir">import std::io;

class Range {
    let _fst : i32;
    let _lst : i32;
    
    pub self (fst : i32, lst : i32) with _fst = fst, _lst = lst {}
    
    pub def begin (self)-&gt; dmut &amp;Iterator { // must return a dmut value
        Iterator::new (self._fst)
    }
    
    pub def end (self)-&gt; &amp;Iterator {
        Iterator::new (self._lst)
    }
    
    impl Streamable;
}

class Iterator {
    let mut _curr : i32;
    
    pub self (curr : i32) with _curr = curr {}
    
    pub def get {0} (self) -&gt; i32 {
        self._curr
    }
    
    pub def opEquals (self, o : &amp;Iterator) -&gt; bool {
        self._curr == o._curr
    }

    pub def next (mut self) {
        self._curr += 1;
    }
}


def main () {
    let mut r = Range::new (0, 10);
    for i in r {
        println (i);
    }
}
</code></pre>
<p><br></p>
<p>To be more efficient and avoid a new allocation at each iteration, the
<strong><code>end</code></strong> method should return a value that is computed once.</p>
<p><strong>Contribution</strong> Enhance this section, which is completely
unclear. And add information about error handling maybe.</p>
<a class="header" href="print.html#version" id="version"><h1>Version</h1></a>
<p>Version is another conditional compilation process (in addition to
<em>compile time execution</em> with templates), that select parts of the
code that must be compiled or not. The following code block presents
the grammar of the <em>version</em> declaration and expression.</p>
<pre><code class="language-grammar">version_decl := '__version' Identifier '{' declaration '}' ('else' declaration)?
version_expr := '__version' Identifier block ('else' expression)?
</code></pre>
<p><br></p>
<p>The identifier used in the version block are in their own name space,
meaning that they do not conflict with the other identifiers
(variable, types, etc...). <strong>Warning</strong> the identifier of the version
is not case sensitive, thus <strong><code>Demo</code></strong> and <strong><code>DEMO</code></strong> are
identical. The version are activated by the command line using the
option <strong><code>-fversion</code></strong>. In the following example the version
<strong><code>Demo</code></strong>, and <strong><code>Full</code></strong> are used.</p>
<pre><code class="language-ymir">import std::io;

__version Demo {
    def foo () {
        println (&quot;Foo of the demo version&quot;);
    }
} else {
    __version Full {
        def foo () {
            println (&quot;Foo of the full version&quot;);
        }
    }	
}

def main () {
    foo ();
}
</code></pre>
<p><br></p>
<pre><code class="language-bash">$ gyc main.yr -fversion=Demo
$ ./a.out
Foo of the demo version

$ gyc main.yr -fversion=Full
$ ./a.out
Foo of the full version
</code></pre>
<p><br></p>
<p>To use multiple version, the option must be set for each version.</p>
<pre><code class="language-bash">$ gyc main.yr -fversion=Demo -fversion=Full
</code></pre>
<a class="header" href="print.html#debug-version" id="debug-version"><h2>Debug version</h2></a>
<p>The debug option of the command line <strong><code>-g</code></strong> activates the
<strong><code>Debug</code></strong> version even without the option <strong><code>-fversion</code></strong>.</p>
<pre><code class="language-ymir">import std::io;

def foo () {
    __version DEBUG {
        println (&quot;Entering foo&quot;);
    }
    
    println (&quot;foo&quot;);
}

def main () {
    foo ();
}
</code></pre>
<p><br></p>
<pre><code class="language-bash">$ gyc main.yr -g
$ ./a.out
Entering foo
foo

$ gyc main.yr
$ ./a.out
foo
</code></pre>
<a class="header" href="print.html#predefined-versions" id="predefined-versions"><h2>Predefined versions</h2></a>
<p><strong>Contribution</strong> There is no predefined version for the moment, but it
is a work in progress. These versions will depend on the compiler, os,
etc..</p>
<a class="header" href="print.html#macro" id="macro"><h1>Macro</h1></a>
<p>Macros are used to perform operation at a syntactic level, instead of
a semantic level, as it is done by all the other symbols. A macro call
is an expansion of a syntaxic element.</p>
<p>Macros are defined using the keyword <strong><code>macro</code></strong>. They contains two
kind of elements, constructors and rules.</p>
<pre><code class="language-ymir">import std::io;

macro Vec {
    pub self (x = __expr &quot;,&quot; y = __expr z=foo) skips (&quot; &quot;) {
        #{z};
        println (&quot;#{x}&quot;);
        println (&quot;#{y}&quot;);
    }

    pub def foo (z=__expr rest=(__expr y=&quot;machin&quot;)) {
        println (&quot;#{z}#{rest::y}&quot;);
    }
}


def main () {
    Vec#{1,2 9 9 machin};
}
</code></pre>
<a class="header" href="print.html#documentation" id="documentation"><h1>Documentation</h1></a>
<p>The <em>Ymir</em> compiler is able to generate documentation files
automatically. These documentation files in <em>json</em> format are easier
to read for a documenation generator than a source code. The option
<strong><code>-fdoc</code></strong> generates documentation file for each compiled
modules. The name of the <em>json</em> file is the path of the module, where
the double colon operators <strong><code>::</code></strong> are replace with underscores
<strong><code>_</code></strong>.</p>
<pre><code class="language-bash">$ tree
.
└── foo
    └── bar
        └── baz.yr

2 directories, 1 file

$ gyc foo/bar/baz.yr -fdoc
$ ls 
foo  foo__bar__baz.doc.json
</code></pre>
<p><br></p>
<p>The following chapters present the json format of the different
declarations (functions, class, etc...). The first chapter presents
the encoding of the types, and the second the encoding of the symbols.</p>
<p><strong>Contribution</strong> A very basic standard documentation website generator
is under development <a href="https://github.com/GNU-Ymir/ydoc">ydoc</a>.</p>
<a class="header" href="print.html#ymir-type" id="ymir-type"><h1>Ymir Type</h1></a>
<p>Ymir type are the value type (<em>cf</em>. <a href="https://gnu-ymir.github.io/Documentations/en/primitives/types.html">Data
types</a>). They
are not always validated for many reasons (templates, aka, ...). The
<strong><code>type</code></strong> value contains the kind of type that is encoded,
<strong><code>unknown</code></strong> means that the type cannot be validated, and is always
associated with <strong><code>name</code></strong> that contains the string name of the type.</p>
<p>Each type contains the attribute <strong><code>mut</code></strong> set to <strong><code>true</code></strong> or
<strong><code>false</code></strong>.</p>
<a class="header" href="print.html#integer" id="integer"><h2>Integer</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>int</code> </td></tr>
<tr><td> <code>name</code> </td><td> <code>i8</code> V <code>u8</code> V <code>i32</code> etc... </td></tr>
</tbody></table>
<a class="header" href="print.html#void" id="void"><h2>Void</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>void</code> </td></tr>
<tr><td> <code>name</code> </td><td> <code>void</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#boolean" id="boolean"><h2>Boolean</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>bool</code> </td></tr>
<tr><td> <code>name</code> </td><td> <code>bool</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#floating" id="floating"><h2>Floating</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>float</code> </td></tr>
<tr><td> <code>name</code> </td><td> <code>f32</code> V <code>f64</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#char" id="char"><h2>Char</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>char</code> </td></tr>
<tr><td> <code>name</code> </td><td> <code>c8</code> V <code>c32</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#array" id="array"><h2>Array</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>array</code> </td></tr>
<tr><td> <code>size</code> </td><td> The size in a string </td></tr>
<tr><td> <code>childs</code> </td><td> An array containing the inner type of the array </td></tr>
</tbody></table>
<a class="header" href="print.html#slice" id="slice"><h2>Slice</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>slice</code> </td></tr>
<tr><td> <code>childs</code> </td><td> An array containing the inner type of the slice </td></tr>
</tbody></table>
<a class="header" href="print.html#tuple-1" id="tuple-1"><h2>Tuple</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>tuple</code> </td></tr>
<tr><td> <code>childs</code> </td><td> An array containing the list of inner type of the tuple </td></tr>
</tbody></table>
<a class="header" href="print.html#struct" id="struct"><h2>Struct</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>struct</code> </td></tr>
<tr><td> <code>name</code> </td><td> The name of the structure </td></tr>
</tbody></table>
<a class="header" href="print.html#enum" id="enum"><h2>Enum</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>enum</code> </td></tr>
<tr><td> <code>name</code> </td><td> The name of the enum </td></tr>
</tbody></table>
<a class="header" href="print.html#pointer" id="pointer"><h2>Pointer</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>pointer</code> </td></tr>
<tr><td> <code>childs</code> </td><td> An array containing the inner type of the pointer </td></tr>
</tbody></table>
<a class="header" href="print.html#classpointer" id="classpointer"><h2>ClassPointer</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>class_pointer</code> </td></tr>
<tr><td> <code>childs</code> </td><td> An array containing the inner type of the pointer </td></tr>
</tbody></table>
<a class="header" href="print.html#range" id="range"><h2>Range</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>range</code> </td></tr>
<tr><td> <code>childs</code> </td><td> An array containing the inner type of the range </td></tr>
</tbody></table>
<a class="header" href="print.html#function-pointer-1" id="function-pointer-1"><h2>Function pointer</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>fn_pointer</code> </td></tr>
<tr><td> <code>childs</code> </td><td> An array containing the parameter types of the function pointer </td></tr>
<tr><td> <code>ret_type</code> </td><td> The return type of the function pointer </td></tr>
</tbody></table>
<a class="header" href="print.html#closure-1" id="closure-1"><h2>Closure</h2></a>
<p><strong>Warning</strong> the closure here is the element contained inside a delegate, not the delegate type</p>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>closure</code> </td></tr>
<tr><td> <code>childs</code> </td><td> An array containing the inner types of the closure </td></tr>
</tbody></table>
<a class="header" href="print.html#delegate" id="delegate"><h2>Delegate</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>dg_pointer</code> </td></tr>
<tr><td> <code>childs</code> </td><td> An array containing the parameter types of the delegate pointer </td></tr>
<tr><td> <code>ret_type</code> </td><td> The return type of the function pointer </td></tr>
</tbody></table>
<a class="header" href="print.html#option-1" id="option-1"><h2>Option</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>option</code> </td></tr>
<tr><td> <code>childs</code> </td><td> An array containing the inner type of the option </td></tr>
</tbody></table>
<a class="header" href="print.html#unknown" id="unknown"><h2>Unknown</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>unknown</code> </td></tr>
<tr><td> <code>name</code> </td><td> The string name of the type </td></tr>
</tbody></table>
<a class="header" href="print.html#symbols" id="symbols"><h1>Symbols</h1></a>
<p>Each element contains standard information :</p>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> The type of the symbol (<code>module</code>, <code>function</code>, etc..) </td></tr>
<tr><td> <code>name</code> </td><td> The name of the symbol </td></tr>
<tr><td> <code>loc_file</code> </td><td> The name of the file containing the symbol </td></tr>
<tr><td> <code>loc_line</code> </td><td> The number of the line at which the symbol is declared </td></tr>
<tr><td> <code>loc_column</code> </td><td> The number of the column at which the symbol is declared </td></tr>
<tr><td> <code>doc</code> </td><td> The documentation associated with the symbol (user comments) </td></tr>
<tr><td> <code>protection</code> </td><td> The protection of the symbol (<code>pub</code> V <code>prot</code> V <code>prv</code>) </td></tr>
</tbody></table>
<a class="header" href="print.html#module" id="module"><h2>Module</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>module</code> </td></tr>
<tr><td> <code>childs</code> </td><td> The symbols declared inside the module </td></tr>
</tbody></table>
<a class="header" href="print.html#function" id="function"><h2>Function</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>function</code> </td></tr>
<tr><td> <code>attributes</code> </td><td> The custom attributes of the function </td></tr>
<tr><td> <code>params</code> </td><td> The list of parameters of the function </td></tr>
<tr><td> <code>ret_type</code> </td><td> The return type of the function </td></tr>
<tr><td> <code>throwers</code> </td><td> The list of type that can be thrown by the function </td></tr>
</tbody></table>
<p>The parameters are defined according to the following table :</p>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>name</code> </td><td> The name of the parameter </td></tr>
<tr><td> <code>type</code> </td><td> The type of the parameter (ymir type) </td></tr>
<tr><td> <code>mut</code> </td><td> <code>true</code> V <code>false</code> </td></tr>
<tr><td> <code>ref</code> </td><td> <code>true</code> V <code>false</code> </td></tr>
<tr><td> <code>value</code> </td><td> Can be unset if the variable has no value, encoded in a string </td></tr>
</tbody></table>
<a class="header" href="print.html#variable-declaration" id="variable-declaration"><h2>Variable declaration</h2></a>
<p>Declaration of a static global variable.</p>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>var</code> </td></tr>
<tr><td> <code>mut</code> </td><td> <code>true</code> V <code>false</code> </td></tr>
<tr><td> <code>var_type</code> </td><td> The ymir type of the variable </td></tr>
<tr><td> <code>value</code> </td><td> Can be unset if the variable has no value, encoded in a string </td></tr>
</tbody></table>
<a class="header" href="print.html#aka-1" id="aka-1"><h2>Aka</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>aka</code> </td></tr>
<tr><td> <code>value</code> </td><td> The value of the aka, encoded in a string </td></tr>
</tbody></table>
<p>The value of the aka is encoded in a string, because as <strong><code>aka</code></strong> are
only evaluated when used, we can't have more information on them.</p>
<a class="header" href="print.html#structure-1" id="structure-1"><h2>Structure</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>struct</code> </td></tr>
<tr><td> <code>attributes</code> </td><td> <code>union</code>, <code>packed</code> </td></tr>
<tr><td> <code>fields</code> </td><td> The list of fields of the structure </td></tr>
</tbody></table>
<a class="header" href="print.html#fields-2" id="fields-2"><h3>Fields</h3></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>name</code> </td><td> The name of the field </td></tr>
<tr><td> <code>type</code> </td><td> The ymir type of the field </td></tr>
<tr><td> <code>mut</code> </td><td> <code>true</code> V <code>false</code> </td></tr>
<tr><td> <code>doc</code> </td><td> The user documentation about the field </td></tr>
<tr><td> <code>value</code> </td><td> Set if the field has a default value, encoded in a string </td></tr>
</tbody></table>
<a class="header" href="print.html#enumeration-1" id="enumeration-1"><h2>Enumeration</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>enum</code> </td></tr>
<tr><td> <code>en_type</code> </td><td> The ymir type of the enumeration fields </td></tr>
<tr><td> <code>fields</code> </td><td> The fields of the enum </td></tr>
</tbody></table>
<a class="header" href="print.html#fields-3" id="fields-3"><h3>Fields</h3></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>name</code> </td><td> The name of the field </td></tr>
<tr><td> <code>doc</code> </td><td> The user comments about the field </td></tr>
<tr><td> <code>value</code> </td><td> The value associated with the field, in a string </td></tr>
</tbody></table>
<a class="header" href="print.html#class-1" id="class-1"><h2>Class</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>class</code> </td></tr>
<tr><td> <code>ancestor</code> </td><td> Set if the class has an ancestor, ymir type </td></tr>
<tr><td> <code>abstract</code> </td><td> <code>true</code> V <code>false</code> </td></tr>
<tr><td> <code>final</code> </td><td> <code>true</code> V <code>false</code> </td></tr>
<tr><td> <code>fields</code> </td><td> The fields of the class </td></tr>
<tr><td> <code>asserts</code> </td><td> The list of static assertion inside the class </td></tr>
<tr><td> <code>cstrs</code> </td><td> The list of constructor of the class </td></tr>
<tr><td> <code>impls</code> </td><td> The list of implementation of the class </td></tr>
<tr><td> <code>methods</code> </td><td> The list of methods of the class </td></tr>
</tbody></table>
<a class="header" href="print.html#fields-4" id="fields-4"><h3>Fields</h3></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>name</code> </td><td> The name of the field </td></tr>
<tr><td> <code>type</code> </td><td> The ymir type of the field </td></tr>
<tr><td> <code>mut</code> </td><td> <code>true</code> V <code>false</code> </td></tr>
<tr><td> <code>doc</code> </td><td> The user comments about the field </td></tr>
<tr><td> <code>protection</code> </td><td> <code>prv</code> V <code>prot</code> V <code>pub</code> </td></tr>
<tr><td> <code>value</code> </td><td> Set if the field has a default value, inside a string </td></tr>
</tbody></table>
<a class="header" href="print.html#asserts" id="asserts"><h3>Asserts</h3></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>test</code> </td><td> The condition in a string </td></tr>
<tr><td> <code>msg</code> </td><td> The msg of the assert </td></tr>
<tr><td> <code>doc</code> </td><td> The user comment about the assertion </td></tr>
</tbody></table>
<a class="header" href="print.html#constructors" id="constructors"><h3>Constructors</h3></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>cstr</code> </td></tr>
<tr><td> <code>params</code> </td><td> The list of parameters of the constructor, identical to those of a function </td></tr>
<tr><td> <code>throws</code> </td><td> The list of ymir types thrown by the constructor </td></tr>
</tbody></table>
<a class="header" href="print.html#implementations" id="implementations"><h3>Implementations</h3></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>impl</code> </td></tr>
<tr><td> <code>trait</code> </td><td> The name of the trait, in a string </td></tr>
<tr><td> <code>childs</code> </td><td> The list of overriden methods, identical to methods </td></tr>
</tbody></table>
<a class="header" href="print.html#methods-1" id="methods-1"><h3>Methods</h3></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>method</code> </td></tr>
<tr><td> <code>over</code> </td><td> <code>true</code> V <code>false</code> </td></tr>
<tr><td> <code>params</code> </td><td> The list of parameters of the method, identical to function </td></tr>
<tr><td> <code>ret_type</code> </td><td> The ymir type of the return type </td></tr>
<tr><td> <code>attributes</code> </td><td> <code>virtual</code>, <code>final</code>, <code>mut</code> </td></tr>
<tr><td> <code>throwers</code> </td><td> The list of types thrown by the method </td></tr>
</tbody></table>
<p>A virtual method is method with no body, and a mutable method is a
method that accepts only a mutable object.</p>
<a class="header" href="print.html#traits" id="traits"><h2>Traits</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>trait</code> </td></tr>
<tr><td> <code>childs</code> </td><td> The list of method inside the trait </td></tr>
</tbody></table>
<a class="header" href="print.html#templates-1" id="templates-1"><h2>Templates</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>template</code> </td></tr>
<tr><td> <code>test</code> </td><td> Set if the template has a test, in a string </td></tr>
<tr><td> <code>params</code> </td><td> The list of parameter of the template, in strings </td></tr>
<tr><td> <code>childs</code> </td><td> The list of symbol inside the template </td></tr>
</tbody></table>
<a class="header" href="print.html#macros" id="macros"><h2>Macros</h2></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>type</code> </td><td> <code>macro</code> </td></tr>
<tr><td> <code>cstrs</code> </td><td> The list of constructor of the macro </td></tr>
<tr><td> <code>rules</code> </td><td> The list of rules of the macro </td></tr>
</tbody></table>
<a class="header" href="print.html#constructors-and-rules" id="constructors-and-rules"><h3>Constructors and Rules</h3></a>
<table><thead><tr><th> Name </th><th> Value </th></tr></thead><tbody>
<tr><td> <code>rule</code> </td><td> The rule of the macro in a string </td></tr>
<tr><td> <code>skips</code> </td><td> The list of token skiped, list of string </td></tr>
</tbody></table>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        
        <script>
            $(document).ready(function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        
        <script type="text/javascript" src="custom.js"></script>
        

    </body>
</html>
